From 9425a3cbffd7e828649ce9b3848aa9215230845d Mon Sep 17 00:00:00 2001
From: Maxwell McKee <66395252+mamckee@users.noreply.github.com>
Date: Thu, 2 Mar 2023 10:51:34 -0800
Subject: [PATCH] SymCrypt provider base (#57)

* Minimally viable provider

* Algorithm table stubs

* Stub out dispatch tables

* Prototype digests with macros

* Create common code

* Refactor common source files into library

* Stub remaining funciton tables

* SymCrypt init in provider init

* Add sha3 digests

* Macro definitions for common functions

* Clean up digest implementation based on default provider model

* Add SAL annotations to digests

* SAL annotate provider base

* Finish stubbing and cleanup

* Rename

* Add errors to provider

* Prefix scossl engine-specific names with e_

* Cleanup scossl_helpers

* Cleanup naming

* Additional cleanup

* Fix name change in digests

* Return scossl_failure for failure case

* Address PR comments

* Remove unnecessary checks
---
 .gitignore                                    |   5 +-
 .vscode/settings.json                         |  21 --
 CMakeLists.txt                                |   2 +
 ScosslCommon/CMakeLists.txt                   |  20 ++
 .../src => ScosslCommon/inc}/scossl_helpers.h |  14 +-
 .../src/scossl_helpers.c                      |  12 +-
 SslPlay/CMakeLists.txt                        |   7 +
 SslPlay/SslPlay.cpp                           |   6 +-
 SymCryptEngine/dynamic/CMakeLists.txt         |  12 +-
 SymCryptEngine/inc/scossl.h                   |  12 +-
 SymCryptEngine/src/scossl.c                   | 181 ++++++------
 SymCryptEngine/src/scossl_ciphers.c           | 216 +++++++-------
 SymCryptEngine/src/scossl_ciphers.h           |   7 +-
 SymCryptEngine/src/scossl_dh.c                |  68 ++---
 SymCryptEngine/src/scossl_dh.h                |  13 +-
 SymCryptEngine/src/scossl_digests.c           | 154 +++++-----
 SymCryptEngine/src/scossl_digests.h           |  11 +-
 SymCryptEngine/src/scossl_dsa.c               |  10 +-
 SymCryptEngine/src/scossl_dsa.h               |  11 +-
 SymCryptEngine/src/scossl_ecc.c               | 116 ++++----
 SymCryptEngine/src/scossl_ecc.h               |  23 +-
 SymCryptEngine/src/scossl_hkdf.c              | 140 ++++-----
 SymCryptEngine/src/scossl_hkdf.h              |  11 +-
 SymCryptEngine/src/scossl_hmac.c              |  72 ++---
 SymCryptEngine/src/scossl_hmac.h              |  17 +-
 SymCryptEngine/src/scossl_pkey_meths.c        | 154 +++++-----
 SymCryptEngine/src/scossl_pkey_meths.h        |   7 +-
 SymCryptEngine/src/scossl_rand.c              |  26 +-
 SymCryptEngine/src/scossl_rand.h              |   3 +-
 SymCryptEngine/src/scossl_rsa.c               |  62 ++--
 SymCryptEngine/src/scossl_rsa.h               |  29 +-
 SymCryptEngine/src/scossl_rsapss.c            |  36 +--
 SymCryptEngine/src/scossl_rsapss.h            |   5 +-
 SymCryptEngine/src/scossl_sshkdf.c            |  74 ++---
 SymCryptEngine/src/scossl_sshkdf.h            |   3 +-
 SymCryptEngine/src/scossl_tls1prf.c           |  20 +-
 SymCryptEngine/src/scossl_tls1prf.h           |  11 +-
 SymCryptEngine/static/CMakeLists.txt          |  13 +-
 SymCryptProvider/CMakeLists.txt               |  47 ++++
 SymCryptProvider/inc/p_scossl_base.h.in       |  31 ++
 SymCryptProvider/src/p_scossl_base.c          | 265 ++++++++++++++++++
 SymCryptProvider/src/p_scossl_ciphers.h       |  33 +++
 SymCryptProvider/src/p_scossl_digests.c       |  54 ++++
 SymCryptProvider/src/p_scossl_digests.h       | 103 +++++++
 SymCryptProvider/src/p_scossl_kdfs.h          |  28 ++
 SymCryptProvider/src/p_scossl_keyexch.h       |  29 ++
 SymCryptProvider/src/p_scossl_keymgmt.h       |  41 +++
 SymCryptProvider/src/p_scossl_signature.h     |  40 +++
 48 files changed, 1476 insertions(+), 799 deletions(-)
 delete mode 100644 .vscode/settings.json
 create mode 100644 ScosslCommon/CMakeLists.txt
 rename {SymCryptEngine/src => ScosslCommon/inc}/scossl_helpers.h (93%)
 rename {SymCryptEngine => ScosslCommon}/src/scossl_helpers.c (97%)
 create mode 100644 SymCryptProvider/CMakeLists.txt
 create mode 100644 SymCryptProvider/inc/p_scossl_base.h.in
 create mode 100644 SymCryptProvider/src/p_scossl_base.c
 create mode 100644 SymCryptProvider/src/p_scossl_ciphers.h
 create mode 100644 SymCryptProvider/src/p_scossl_digests.c
 create mode 100644 SymCryptProvider/src/p_scossl_digests.h
 create mode 100644 SymCryptProvider/src/p_scossl_kdfs.h
 create mode 100644 SymCryptProvider/src/p_scossl_keyexch.h
 create mode 100644 SymCryptProvider/src/p_scossl_keymgmt.h
 create mode 100644 SymCryptProvider/src/p_scossl_signature.h

diff --git a/.gitignore b/.gitignore
index 9100c32..223aad1 100644
--- a/.gitignore
+++ b/.gitignore
@@ -378,4 +378,7 @@ _deps
 ### VisualStudioCode ###
 .vscode/*
 
-*.pem
\ No newline at end of file
+*.pem
+
+# Files generated by cmake #
+SymCryptProvider/inc/p_scossl_base.h
\ No newline at end of file
diff --git a/.vscode/settings.json b/.vscode/settings.json
deleted file mode 100644
index a5db022..0000000
--- a/.vscode/settings.json
+++ /dev/null
@@ -1,21 +0,0 @@
-{
-    "files.associations": {
-        "e_symcrypt_digests.h": "c",
-        "cstring": "cpp",
-        "array": "cpp",
-        "deque": "cpp",
-        "string": "cpp",
-        "unordered_map": "cpp",
-        "vector": "cpp",
-        "string_view": "cpp",
-        "initializer_list": "cpp",
-        "random": "c",
-        "system_error": "cpp",
-        "functional": "c",
-        "istream": "c",
-        "ostream": "c",
-        "tuple": "c",
-        "type_traits": "c",
-        "utility": "c"
-    }
-}
\ No newline at end of file
diff --git a/CMakeLists.txt b/CMakeLists.txt
index 28fa1d1..8ac7521 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -26,6 +26,8 @@ else()
     add_compile_options(-DDBG=1)
 endif()
 
+add_subdirectory (ScosslCommon)
 add_subdirectory (SymCryptEngine/static)
 add_subdirectory (SymCryptEngine/dynamic)
+add_subdirectory (SymCryptProvider)
 add_subdirectory (SslPlay)
diff --git a/ScosslCommon/CMakeLists.txt b/ScosslCommon/CMakeLists.txt
new file mode 100644
index 0000000..2b395d8
--- /dev/null
+++ b/ScosslCommon/CMakeLists.txt
@@ -0,0 +1,20 @@
+cmake_minimum_required(VERSION 3.13.0)
+
+project(scossl_common_lib)
+
+set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -fPIC -Wall -Wextra -Wno-unused-parameter -Wno-unknown-pragmas")
+set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fPIC -std=c++1y -Wall -Wextra -Wno-unused-parameter")
+
+find_package(OpenSSL REQUIRED)
+include_directories(${OPENSSL_INCLUDE_DIR})
+
+set(SCOSSL_SOURCES
+    ./src/scossl_helpers.c
+)
+
+add_library(scossl_common STATIC ${SCOSSL_SOURCES})
+
+target_include_directories(scossl_common PUBLIC ./inc)
+target_include_directories(scossl_common PRIVATE ./src)
+
+set_target_properties(scossl_common PROPERTIES OUTPUT_NAME "scosslcommon")
\ No newline at end of file
diff --git a/SymCryptEngine/src/scossl_helpers.h b/ScosslCommon/inc/scossl_helpers.h
similarity index 93%
rename from SymCryptEngine/src/scossl_helpers.h
rename to ScosslCommon/inc/scossl_helpers.h
index b13d68c..a28ee0c 100644
--- a/SymCryptEngine/src/scossl_helpers.h
+++ b/ScosslCommon/inc/scossl_helpers.h
@@ -4,10 +4,13 @@
 
 #pragma once
 
-#include "scossl.h"
 #include <symcrypt.h>
 #include <string.h>
 
+#include <openssl/ossl_typ.h>
+#include <openssl/crypto.h>
+#include <openssl/engine.h>
+
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -27,6 +30,15 @@ typedef _Return_type_success_(return >= 0) int SCOSSL_RETURNLENGTH; // For funct
 // Only applies in certain contexts (used when implementing EVP-layer functionality)
 #define SCOSSL_UNSUPPORTED (-2)
 
+#define SCOSSL_LOG_LEVEL_NO_CHANGE  (-1)
+#define SCOSSL_LOG_LEVEL_OFF        (0)
+#define SCOSSL_LOG_LEVEL_ERROR      (1) // DEFAULT for OpenSSL ERR
+#define SCOSSL_LOG_LEVEL_INFO       (2) // DEFAULT for stderr / logging to logfile
+#define SCOSSL_LOG_LEVEL_DEBUG      (3)
+
+void SCOSSL_set_trace_level(int trace_level, int ossl_ERR_level);
+void SCOSSL_set_trace_log_filename(const char *filename);
+
 // Functions to set up and destroy SCOSSL logging static variables, locks, and integration with
 // OpenSSL ERR infrastructure. Should only be called in Engine bind / destroy.
 void scossl_setup_logging();
diff --git a/SymCryptEngine/src/scossl_helpers.c b/ScosslCommon/src/scossl_helpers.c
similarity index 97%
rename from SymCryptEngine/src/scossl_helpers.c
rename to ScosslCommon/src/scossl_helpers.c
index d30afad..bb5850e 100644
--- a/SymCryptEngine/src/scossl_helpers.c
+++ b/ScosslCommon/src/scossl_helpers.c
@@ -11,7 +11,7 @@
 extern "C" {
 #endif
 
-#define SCOSSL_ENGINE_TRACELOG_PARA_LENGTH  (256)
+#define SCOSSL_TRACELOG_PARA_LENGTH  (256)
 
 #define SCOSSL_LOG_LEVEL_PREFIX_ERROR       "ERROR"
 #define SCOSSL_LOG_LEVEL_PREFIX_INFO        "INFO"
@@ -125,7 +125,7 @@ void scossl_setup_logging()
         ERR_load_strings(_scossl_err_library_code, SCOSSL_ERR_reason_strings);
 
         _loggingLock = CRYPTO_THREAD_lock_new();
-        SCOSSL_ENGINE_set_trace_log_filename(NULL);
+        SCOSSL_set_trace_log_filename(NULL);
     }
 }
 
@@ -134,7 +134,7 @@ void scossl_destroy_logging()
     CRYPTO_THREAD_lock_free(_loggingLock);
 }
 
-void SCOSSL_ENGINE_set_trace_level(int trace_level, int ossl_ERR_level)
+void SCOSSL_set_trace_level(int trace_level, int ossl_ERR_level)
 {
     if( trace_level >= SCOSSL_LOG_LEVEL_OFF &&
         trace_level <= SCOSSL_LOG_LEVEL_DEBUG )
@@ -148,7 +148,7 @@ void SCOSSL_ENGINE_set_trace_level(int trace_level, int ossl_ERR_level)
     }
 }
 
-void SCOSSL_ENGINE_set_trace_log_filename(const char *filename)
+void SCOSSL_set_trace_log_filename(const char *filename)
 {
     if( _traceLogFilename )
     {
@@ -188,8 +188,8 @@ static void _scossl_log_bytes_valist(
     const char *format,
     va_list args)
 {
-    char errStringBuf[SCOSSL_ENGINE_TRACELOG_PARA_LENGTH];
-    char paraBuf[SCOSSL_ENGINE_TRACELOG_PARA_LENGTH];
+    char errStringBuf[SCOSSL_TRACELOG_PARA_LENGTH];
+    char paraBuf[SCOSSL_TRACELOG_PARA_LENGTH];
     char *trace_level_prefix = "";
 
     if( SYMCRYPT_MAX(_traceLogLevel, _osslERRLogLevel) < trace_level )
diff --git a/SslPlay/CMakeLists.txt b/SslPlay/CMakeLists.txt
index fb301bd..04fcc65 100644
--- a/SslPlay/CMakeLists.txt
+++ b/SslPlay/CMakeLists.txt
@@ -10,13 +10,20 @@ add_executable (SslPlay
     SslPlay.cpp
 )
 
+set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wno-deprecated-declarations")
+set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wno-deprecated-declarations")
+
 if (SCOSSL_SSHKDF)
     set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -DSCOSSL_SSHKDF")
     set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -DSCOSSL_SSHKDF")
 endif()
 
 
+add_dependencies(SslPlay scossl_common)
+
 target_link_directories(SslPlay PUBLIC ${CMAKE_BINARY_DIR} ${CMAKE_INSTALL_LIBDIR})
 target_include_directories(SslPlay PUBLIC ${CMAKE_SOURCE_DIR}/SymCryptEngine/inc)
+target_include_directories(SslPlay PUBLIC ../ScosslCommon/inc)
 
 target_link_libraries(SslPlay PUBLIC scossl_dynamic ${OPENSSL_CRYPTO_LIBRARY})
+target_link_libraries(SslPlay PRIVATE scossl_common)
diff --git a/SslPlay/SslPlay.cpp b/SslPlay/SslPlay.cpp
index 1fbcf05..5f77bdf 100644
--- a/SslPlay/SslPlay.cpp
+++ b/SslPlay/SslPlay.cpp
@@ -1707,11 +1707,11 @@ void TestTls1Prf(void)
             handleOpenSSLError("EVP_PKEY_CTX_set_tls1_prf_md");
             goto end;
         }
-        if (EVP_PKEY_CTX_set1_tls1_prf_secret(pctx, "secret", 6) <= 0) {
+        if (EVP_PKEY_CTX_set1_tls1_prf_secret(pctx, reinterpret_cast<const unsigned char*>("secret"), 6) <= 0) {
             handleOpenSSLError("EVP_PKEY_CTX_set1_tls1_prf_secret");
             goto end;
         }
-        if (EVP_PKEY_CTX_add1_tls1_prf_seed(pctx, "seed", 4) <= 0) {
+        if (EVP_PKEY_CTX_add1_tls1_prf_seed(pctx, reinterpret_cast<const unsigned char*>("seed"), 4) <= 0) {
             handleOpenSSLError("EVP_PKEY_CTX_add1_tls1_prf_seed");
             goto end;
         }
@@ -2283,7 +2283,7 @@ int main(int argc, char** argv)
     if (argc >= 3) {
         scossl_ossl_ERR_level = atoi(argv[2]);
     }
-    SCOSSL_ENGINE_set_trace_level(scossl_log_level, scossl_ossl_ERR_level);
+    SCOSSL_set_trace_level(scossl_log_level, scossl_ossl_ERR_level);
     SCOSSL_ENGINE_Initialize();
     bio_err = BIO_new_fp(stdout, BIO_NOCLOSE);
 
diff --git a/SymCryptEngine/dynamic/CMakeLists.txt b/SymCryptEngine/dynamic/CMakeLists.txt
index ef72372..c6b0c8e 100644
--- a/SymCryptEngine/dynamic/CMakeLists.txt
+++ b/SymCryptEngine/dynamic/CMakeLists.txt
@@ -6,15 +6,15 @@ set(DEFAULT_BUILD_TYPE "Release")
 
 include(GNUInstallDirs)
 
-set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wall -Wextra -Wno-unused-parameter -Wno-unknown-pragmas")
-set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++1y -Wall -Wextra -Wno-unused-parameter")
+set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wall -Wextra -Wno-deprecated-declarations -Wno-unused-parameter -Wno-unknown-pragmas")
+set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++1y -Wall -Wextra -Wno-deprecated-declarations -Wno-unused-parameter")
 
 find_package(OpenSSL REQUIRED)
 include_directories(${OPENSSL_INCLUDE_DIR})
 
 find_library(SYMCRYPT_LIBRARY symcrypt PATHS ${CMAKE_SOURCE_DIR})
 
-set(SCOSSL_SOURCES 
+set(SCOSSL_SOURCES
     ../src/scossl.c
     ../src/scossl_ciphers.c
     ../src/scossl_dh.c
@@ -28,7 +28,6 @@ set(SCOSSL_SOURCES
     ../src/scossl_hkdf.c
     ../src/scossl_tls1prf.c
     ../src/scossl_hmac.c
-    ../src/scossl_helpers.c
 )
 
 if (SCOSSL_SSHKDF)
@@ -38,17 +37,20 @@ if (SCOSSL_SSHKDF)
 endif()
 
 add_library(scossl_dynamic SHARED ${SCOSSL_SOURCES})
+add_dependencies(scossl_dynamic scossl_common)
 
 set_target_properties(scossl_dynamic PROPERTIES PUBLIC_HEADER ../inc/scossl.h)
 # target_link_libraries(scossl_dynamic ${OPENSSL_CRYPTO_LIBRARY})
 target_include_directories(scossl_dynamic PUBLIC ../inc)
 target_include_directories(scossl_dynamic PRIVATE ../src)
-target_include_directories (scossl_dynamic PUBLIC ${CMAKE_CURRENT_SOURCE_DIR})
+target_include_directories(scossl_dynamic PUBLIC ${CMAKE_CURRENT_SOURCE_DIR})
+target_include_directories(scossl_dynamic PUBLIC ../ScosslCommon/inc)
 
 # Remove default "lib" prefix from symcryptengine.so as OpenSSL engine is not a generic Linux .so
 set_target_properties(scossl_dynamic PROPERTIES PREFIX "")
 set_target_properties(scossl_dynamic PROPERTIES OUTPUT_NAME "symcryptengine")
 
+target_link_libraries(scossl_dynamic PRIVATE scossl_common)
 target_link_libraries(scossl_dynamic PUBLIC ${SYMCRYPT_LIBRARY})
 target_link_libraries(scossl_dynamic PUBLIC ${OPENSSL_CRYPTO_LIBRARY})
 
diff --git a/SymCryptEngine/inc/scossl.h b/SymCryptEngine/inc/scossl.h
index 3593432..c2fd9f9 100644
--- a/SymCryptEngine/inc/scossl.h
+++ b/SymCryptEngine/inc/scossl.h
@@ -6,23 +6,15 @@
 #include <openssl/crypto.h>
 #include <openssl/engine.h>
 
+#include "scossl_helpers.h"
+
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-#define SCOSSL_LOG_LEVEL_NO_CHANGE  (-1)
-#define SCOSSL_LOG_LEVEL_OFF        (0)
-#define SCOSSL_LOG_LEVEL_ERROR      (1) // DEFAULT for OpenSSL ERR
-#define SCOSSL_LOG_LEVEL_INFO       (2) // DEFAULT for stderr / logging to logfile
-#define SCOSSL_LOG_LEVEL_DEBUG      (3)
-
-void SCOSSL_ENGINE_set_trace_level(int trace_level, int ossl_ERR_level);
-void SCOSSL_ENGINE_set_trace_log_filename(const char *filename);
-
 // SymCrypt-OpenSSL Engine Initialization.
 int SCOSSL_ENGINE_Initialize();
 
-
 #ifdef __cplusplus
 }
 #endif
diff --git a/SymCryptEngine/src/scossl.c b/SymCryptEngine/src/scossl.c
index 0e62490..e102062 100644
--- a/SymCryptEngine/src/scossl.c
+++ b/SymCryptEngine/src/scossl.c
@@ -11,42 +11,41 @@
 #include "scossl_ciphers.h"
 #include "scossl_pkey_meths.h"
 #include "scossl_rand.h"
-#include "scossl_helpers.h"
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-int scossl_module_initialized = 0;
+int e_scossl_module_initialized = 0;
 
 /* The constants used when creating the ENGINE */
-static const char* engine_scossl_id = "symcrypt";
-static const char* engine_scossl_name = "SCOSSL (SymCrypt engine for OpenSSL)";
-static EC_KEY_METHOD* scossl_eckey_method = NULL;
-static RSA_METHOD* scossl_rsa_method = NULL;
-// static DSA_METHOD* scossl_dsa_method = NULL;
-static DH_METHOD* scossl_dh_method = NULL;
+static const char* e_scossl_id = "symcrypt";
+static const char* e_scossl_name = "SCOSSL (SymCrypt engine for OpenSSL)";
+static EC_KEY_METHOD* e_scossl_eckey_method = NULL;
+static RSA_METHOD* e_scossl_rsa_method = NULL;
+// static DSA_METHOD* e_scossl_dsa_method = NULL;
+static DH_METHOD* e_scossl_dh_method = NULL;
 
-SCOSSL_STATUS scossl_destroy(ENGINE* e)
+SCOSSL_STATUS e_scossl_destroy(ENGINE* e)
 {
-    if( scossl_eckey_method != NULL )
+    if( e_scossl_eckey_method != NULL )
     {
-        scossl_destroy_digests();
-        scossl_destroy_ciphers();
-        scossl_destroy_pkey_methods();
-        RSA_meth_free(scossl_rsa_method);
-        scossl_rsa_method = NULL;
-        scossl_destroy_ecc_curves();
-        EC_KEY_METHOD_free(scossl_eckey_method);
-        scossl_eckey_method = NULL;
-        CRYPTO_free_ex_index(CRYPTO_EX_INDEX_RSA, scossl_rsa_idx);
-        CRYPTO_free_ex_index(CRYPTO_EX_INDEX_EC_KEY, scossl_eckey_idx);
-        // DSA_meth_free(scossl_dsa_method);
-        // scossl_dsa_method = NULL;
-        scossl_destroy_safeprime_dlgroups();
-        DH_meth_free(scossl_dh_method);
-        scossl_dh_method = NULL;
-        CRYPTO_free_ex_index(CRYPTO_EX_INDEX_DH, scossl_dh_idx);
+        e_scossl_destroy_digests();
+        e_scossl_destroy_ciphers();
+        e_scossl_destroy_pkey_methods();
+        RSA_meth_free(e_scossl_rsa_method);
+        e_scossl_rsa_method = NULL;
+        e_scossl_destroy_ecc_curves();
+        EC_KEY_METHOD_free(e_scossl_eckey_method);
+        e_scossl_eckey_method = NULL;
+        CRYPTO_free_ex_index(CRYPTO_EX_INDEX_RSA, e_scossl_rsa_idx);
+        CRYPTO_free_ex_index(CRYPTO_EX_INDEX_EC_KEY, e_scossl_eckey_idx);
+        // DSA_meth_free(e_scossl_dsa_method);
+        // e_scossl_dsa_method = NULL;
+        e_scossl_destroy_safeprime_dlgroups();
+        DH_meth_free(e_scossl_dh_method);
+        e_scossl_dh_method = NULL;
+        CRYPTO_free_ex_index(CRYPTO_EX_INDEX_DH, e_scossl_dh_idx);
         scossl_destroy_logging();
     }
 
@@ -68,104 +67,104 @@ static SCOSSL_STATUS scossl_bind_engine(ENGINE* e)
     OBJ_NAME_remove(LN_aes_128_cbc_hmac_sha256, OBJ_NAME_TYPE_CIPHER_METH);
     OBJ_NAME_remove(LN_aes_256_cbc_hmac_sha256, OBJ_NAME_TYPE_CIPHER_METH);
 
-    if( !scossl_module_initialized )
+    if( !e_scossl_module_initialized )
     {
         SYMCRYPT_MODULE_INIT();
-        scossl_module_initialized = 1;
+        e_scossl_module_initialized = 1;
     }
 
-    scossl_rsa_method = RSA_meth_dup(RSA_PKCS1_OpenSSL());
-    scossl_eckey_method = EC_KEY_METHOD_new(EC_KEY_OpenSSL());
-    // scossl_dsa_method = DSA_meth_dup(DSA_OpenSSL());
-    scossl_dh_method = DH_meth_dup(DH_OpenSSL());
+    e_scossl_rsa_method = RSA_meth_dup(RSA_PKCS1_OpenSSL());
+    e_scossl_eckey_method = EC_KEY_METHOD_new(EC_KEY_OpenSSL());
+    // e_scossl_dsa_method = DSA_meth_dup(DSA_OpenSSL());
+    e_scossl_dh_method = DH_meth_dup(DH_OpenSSL());
 
-    if( !scossl_rsa_method
-     || !scossl_eckey_method
-     // || !scossl_dsa_method
-     || !scossl_dh_method
+    if( !e_scossl_rsa_method
+     || !e_scossl_eckey_method
+     // || !e_scossl_dsa_method
+     || !e_scossl_dh_method
         )
     {
         goto end;
     }
 
     /* Setup RSA_METHOD */
-    if( (scossl_rsa_idx = RSA_get_ex_new_index(0, NULL, NULL, NULL, NULL)) == -1
-        || !RSA_meth_set1_name(scossl_rsa_method, "SCOSSL (SymCrypt engine for OpenSSL) RSA Method")
-        || !RSA_meth_set_pub_enc(scossl_rsa_method, scossl_rsa_pub_enc)
-        || !RSA_meth_set_priv_dec(scossl_rsa_method, scossl_rsa_priv_dec)
-        || !RSA_meth_set_priv_enc(scossl_rsa_method, scossl_rsa_priv_enc)
-        || !RSA_meth_set_pub_dec(scossl_rsa_method, scossl_rsa_pub_dec)
-        || !RSA_meth_set_mod_exp(scossl_rsa_method, scossl_rsa_mod_exp)
-        || !RSA_meth_set_bn_mod_exp(scossl_rsa_method, scossl_rsa_bn_mod_exp)
-        || !RSA_meth_set_init(scossl_rsa_method, scossl_rsa_init)
-        || !RSA_meth_set_finish(scossl_rsa_method, scossl_rsa_finish)
-        || !RSA_meth_set_sign(scossl_rsa_method, scossl_rsa_sign)
-        || !RSA_meth_set_verify(scossl_rsa_method, scossl_rsa_verify)
-        || !RSA_meth_set_keygen(scossl_rsa_method, scossl_rsa_keygen)
+    if( (e_scossl_rsa_idx = RSA_get_ex_new_index(0, NULL, NULL, NULL, NULL)) == -1
+        || !RSA_meth_set1_name(e_scossl_rsa_method, "SCOSSL (SymCrypt engine for OpenSSL) RSA Method")
+        || !RSA_meth_set_pub_enc(e_scossl_rsa_method, e_scossl_rsa_pub_enc)
+        || !RSA_meth_set_priv_dec(e_scossl_rsa_method, e_scossl_rsa_priv_dec)
+        || !RSA_meth_set_priv_enc(e_scossl_rsa_method, e_scossl_rsa_priv_enc)
+        || !RSA_meth_set_pub_dec(e_scossl_rsa_method, e_scossl_rsa_pub_dec)
+        || !RSA_meth_set_mod_exp(e_scossl_rsa_method, e_scossl_rsa_mod_exp)
+        || !RSA_meth_set_bn_mod_exp(e_scossl_rsa_method, e_scossl_rsa_bn_mod_exp)
+        || !RSA_meth_set_init(e_scossl_rsa_method, e_scossl_rsa_init)
+        || !RSA_meth_set_finish(e_scossl_rsa_method, e_scossl_rsa_finish)
+        || !RSA_meth_set_sign(e_scossl_rsa_method, e_scossl_rsa_sign)
+        || !RSA_meth_set_verify(e_scossl_rsa_method, e_scossl_rsa_verify)
+        || !RSA_meth_set_keygen(e_scossl_rsa_method, e_scossl_rsa_keygen)
         )
     {
         goto end;
     }
 
     /* Setup EC_METHOD */
-    if( (scossl_eckey_idx = EC_KEY_get_ex_new_index(0, NULL, NULL, NULL, NULL)) == -1 )
+    if( (e_scossl_eckey_idx = EC_KEY_get_ex_new_index(0, NULL, NULL, NULL, NULL)) == -1 )
     {
         goto end;
     }
 
-    EC_KEY_METHOD_set_init(scossl_eckey_method,
+    EC_KEY_METHOD_set_init(e_scossl_eckey_method,
                            NULL, // eckey_init - lazily initialize ex_data only when the engine needs to
-                           scossl_eckey_finish,
+                           e_scossl_eckey_finish,
                            NULL, // eckey_copy
                            NULL, // eckey_set_group
                            NULL, // eckey_set_private
                            NULL); // eckey_set_public
-    EC_KEY_METHOD_set_keygen(scossl_eckey_method,
-                             scossl_eckey_keygen);
-    EC_KEY_METHOD_set_compute_key(scossl_eckey_method,
-                                  scossl_eckey_compute_key);
-    EC_KEY_METHOD_set_sign(scossl_eckey_method,
-                           scossl_eckey_sign,
-                           scossl_eckey_sign_setup,
-                           scossl_eckey_sign_sig);
-    EC_KEY_METHOD_set_verify(scossl_eckey_method,
-                             scossl_eckey_verify,
-                             scossl_eckey_verify_sig);
+    EC_KEY_METHOD_set_keygen(e_scossl_eckey_method,
+                             e_scossl_eckey_keygen);
+    EC_KEY_METHOD_set_compute_key(e_scossl_eckey_method,
+                                  e_scossl_eckey_compute_key);
+    EC_KEY_METHOD_set_sign(e_scossl_eckey_method,
+                           e_scossl_eckey_sign,
+                           e_scossl_eckey_sign_setup,
+                           e_scossl_eckey_sign_sig);
+    EC_KEY_METHOD_set_verify(e_scossl_eckey_method,
+                             e_scossl_eckey_verify,
+                             e_scossl_eckey_verify_sig);
 
     // /* Setup DSA METHOD */
-    // if (   !DSA_meth_set_sign(scossl_dsa_method, scossl_dsa_sign)
-    //     || !DSA_meth_set_sign_setup(scossl_dsa_method, scossl_dsa_sign_setup)
-    //     || !DSA_meth_set_verify(scossl_dsa_method, scossl_dsa_verify)
-    //     || !DSA_meth_set_init(scossl_dsa_method, scossl_dsa_init)
-    //     || !DSA_meth_set_finish(scossl_dsa_method, scossl_dsa_finish)
+    // if (   !DSA_meth_set_sign(e_scossl_dsa_method, e_scossl_dsa_sign)
+    //     || !DSA_meth_set_sign_setup(e_scossl_dsa_method, e_scossl_dsa_sign_setup)
+    //     || !DSA_meth_set_verify(e_scossl_dsa_method, e_scossl_dsa_verify)
+    //     || !DSA_meth_set_init(e_scossl_dsa_method, e_scossl_dsa_init)
+    //     || !DSA_meth_set_finish(e_scossl_dsa_method, e_scossl_dsa_finish)
     //     )
     // {
     //     goto end;
     // }
 
     // /* Setup DH METHOD */
-    if (   (scossl_dh_idx = DH_get_ex_new_index(0, NULL, NULL, NULL, NULL)) == -1
-        || !DH_meth_set1_name(scossl_dh_method, "SCOSSL (SymCrypt engine for OpenSSL) DH Method")
-        || !DH_meth_set_generate_key(scossl_dh_method, scossl_dh_generate_key)
-        || !DH_meth_set_compute_key(scossl_dh_method, scossl_dh_compute_key)
-        || !DH_meth_set_finish(scossl_dh_method, scossl_dh_finish)
+    if (   (e_scossl_dh_idx = DH_get_ex_new_index(0, NULL, NULL, NULL, NULL)) == -1
+        || !DH_meth_set1_name(e_scossl_dh_method, "SCOSSL (SymCrypt engine for OpenSSL) DH Method")
+        || !DH_meth_set_generate_key(e_scossl_dh_method, e_scossl_dh_generate_key)
+        || !DH_meth_set_compute_key(e_scossl_dh_method, e_scossl_dh_compute_key)
+        || !DH_meth_set_finish(e_scossl_dh_method, e_scossl_dh_finish)
         )
     {
         goto end;
     }
 
     // Engine initialization
-    if(    !ENGINE_set_id(e, engine_scossl_id)
-        || !ENGINE_set_name(e, engine_scossl_name)
-        || !ENGINE_set_destroy_function(e, scossl_destroy)
-        || !ENGINE_set_EC(e, scossl_eckey_method)
-        || !ENGINE_set_RSA(e, scossl_rsa_method)
-        //|| !ENGINE_set_DSA(e, scossl_dsa_method)
-        || !ENGINE_set_DH(e, scossl_dh_method)
-        || !ENGINE_set_RAND(e, scossl_rand_method())
-        || !ENGINE_set_digests(e, scossl_digests)
-        || !ENGINE_set_ciphers(e, scossl_ciphers)
-        || !ENGINE_set_pkey_meths(e, scossl_pkey_methods)
+    if(    !ENGINE_set_id(e, e_scossl_id)
+        || !ENGINE_set_name(e, e_scossl_name)
+        || !ENGINE_set_destroy_function(e, e_scossl_destroy)
+        || !ENGINE_set_EC(e, e_scossl_eckey_method)
+        || !ENGINE_set_RSA(e, e_scossl_rsa_method)
+        //|| !ENGINE_set_DSA(e, e_scossl_dsa_method)
+        || !ENGINE_set_DH(e, e_scossl_dh_method)
+        || !ENGINE_set_RAND(e, e_scossl_rand_method())
+        || !ENGINE_set_digests(e, e_scossl_digests)
+        || !ENGINE_set_ciphers(e, e_scossl_ciphers)
+        || !ENGINE_set_pkey_meths(e, e_scossl_pkey_methods)
         )
     {
         goto end;
@@ -194,14 +193,14 @@ static SCOSSL_STATUS scossl_bind_engine(ENGINE* e)
     scossl_setup_logging();
 
     // Initialize hidden static variables once at Engine load time
-    if(    !scossl_ecc_init_static()
-        || !scossl_dh_init_static()
-        || !scossl_digests_init_static()
-        || !scossl_ciphers_init_static()
-        || !scossl_pkey_methods_init_static()
+    if(    !e_scossl_ecc_init_static()
+        || !e_scossl_dh_init_static()
+        || !e_scossl_digests_init_static()
+        || !e_scossl_ciphers_init_static()
+        || !e_scossl_pkey_methods_init_static()
         )
     {
-        scossl_destroy(e);
+        e_scossl_destroy(e);
         goto end;
     }
 
@@ -213,7 +212,7 @@ end:
 # ifndef OPENSSL_NO_DYNAMIC_ENGINE
 static SCOSSL_STATUS scossl_bind_helper(ENGINE *e, const char *id)
 {
-    if( id && (strcmp(id, engine_scossl_id) != 0) )
+    if( id && (strcmp(id, e_scossl_id) != 0) )
     {
         return SCOSSL_FAILURE;
     }
diff --git a/SymCryptEngine/src/scossl_ciphers.c b/SymCryptEngine/src/scossl_ciphers.c
index 69340d8..b720488 100644
--- a/SymCryptEngine/src/scossl_ciphers.c
+++ b/SymCryptEngine/src/scossl_ciphers.c
@@ -138,24 +138,24 @@ static int scossl_cipher_nids[] = {
 #define AES_192_KEY_SIZE 24
 #define AES_256_KEY_SIZE 32
 
-SCOSSL_STATUS scossl_aes_cbc_init_key(
+SCOSSL_STATUS e_scossl_aes_cbc_init_key(
     _Inout_ EVP_CIPHER_CTX *ctx, _In_ const unsigned char *key, _In_ const unsigned char *iv, SCOSSL_ENCRYPTION_MODE enc);
-SCOSSL_STATUS scossl_aes_cbc_cipher(
+SCOSSL_STATUS e_scossl_aes_cbc_cipher(
     _Inout_ EVP_CIPHER_CTX *ctx, _Out_ unsigned char *out, _In_reads_bytes_(inl) const unsigned char *in, size_t inl);
-static SCOSSL_STATUS scossl_aes_cbc_ctrl(_In_ EVP_CIPHER_CTX *ctx, int type, int arg, _Inout_ void *ptr);
+static SCOSSL_STATUS e_scossl_aes_cbc_ctrl(_In_ EVP_CIPHER_CTX *ctx, int type, int arg, _Inout_ void *ptr);
 #define AES_CBC_FLAGS    (EVP_CIPH_FLAG_DEFAULT_ASN1|EVP_CIPH_CBC_MODE|EVP_CIPH_CUSTOM_COPY \
                          |EVP_CIPH_ALWAYS_CALL_INIT|EVP_CIPH_FLAG_FIPS)
 
 /* AES128 - CBC */
 static EVP_CIPHER *_hidden_aes_128_cbc = NULL;
-static const EVP_CIPHER *scossl_aes_128_cbc(void)
+static const EVP_CIPHER *e_scossl_aes_128_cbc(void)
 {
     if( (_hidden_aes_128_cbc = EVP_CIPHER_meth_new(NID_aes_128_cbc, SYMCRYPT_AES_BLOCK_SIZE , AES_128_KEY_SIZE)) == NULL
         || !EVP_CIPHER_meth_set_iv_length(_hidden_aes_128_cbc, SYMCRYPT_AES_BLOCK_SIZE)
         || !EVP_CIPHER_meth_set_flags(_hidden_aes_128_cbc, AES_CBC_FLAGS)
-        || !EVP_CIPHER_meth_set_init(_hidden_aes_128_cbc, scossl_aes_cbc_init_key)
-        || !EVP_CIPHER_meth_set_do_cipher(_hidden_aes_128_cbc, scossl_aes_cbc_cipher)
-        || !EVP_CIPHER_meth_set_ctrl(_hidden_aes_128_cbc, scossl_aes_cbc_ctrl)
+        || !EVP_CIPHER_meth_set_init(_hidden_aes_128_cbc, e_scossl_aes_cbc_init_key)
+        || !EVP_CIPHER_meth_set_do_cipher(_hidden_aes_128_cbc, e_scossl_aes_cbc_cipher)
+        || !EVP_CIPHER_meth_set_ctrl(_hidden_aes_128_cbc, e_scossl_aes_cbc_ctrl)
         || !EVP_CIPHER_meth_set_impl_ctx_size(_hidden_aes_128_cbc, sizeof(struct cipher_cbc_ctx)) )
     {
         EVP_CIPHER_meth_free(_hidden_aes_128_cbc);
@@ -166,14 +166,14 @@ static const EVP_CIPHER *scossl_aes_128_cbc(void)
 
 /* AES192 - CBC */
 static EVP_CIPHER *_hidden_aes_192_cbc = NULL;
-static const EVP_CIPHER *scossl_aes_192_cbc(void)
+static const EVP_CIPHER *e_scossl_aes_192_cbc(void)
 {
     if( (_hidden_aes_192_cbc = EVP_CIPHER_meth_new(NID_aes_192_cbc, SYMCRYPT_AES_BLOCK_SIZE , AES_192_KEY_SIZE)) == NULL
         || !EVP_CIPHER_meth_set_iv_length(_hidden_aes_192_cbc, SYMCRYPT_AES_BLOCK_SIZE)
         || !EVP_CIPHER_meth_set_flags(_hidden_aes_192_cbc, AES_CBC_FLAGS)
-        || !EVP_CIPHER_meth_set_init(_hidden_aes_192_cbc, scossl_aes_cbc_init_key)
-        || !EVP_CIPHER_meth_set_do_cipher(_hidden_aes_192_cbc, scossl_aes_cbc_cipher)
-        || !EVP_CIPHER_meth_set_ctrl(_hidden_aes_192_cbc, scossl_aes_cbc_ctrl)
+        || !EVP_CIPHER_meth_set_init(_hidden_aes_192_cbc, e_scossl_aes_cbc_init_key)
+        || !EVP_CIPHER_meth_set_do_cipher(_hidden_aes_192_cbc, e_scossl_aes_cbc_cipher)
+        || !EVP_CIPHER_meth_set_ctrl(_hidden_aes_192_cbc, e_scossl_aes_cbc_ctrl)
         || !EVP_CIPHER_meth_set_impl_ctx_size(_hidden_aes_192_cbc, sizeof(struct cipher_cbc_ctx)) )
     {
         EVP_CIPHER_meth_free(_hidden_aes_192_cbc);
@@ -184,14 +184,14 @@ static const EVP_CIPHER *scossl_aes_192_cbc(void)
 
 /* AES256 - CBC */
 static EVP_CIPHER *_hidden_aes_256_cbc = NULL;
-static const EVP_CIPHER *scossl_aes_256_cbc(void)
+static const EVP_CIPHER *e_scossl_aes_256_cbc(void)
 {
     if( (_hidden_aes_256_cbc = EVP_CIPHER_meth_new(NID_aes_256_cbc, SYMCRYPT_AES_BLOCK_SIZE , AES_256_KEY_SIZE)) == NULL
         || !EVP_CIPHER_meth_set_iv_length(_hidden_aes_256_cbc, SYMCRYPT_AES_BLOCK_SIZE)
         || !EVP_CIPHER_meth_set_flags(_hidden_aes_256_cbc, AES_CBC_FLAGS)
-        || !EVP_CIPHER_meth_set_init(_hidden_aes_256_cbc, scossl_aes_cbc_init_key)
-        || !EVP_CIPHER_meth_set_do_cipher(_hidden_aes_256_cbc, scossl_aes_cbc_cipher)
-        || !EVP_CIPHER_meth_set_ctrl(_hidden_aes_256_cbc, scossl_aes_cbc_ctrl)
+        || !EVP_CIPHER_meth_set_init(_hidden_aes_256_cbc, e_scossl_aes_cbc_init_key)
+        || !EVP_CIPHER_meth_set_do_cipher(_hidden_aes_256_cbc, e_scossl_aes_cbc_cipher)
+        || !EVP_CIPHER_meth_set_ctrl(_hidden_aes_256_cbc, e_scossl_aes_cbc_ctrl)
         || !EVP_CIPHER_meth_set_impl_ctx_size(_hidden_aes_256_cbc, sizeof(struct cipher_cbc_ctx)) )
     {
         EVP_CIPHER_meth_free(_hidden_aes_256_cbc);
@@ -200,23 +200,23 @@ static const EVP_CIPHER *scossl_aes_256_cbc(void)
     return _hidden_aes_256_cbc;
 }
 
-SCOSSL_STATUS scossl_aes_ecb_init_key(
+SCOSSL_STATUS e_scossl_aes_ecb_init_key(
     _Inout_ EVP_CIPHER_CTX *ctx, _In_ const unsigned char *key, _In_ const unsigned char *iv, SCOSSL_ENCRYPTION_MODE enc);
-SCOSSL_STATUS scossl_aes_ecb_cipher(
+SCOSSL_STATUS e_scossl_aes_ecb_cipher(
     _Inout_ EVP_CIPHER_CTX *ctx, _Out_ unsigned char *out, _In_reads_bytes_(inl) const unsigned char *in, size_t inl);
-static SCOSSL_STATUS scossl_aes_ecb_ctrl(_In_ EVP_CIPHER_CTX *ctx, int type, int arg, _Inout_ void *ptr);
+static SCOSSL_STATUS e_scossl_aes_ecb_ctrl(_In_ EVP_CIPHER_CTX *ctx, int type, int arg, _Inout_ void *ptr);
 #define AES_ECB_FLAGS    (EVP_CIPH_FLAG_DEFAULT_ASN1|EVP_CIPH_ECB_MODE|EVP_CIPH_CUSTOM_COPY \
                          |EVP_CIPH_FLAG_FIPS)
 
 /* AES128 - ecb */
 static EVP_CIPHER *_hidden_aes_128_ecb = NULL;
-static const EVP_CIPHER *scossl_aes_128_ecb(void)
+static const EVP_CIPHER *e_scossl_aes_128_ecb(void)
 {
     if( (_hidden_aes_128_ecb = EVP_CIPHER_meth_new(NID_aes_128_ecb, SYMCRYPT_AES_BLOCK_SIZE , AES_128_KEY_SIZE)) == NULL
         || !EVP_CIPHER_meth_set_flags(_hidden_aes_128_ecb, AES_ECB_FLAGS)
-        || !EVP_CIPHER_meth_set_init(_hidden_aes_128_ecb, scossl_aes_ecb_init_key)
-        || !EVP_CIPHER_meth_set_do_cipher(_hidden_aes_128_ecb, scossl_aes_ecb_cipher)
-        || !EVP_CIPHER_meth_set_ctrl(_hidden_aes_128_ecb, scossl_aes_ecb_ctrl)
+        || !EVP_CIPHER_meth_set_init(_hidden_aes_128_ecb, e_scossl_aes_ecb_init_key)
+        || !EVP_CIPHER_meth_set_do_cipher(_hidden_aes_128_ecb, e_scossl_aes_ecb_cipher)
+        || !EVP_CIPHER_meth_set_ctrl(_hidden_aes_128_ecb, e_scossl_aes_ecb_ctrl)
         || !EVP_CIPHER_meth_set_impl_ctx_size(_hidden_aes_128_ecb, sizeof(struct cipher_ecb_ctx)) )
     {
         EVP_CIPHER_meth_free(_hidden_aes_128_ecb);
@@ -227,13 +227,13 @@ static const EVP_CIPHER *scossl_aes_128_ecb(void)
 
 /* AES192 - ecb */
 static EVP_CIPHER *_hidden_aes_192_ecb = NULL;
-static const EVP_CIPHER *scossl_aes_192_ecb(void)
+static const EVP_CIPHER *e_scossl_aes_192_ecb(void)
 {
     if( (_hidden_aes_192_ecb = EVP_CIPHER_meth_new(NID_aes_192_ecb, SYMCRYPT_AES_BLOCK_SIZE , AES_192_KEY_SIZE)) == NULL
         || !EVP_CIPHER_meth_set_flags(_hidden_aes_192_ecb, AES_ECB_FLAGS)
-        || !EVP_CIPHER_meth_set_init(_hidden_aes_192_ecb, scossl_aes_ecb_init_key)
-        || !EVP_CIPHER_meth_set_do_cipher(_hidden_aes_192_ecb, scossl_aes_ecb_cipher)
-        || !EVP_CIPHER_meth_set_ctrl(_hidden_aes_192_ecb, scossl_aes_ecb_ctrl)
+        || !EVP_CIPHER_meth_set_init(_hidden_aes_192_ecb, e_scossl_aes_ecb_init_key)
+        || !EVP_CIPHER_meth_set_do_cipher(_hidden_aes_192_ecb, e_scossl_aes_ecb_cipher)
+        || !EVP_CIPHER_meth_set_ctrl(_hidden_aes_192_ecb, e_scossl_aes_ecb_ctrl)
         || !EVP_CIPHER_meth_set_impl_ctx_size(_hidden_aes_192_ecb, sizeof(struct cipher_ecb_ctx)) )
     {
         EVP_CIPHER_meth_free(_hidden_aes_192_ecb);
@@ -244,13 +244,13 @@ static const EVP_CIPHER *scossl_aes_192_ecb(void)
 
 /* AES256 - ecb */
 static EVP_CIPHER *_hidden_aes_256_ecb = NULL;
-static const EVP_CIPHER *scossl_aes_256_ecb(void)
+static const EVP_CIPHER *e_scossl_aes_256_ecb(void)
 {
     if( (_hidden_aes_256_ecb = EVP_CIPHER_meth_new(NID_aes_256_ecb, SYMCRYPT_AES_BLOCK_SIZE , AES_256_KEY_SIZE)) == NULL
         || !EVP_CIPHER_meth_set_flags(_hidden_aes_256_ecb, AES_ECB_FLAGS)
-        || !EVP_CIPHER_meth_set_init(_hidden_aes_256_ecb, scossl_aes_ecb_init_key)
-        || !EVP_CIPHER_meth_set_do_cipher(_hidden_aes_256_ecb, scossl_aes_ecb_cipher)
-        || !EVP_CIPHER_meth_set_ctrl(_hidden_aes_256_ecb, scossl_aes_ecb_ctrl)
+        || !EVP_CIPHER_meth_set_init(_hidden_aes_256_ecb, e_scossl_aes_ecb_init_key)
+        || !EVP_CIPHER_meth_set_do_cipher(_hidden_aes_256_ecb, e_scossl_aes_ecb_cipher)
+        || !EVP_CIPHER_meth_set_ctrl(_hidden_aes_256_ecb, e_scossl_aes_ecb_ctrl)
         || !EVP_CIPHER_meth_set_impl_ctx_size(_hidden_aes_256_ecb, sizeof(struct cipher_ecb_ctx)) )
     {
         EVP_CIPHER_meth_free(_hidden_aes_256_ecb);
@@ -261,24 +261,24 @@ static const EVP_CIPHER *scossl_aes_256_ecb(void)
 
 // Disabling XTS for now - remove with if region to avoid unused function warning
 #if 0
-SCOSSL_STATUS scossl_aes_xts_init_key(
+SCOSSL_STATUS e_scossl_aes_xts_init_key(
     _Inout_ EVP_CIPHER_CTX *ctx, _In_ const unsigned char *key, _In_ const unsigned char *iv, SCOSSL_ENCRYPTION_MODE enc);
-SCOSSL_STATUS scossl_aes_xts_cipher(
+SCOSSL_STATUS e_scossl_aes_xts_cipher(
     _Inout_ EVP_CIPHER_CTX *ctx, _Out_ unsigned char *out, _In_reads_bytes_(inl) const unsigned char *in, size_t inl);
-static SCOSSL_STATUS scossl_aes_xts_ctrl(_Inout_ EVP_CIPHER_CTX *ctx, int type, int arg, _Inout_ void *ptr);
+static SCOSSL_STATUS e_scossl_aes_xts_ctrl(_Inout_ EVP_CIPHER_CTX *ctx, int type, int arg, _Inout_ void *ptr);
 #define AES_XTS_FLAGS   (EVP_CIPH_FLAG_DEFAULT_ASN1|EVP_CIPH_XTS_MODE|EVP_CIPH_CUSTOM_COPY \
                         |EVP_CIPH_CUSTOM_IV|EVP_CIPH_FLAG_CUSTOM_CIPHER)
 
 /* AES128 - XTS */
 static EVP_CIPHER *_hidden_aes_128_xts = NULL;
-static const EVP_CIPHER *scossl_aes_128_xts(void)
+static const EVP_CIPHER *e_scossl_aes_128_xts(void)
 {
     if( (_hidden_aes_128_xts = EVP_CIPHER_meth_new(NID_aes_128_xts, SYMCRYPT_AES_BLOCK_SIZE , AES_128_KEY_SIZE * 2)) == NULL
         || !EVP_CIPHER_meth_set_iv_length(_hidden_aes_128_xts, SYMCRYPT_AES_BLOCK_SIZE)
         || !EVP_CIPHER_meth_set_flags(_hidden_aes_128_xts, AES_XTS_FLAGS)
-        || !EVP_CIPHER_meth_set_init(_hidden_aes_128_xts, scossl_aes_xts_init_key)
-        || !EVP_CIPHER_meth_set_do_cipher(_hidden_aes_128_xts, scossl_aes_xts_cipher)
-        || !EVP_CIPHER_meth_set_ctrl(_hidden_aes_128_xts, scossl_aes_xts_ctrl)
+        || !EVP_CIPHER_meth_set_init(_hidden_aes_128_xts, e_scossl_aes_xts_init_key)
+        || !EVP_CIPHER_meth_set_do_cipher(_hidden_aes_128_xts, e_scossl_aes_xts_cipher)
+        || !EVP_CIPHER_meth_set_ctrl(_hidden_aes_128_xts, e_scossl_aes_xts_ctrl)
         || !EVP_CIPHER_meth_set_impl_ctx_size(_hidden_aes_128_xts, sizeof(struct cipher_xts_ctx)) )
     {
         EVP_CIPHER_meth_free(_hidden_aes_128_xts);
@@ -289,14 +289,14 @@ static const EVP_CIPHER *scossl_aes_128_xts(void)
 
 /* AES256 - XTS */
 static EVP_CIPHER *_hidden_aes_256_xts = NULL;
-static const EVP_CIPHER *scossl_aes_256_xts(void)
+static const EVP_CIPHER *e_scossl_aes_256_xts(void)
 {
     if( (_hidden_aes_256_xts = EVP_CIPHER_meth_new(NID_aes_256_xts, SYMCRYPT_AES_BLOCK_SIZE , AES_256_KEY_SIZE * 2)) == NULL
         || !EVP_CIPHER_meth_set_iv_length(_hidden_aes_256_xts, SYMCRYPT_AES_BLOCK_SIZE)
         || !EVP_CIPHER_meth_set_flags(_hidden_aes_256_xts, AES_XTS_FLAGS)
-        || !EVP_CIPHER_meth_set_init(_hidden_aes_256_xts, scossl_aes_xts_init_key)
-        || !EVP_CIPHER_meth_set_do_cipher(_hidden_aes_256_xts, scossl_aes_xts_cipher)
-        || !EVP_CIPHER_meth_set_ctrl(_hidden_aes_256_xts, scossl_aes_xts_ctrl)
+        || !EVP_CIPHER_meth_set_init(_hidden_aes_256_xts, e_scossl_aes_xts_init_key)
+        || !EVP_CIPHER_meth_set_do_cipher(_hidden_aes_256_xts, e_scossl_aes_xts_cipher)
+        || !EVP_CIPHER_meth_set_ctrl(_hidden_aes_256_xts, e_scossl_aes_xts_ctrl)
         || !EVP_CIPHER_meth_set_impl_ctx_size(_hidden_aes_256_xts, sizeof(struct cipher_xts_ctx)) )
     {
         EVP_CIPHER_meth_free(_hidden_aes_256_xts);
@@ -307,11 +307,11 @@ static const EVP_CIPHER *scossl_aes_256_xts(void)
 #endif
 
 
-SCOSSL_STATUS scossl_aes_gcm_init_key(
+SCOSSL_STATUS e_scossl_aes_gcm_init_key(
     _Inout_ EVP_CIPHER_CTX *ctx, _In_ const unsigned char *key, _In_ const unsigned char *iv, SCOSSL_ENCRYPTION_MODE enc);
-SCOSSL_RETURNLENGTH scossl_aes_gcm_cipher(
+SCOSSL_RETURNLENGTH e_scossl_aes_gcm_cipher(
     _Inout_ EVP_CIPHER_CTX *ctx, _Out_ unsigned char *out, _In_reads_bytes_(inl) const unsigned char *in, size_t inl);
-static _Success_(return > 0) int scossl_aes_gcm_ctrl(_Inout_ EVP_CIPHER_CTX *ctx, int type, int arg, _Inout_ void *ptr);
+static _Success_(return > 0) int e_scossl_aes_gcm_ctrl(_Inout_ EVP_CIPHER_CTX *ctx, int type, int arg, _Inout_ void *ptr);
 #define AES_GCM_FLAGS   (EVP_CIPH_FLAG_DEFAULT_ASN1|EVP_CIPH_GCM_MODE|EVP_CIPH_CUSTOM_COPY \
                         |EVP_CIPH_CUSTOM_IV|EVP_CIPH_CUSTOM_IV_LENGTH|EVP_CIPH_FLAG_CUSTOM_CIPHER \
                         |EVP_CIPH_ALWAYS_CALL_INIT|EVP_CIPH_CTRL_INIT|EVP_CIPH_FLAG_AEAD_CIPHER \
@@ -319,13 +319,13 @@ static _Success_(return > 0) int scossl_aes_gcm_ctrl(_Inout_ EVP_CIPHER_CTX *ctx
 
 /* AES128 - GCM */
 static EVP_CIPHER *_hidden_aes_128_gcm = NULL;
-static const EVP_CIPHER *scossl_aes_128_gcm(void)
+static const EVP_CIPHER *e_scossl_aes_128_gcm(void)
 {
     if( (_hidden_aes_128_gcm = EVP_CIPHER_meth_new(NID_aes_128_gcm, 1, AES_128_KEY_SIZE)) == NULL
         || !EVP_CIPHER_meth_set_flags(_hidden_aes_128_gcm, AES_GCM_FLAGS)
-        || !EVP_CIPHER_meth_set_init(_hidden_aes_128_gcm, scossl_aes_gcm_init_key)
-        || !EVP_CIPHER_meth_set_do_cipher(_hidden_aes_128_gcm, scossl_aes_gcm_cipher)
-        || !EVP_CIPHER_meth_set_ctrl(_hidden_aes_128_gcm, scossl_aes_gcm_ctrl)
+        || !EVP_CIPHER_meth_set_init(_hidden_aes_128_gcm, e_scossl_aes_gcm_init_key)
+        || !EVP_CIPHER_meth_set_do_cipher(_hidden_aes_128_gcm, e_scossl_aes_gcm_cipher)
+        || !EVP_CIPHER_meth_set_ctrl(_hidden_aes_128_gcm, e_scossl_aes_gcm_ctrl)
         || !EVP_CIPHER_meth_set_impl_ctx_size(_hidden_aes_128_gcm, sizeof(struct cipher_gcm_ctx)) )
     {
         EVP_CIPHER_meth_free(_hidden_aes_128_gcm);
@@ -336,13 +336,13 @@ static const EVP_CIPHER *scossl_aes_128_gcm(void)
 
 /* AES192 - GCM */
 static EVP_CIPHER *_hidden_aes_192_gcm = NULL;
-static const EVP_CIPHER *scossl_aes_192_gcm(void)
+static const EVP_CIPHER *e_scossl_aes_192_gcm(void)
 {
     if( (_hidden_aes_192_gcm = EVP_CIPHER_meth_new(NID_aes_192_gcm, 1, AES_192_KEY_SIZE)) == NULL
         || !EVP_CIPHER_meth_set_flags(_hidden_aes_192_gcm, AES_GCM_FLAGS)
-        || !EVP_CIPHER_meth_set_init(_hidden_aes_192_gcm, scossl_aes_gcm_init_key)
-        || !EVP_CIPHER_meth_set_do_cipher(_hidden_aes_192_gcm, scossl_aes_gcm_cipher)
-        || !EVP_CIPHER_meth_set_ctrl(_hidden_aes_192_gcm, scossl_aes_gcm_ctrl)
+        || !EVP_CIPHER_meth_set_init(_hidden_aes_192_gcm, e_scossl_aes_gcm_init_key)
+        || !EVP_CIPHER_meth_set_do_cipher(_hidden_aes_192_gcm, e_scossl_aes_gcm_cipher)
+        || !EVP_CIPHER_meth_set_ctrl(_hidden_aes_192_gcm, e_scossl_aes_gcm_ctrl)
         || !EVP_CIPHER_meth_set_impl_ctx_size(_hidden_aes_192_gcm, sizeof(struct cipher_gcm_ctx)) )
     {
         EVP_CIPHER_meth_free(_hidden_aes_192_gcm);
@@ -353,13 +353,13 @@ static const EVP_CIPHER *scossl_aes_192_gcm(void)
 
 /* AES256 - GCM */
 static EVP_CIPHER *_hidden_aes_256_gcm = NULL;
-static const EVP_CIPHER *scossl_aes_256_gcm(void)
+static const EVP_CIPHER *e_scossl_aes_256_gcm(void)
 {
     if( (_hidden_aes_256_gcm = EVP_CIPHER_meth_new(NID_aes_256_gcm, 1, AES_256_KEY_SIZE)) == NULL
         || !EVP_CIPHER_meth_set_flags(_hidden_aes_256_gcm, AES_GCM_FLAGS)
-        || !EVP_CIPHER_meth_set_init(_hidden_aes_256_gcm, scossl_aes_gcm_init_key)
-        || !EVP_CIPHER_meth_set_do_cipher(_hidden_aes_256_gcm, scossl_aes_gcm_cipher)
-        || !EVP_CIPHER_meth_set_ctrl(_hidden_aes_256_gcm, scossl_aes_gcm_ctrl)
+        || !EVP_CIPHER_meth_set_init(_hidden_aes_256_gcm, e_scossl_aes_gcm_init_key)
+        || !EVP_CIPHER_meth_set_do_cipher(_hidden_aes_256_gcm, e_scossl_aes_gcm_cipher)
+        || !EVP_CIPHER_meth_set_ctrl(_hidden_aes_256_gcm, e_scossl_aes_gcm_ctrl)
         || !EVP_CIPHER_meth_set_impl_ctx_size(_hidden_aes_256_gcm, sizeof(struct cipher_gcm_ctx)) )
     {
         EVP_CIPHER_meth_free(_hidden_aes_256_gcm);
@@ -368,11 +368,11 @@ static const EVP_CIPHER *scossl_aes_256_gcm(void)
     return _hidden_aes_256_gcm;
 }
 
-SCOSSL_STATUS scossl_aes_ccm_init_key(
+SCOSSL_STATUS e_scossl_aes_ccm_init_key(
     _Inout_ EVP_CIPHER_CTX *ctx, _In_ const unsigned char *key, _In_ const unsigned char *iv, SCOSSL_ENCRYPTION_MODE enc);
-SCOSSL_RETURNLENGTH scossl_aes_ccm_cipher(
+SCOSSL_RETURNLENGTH e_scossl_aes_ccm_cipher(
     _Inout_ EVP_CIPHER_CTX *ctx, _Out_ unsigned char *out, _In_reads_bytes_(inl) const unsigned char *in, size_t inl);
-static _Success_(return > 0) int scossl_aes_ccm_ctrl(_Inout_ EVP_CIPHER_CTX *ctx, int type, int arg, _Inout_ void *ptr);
+static _Success_(return > 0) int e_scossl_aes_ccm_ctrl(_Inout_ EVP_CIPHER_CTX *ctx, int type, int arg, _Inout_ void *ptr);
 #define AES_CCM_FLAGS   (EVP_CIPH_FLAG_DEFAULT_ASN1|EVP_CIPH_CCM_MODE|EVP_CIPH_CUSTOM_COPY \
                         |EVP_CIPH_CUSTOM_IV|EVP_CIPH_CUSTOM_IV_LENGTH|EVP_CIPH_FLAG_CUSTOM_CIPHER \
                         |EVP_CIPH_ALWAYS_CALL_INIT|EVP_CIPH_CTRL_INIT|EVP_CIPH_FLAG_AEAD_CIPHER \
@@ -380,13 +380,13 @@ static _Success_(return > 0) int scossl_aes_ccm_ctrl(_Inout_ EVP_CIPHER_CTX *ctx
 
 /* AES128 - CCM */
 static EVP_CIPHER *_hidden_aes_128_ccm = NULL;
-static const EVP_CIPHER *scossl_aes_128_ccm(void)
+static const EVP_CIPHER *e_scossl_aes_128_ccm(void)
 {
     if( (_hidden_aes_128_ccm = EVP_CIPHER_meth_new(NID_aes_128_ccm, 1, AES_128_KEY_SIZE)) == NULL
         || !EVP_CIPHER_meth_set_flags(_hidden_aes_128_ccm, AES_CCM_FLAGS)
-        || !EVP_CIPHER_meth_set_init(_hidden_aes_128_ccm, scossl_aes_ccm_init_key)
-        || !EVP_CIPHER_meth_set_do_cipher(_hidden_aes_128_ccm, scossl_aes_ccm_cipher)
-        || !EVP_CIPHER_meth_set_ctrl(_hidden_aes_128_ccm, scossl_aes_ccm_ctrl)
+        || !EVP_CIPHER_meth_set_init(_hidden_aes_128_ccm, e_scossl_aes_ccm_init_key)
+        || !EVP_CIPHER_meth_set_do_cipher(_hidden_aes_128_ccm, e_scossl_aes_ccm_cipher)
+        || !EVP_CIPHER_meth_set_ctrl(_hidden_aes_128_ccm, e_scossl_aes_ccm_ctrl)
         || !EVP_CIPHER_meth_set_impl_ctx_size(_hidden_aes_128_ccm, sizeof(struct cipher_ccm_ctx)) )
     {
         EVP_CIPHER_meth_free(_hidden_aes_128_ccm);
@@ -397,13 +397,13 @@ static const EVP_CIPHER *scossl_aes_128_ccm(void)
 
 /* AES192 - CCM */
 static EVP_CIPHER *_hidden_aes_192_ccm = NULL;
-static const EVP_CIPHER *scossl_aes_192_ccm(void)
+static const EVP_CIPHER *e_scossl_aes_192_ccm(void)
 {
     if( (_hidden_aes_192_ccm = EVP_CIPHER_meth_new(NID_aes_192_ccm, 1, AES_192_KEY_SIZE)) == NULL
         || !EVP_CIPHER_meth_set_flags(_hidden_aes_192_ccm, AES_CCM_FLAGS)
-        || !EVP_CIPHER_meth_set_init(_hidden_aes_192_ccm, scossl_aes_ccm_init_key)
-        || !EVP_CIPHER_meth_set_do_cipher(_hidden_aes_192_ccm, scossl_aes_ccm_cipher)
-        || !EVP_CIPHER_meth_set_ctrl(_hidden_aes_192_ccm, scossl_aes_ccm_ctrl)
+        || !EVP_CIPHER_meth_set_init(_hidden_aes_192_ccm, e_scossl_aes_ccm_init_key)
+        || !EVP_CIPHER_meth_set_do_cipher(_hidden_aes_192_ccm, e_scossl_aes_ccm_cipher)
+        || !EVP_CIPHER_meth_set_ctrl(_hidden_aes_192_ccm, e_scossl_aes_ccm_ctrl)
         || !EVP_CIPHER_meth_set_impl_ctx_size(_hidden_aes_192_ccm, sizeof(struct cipher_ccm_ctx)) )
     {
         EVP_CIPHER_meth_free(_hidden_aes_192_ccm);
@@ -414,13 +414,13 @@ static const EVP_CIPHER *scossl_aes_192_ccm(void)
 
 /* AES256 - CCM */
 static EVP_CIPHER *_hidden_aes_256_ccm = NULL;
-static const EVP_CIPHER *scossl_aes_256_ccm(void)
+static const EVP_CIPHER *e_scossl_aes_256_ccm(void)
 {
     if( (_hidden_aes_256_ccm = EVP_CIPHER_meth_new(NID_aes_256_ccm, 1, AES_256_KEY_SIZE)) == NULL
         || !EVP_CIPHER_meth_set_flags(_hidden_aes_256_ccm, AES_CCM_FLAGS)
-        || !EVP_CIPHER_meth_set_init(_hidden_aes_256_ccm, scossl_aes_ccm_init_key)
-        || !EVP_CIPHER_meth_set_do_cipher(_hidden_aes_256_ccm, scossl_aes_ccm_cipher)
-        || !EVP_CIPHER_meth_set_ctrl(_hidden_aes_256_ccm, scossl_aes_ccm_ctrl)
+        || !EVP_CIPHER_meth_set_init(_hidden_aes_256_ccm, e_scossl_aes_ccm_init_key)
+        || !EVP_CIPHER_meth_set_do_cipher(_hidden_aes_256_ccm, e_scossl_aes_ccm_cipher)
+        || !EVP_CIPHER_meth_set_ctrl(_hidden_aes_256_ccm, e_scossl_aes_ccm_ctrl)
         || !EVP_CIPHER_meth_set_impl_ctx_size(_hidden_aes_256_ccm, sizeof(struct cipher_ccm_ctx)) )
     {
         EVP_CIPHER_meth_free(_hidden_aes_256_ccm);
@@ -430,7 +430,7 @@ static const EVP_CIPHER *scossl_aes_256_ccm(void)
 }
 
 
-void scossl_destroy_ciphers(void)
+void e_scossl_destroy_ciphers(void)
 {
     EVP_CIPHER_meth_free(_hidden_aes_128_cbc);
     EVP_CIPHER_meth_free(_hidden_aes_192_cbc);
@@ -462,29 +462,29 @@ void scossl_destroy_ciphers(void)
     _hidden_aes_256_ccm = NULL;
 }
 
-SCOSSL_STATUS scossl_ciphers_init_static()
+SCOSSL_STATUS e_scossl_ciphers_init_static()
 {
-    if( (scossl_aes_128_cbc() == NULL) ||
-        (scossl_aes_192_cbc() == NULL) ||
-        (scossl_aes_256_cbc() == NULL) ||
-        (scossl_aes_128_ecb() == NULL) ||
-        (scossl_aes_192_ecb() == NULL) ||
-        (scossl_aes_256_ecb() == NULL) ||
-        // (scossl_aes_128_xts() == NULL) ||
-        // (scossl_aes_256_xts() == NULL) ||
-        (scossl_aes_128_gcm() == NULL) ||
-        (scossl_aes_192_gcm() == NULL) ||
-        (scossl_aes_256_gcm() == NULL) ||
-        (scossl_aes_128_ccm() == NULL) ||
-        (scossl_aes_192_ccm() == NULL) ||
-        (scossl_aes_256_ccm() == NULL) )
+    if( (e_scossl_aes_128_cbc() == NULL) ||
+        (e_scossl_aes_192_cbc() == NULL) ||
+        (e_scossl_aes_256_cbc() == NULL) ||
+        (e_scossl_aes_128_ecb() == NULL) ||
+        (e_scossl_aes_192_ecb() == NULL) ||
+        (e_scossl_aes_256_ecb() == NULL) ||
+        // (e_scossl_aes_128_xts() == NULL) ||
+        // (e_scossl_aes_256_xts() == NULL) ||
+        (e_scossl_aes_128_gcm() == NULL) ||
+        (e_scossl_aes_192_gcm() == NULL) ||
+        (e_scossl_aes_256_gcm() == NULL) ||
+        (e_scossl_aes_128_ccm() == NULL) ||
+        (e_scossl_aes_192_ccm() == NULL) ||
+        (e_scossl_aes_256_ccm() == NULL) )
     {
         return SCOSSL_FAILURE;
     }
     return SCOSSL_SUCCESS;
 }
 
-int scossl_ciphers(ENGINE *e, const EVP_CIPHER **cipher,
+int e_scossl_ciphers(ENGINE *e, const EVP_CIPHER **cipher,
                      const int **nids, int nid)
 {
     int ok = 1;
@@ -555,7 +555,7 @@ int scossl_ciphers(ENGINE *e, const EVP_CIPHER **cipher,
 
 // Initializes ctx with the provided key and iv, along with enc/dec mode.
 // Returns SCOSSL_SUCCESS on success, or SCOSSL_FAILURE on error.
-SCOSSL_STATUS scossl_aes_cbc_init_key(_Inout_ EVP_CIPHER_CTX *ctx, _In_ const unsigned char *key,
+SCOSSL_STATUS e_scossl_aes_cbc_init_key(_Inout_ EVP_CIPHER_CTX *ctx, _In_ const unsigned char *key,
                              _In_ const unsigned char *iv, SCOSSL_ENCRYPTION_MODE enc)
 {
     struct cipher_cbc_ctx *cipherCtx = (struct cipher_cbc_ctx *)EVP_CIPHER_CTX_get_cipher_data(ctx);
@@ -573,7 +573,7 @@ SCOSSL_STATUS scossl_aes_cbc_init_key(_Inout_ EVP_CIPHER_CTX *ctx, _In_ const un
 
 // Encrypts or decrypts in, storing result in out, depending on mode set in ctx.
 // Returns SCOSSL_SUCCESS on success, or SCOSSL_FAILURE on error.
-SCOSSL_STATUS scossl_aes_cbc_cipher(_Inout_ EVP_CIPHER_CTX *ctx, _Out_ unsigned char *out,
+SCOSSL_STATUS e_scossl_aes_cbc_cipher(_Inout_ EVP_CIPHER_CTX *ctx, _Out_ unsigned char *out,
                                _In_reads_bytes_(inl) const unsigned char *in, size_t inl)
 {
     struct cipher_cbc_ctx *cipherCtx = (struct cipher_cbc_ctx *)EVP_CIPHER_CTX_get_cipher_data(ctx);
@@ -592,7 +592,7 @@ SCOSSL_STATUS scossl_aes_cbc_cipher(_Inout_ EVP_CIPHER_CTX *ctx, _Out_ unsigned
 
 // Allows various cipher specific parameters to be determined and set.
 // Returns SCOSSL_SUCCESS on success, or SCOSSL_FAILURE on error.
-static SCOSSL_STATUS scossl_aes_cbc_ctrl(_In_ EVP_CIPHER_CTX *ctx, int type, int arg,
+static SCOSSL_STATUS e_scossl_aes_cbc_ctrl(_In_ EVP_CIPHER_CTX *ctx, int type, int arg,
                                     _Inout_ void *ptr)
 {
     struct cipher_cbc_ctx *srcCtx;
@@ -620,7 +620,7 @@ static SCOSSL_STATUS scossl_aes_cbc_ctrl(_In_ EVP_CIPHER_CTX *ctx, int type, int
 
 // Initializes ctx with the provided key and iv, along with enc/dec mode.
 // Returns SCOSSL_SUCCESS on success, or SCOSSL_FAILURE on error.
-SCOSSL_STATUS scossl_aes_ecb_init_key(_Inout_ EVP_CIPHER_CTX *ctx, _In_ const unsigned char *key,
+SCOSSL_STATUS e_scossl_aes_ecb_init_key(_Inout_ EVP_CIPHER_CTX *ctx, _In_ const unsigned char *key,
                              _In_ const unsigned char *iv, SCOSSL_ENCRYPTION_MODE enc)
 {
     struct cipher_ecb_ctx *cipherCtx = (struct cipher_ecb_ctx *)EVP_CIPHER_CTX_get_cipher_data(ctx);
@@ -638,7 +638,7 @@ SCOSSL_STATUS scossl_aes_ecb_init_key(_Inout_ EVP_CIPHER_CTX *ctx, _In_ const un
 
 // Encrypts or decrypts in, storing result in out, depending on mode set in ctx.
 // Returns SCOSSL_SUCCESS on success, or SCOSSL_FAILURE on error.
-SCOSSL_STATUS scossl_aes_ecb_cipher(_Inout_ EVP_CIPHER_CTX *ctx, _Out_ unsigned char *out,
+SCOSSL_STATUS e_scossl_aes_ecb_cipher(_Inout_ EVP_CIPHER_CTX *ctx, _Out_ unsigned char *out,
                                _In_reads_bytes_(inl) const unsigned char *in, size_t inl)
 {
     struct cipher_ecb_ctx *cipherCtx = (struct cipher_ecb_ctx *)EVP_CIPHER_CTX_get_cipher_data(ctx);
@@ -656,7 +656,7 @@ SCOSSL_STATUS scossl_aes_ecb_cipher(_Inout_ EVP_CIPHER_CTX *ctx, _Out_ unsigned
 
 // Allows various cipher specific parameters to be determined and set.
 // Returns SCOSSL_SUCCESS on success, or SCOSSL_FAILURE on error.
-static SCOSSL_STATUS scossl_aes_ecb_ctrl(_In_ EVP_CIPHER_CTX *ctx, int type, int arg,
+static SCOSSL_STATUS e_scossl_aes_ecb_ctrl(_In_ EVP_CIPHER_CTX *ctx, int type, int arg,
                                     _Inout_ void *ptr)
 {
     struct cipher_ecb_ctx *srcCtx;
@@ -686,7 +686,7 @@ static SCOSSL_STATUS scossl_aes_ecb_ctrl(_In_ EVP_CIPHER_CTX *ctx, int type, int
 
 // Initializes ctx with the provided key and iv, along with enc/dec mode.
 // Returns SCOSSL_SUCCESS on success, or SCOSSL_FAILURE on error.
-SCOSSL_STATUS scossl_aes_xts_init_key(_Inout_ EVP_CIPHER_CTX *ctx, _In_ const unsigned char *key,
+SCOSSL_STATUS e_scossl_aes_xts_init_key(_Inout_ EVP_CIPHER_CTX *ctx, _In_ const unsigned char *key,
                              _In_ const unsigned char *iv, SCOSSL_ENCRYPTION_MODE enc)
 {
     SYMCRYPT_ERROR scError = SYMCRYPT_NO_ERROR;
@@ -713,7 +713,7 @@ SCOSSL_STATUS scossl_aes_xts_init_key(_Inout_ EVP_CIPHER_CTX *ctx, _In_ const un
 
 // This is a EVP_CIPH_FLAG_CUSTOM_CIPHER do cipher method
 // return negative value on failure, and number of bytes written to out on success (may be 0)
-SCOSSL_RETURNLENGTH scossl_aes_xts_cipher(_Inout_ EVP_CIPHER_CTX *ctx, _Out_ unsigned char *out,
+SCOSSL_RETURNLENGTH e_scossl_aes_xts_cipher(_Inout_ EVP_CIPHER_CTX *ctx, _Out_ unsigned char *out,
                                _In_reads_bytes_(inl) const unsigned char *in, size_t inl)
 {
     int ret = 0;
@@ -760,7 +760,7 @@ SCOSSL_RETURNLENGTH scossl_aes_xts_cipher(_Inout_ EVP_CIPHER_CTX *ctx, _Out_ uns
 
 // Allows various cipher specific parameters to be determined and set.
 // Returns SCOSSL_SUCCESS on success, or SCOSSL_FAILURE on error.
-static SCOSSL_STATUS scossl_aes_xts_ctrl(_In_ EVP_CIPHER_CTX *ctx, int type, int arg,
+static SCOSSL_STATUS e_scossl_aes_xts_ctrl(_In_ EVP_CIPHER_CTX *ctx, int type, int arg,
                                     _Inout_ void *ptr)
 {
     switch( type )
@@ -791,7 +791,7 @@ static SCOSSL_STATUS scossl_aes_xts_ctrl(_In_ EVP_CIPHER_CTX *ctx, int type, int
 
 // Initializes ctx with the provided key and iv, along with enc/dec mode.
 // Returns SCOSSL_SUCCESS on success, or SCOSSL_FAILURE on error.
-SCOSSL_STATUS scossl_aes_gcm_init_key(_Inout_ EVP_CIPHER_CTX *ctx, _In_ const unsigned char *key,
+SCOSSL_STATUS e_scossl_aes_gcm_init_key(_Inout_ EVP_CIPHER_CTX *ctx, _In_ const unsigned char *key,
                              _In_ const unsigned char *iv, SCOSSL_ENCRYPTION_MODE enc)
 {
     SYMCRYPT_ERROR scError = SYMCRYPT_NO_ERROR;
@@ -817,7 +817,7 @@ SCOSSL_STATUS scossl_aes_gcm_init_key(_Inout_ EVP_CIPHER_CTX *ctx, _In_ const un
 
 // Encrypts or decrypts in, storing result in out, depending on mode set in ctx.
 // Returns length of out on success, or -1 on error.
-static SCOSSL_RETURNLENGTH scossl_aes_gcm_tls(_In_ EVP_CIPHER_CTX *ctx, _Inout_ struct cipher_gcm_ctx *cipherCtx, _Out_ unsigned char *out,
+static SCOSSL_RETURNLENGTH e_scossl_aes_gcm_tls(_In_ EVP_CIPHER_CTX *ctx, _Inout_ struct cipher_gcm_ctx *cipherCtx, _Out_ unsigned char *out,
                                _In_reads_bytes_(inl) const unsigned char *in, size_t inl, BOOL enc)
 {
     int ret = -1;
@@ -862,7 +862,7 @@ static SCOSSL_RETURNLENGTH scossl_aes_gcm_tls(_In_ EVP_CIPHER_CTX *ctx, _Inout_
     {
         // First 8B of ESP payload data are the variable part of the IV (last 8B)
         // Generate it using the IV invocation field to ensure distinct IVs are used
-        if( scossl_aes_gcm_ctrl(ctx, EVP_CTRL_GCM_IV_GEN, EVP_GCM_TLS_EXPLICIT_IV_LEN, out) != SCOSSL_SUCCESS )
+        if( e_scossl_aes_gcm_ctrl(ctx, EVP_CTRL_GCM_IV_GEN, EVP_GCM_TLS_EXPLICIT_IV_LEN, out) != SCOSSL_SUCCESS )
         {
             SCOSSL_LOG_ERROR(SCOSSL_ERR_F_AES_GCM_TLS, ERR_R_INTERNAL_ERROR,
                 "AES-GCM TLS failed to generate IV");
@@ -911,7 +911,7 @@ cleanup:
 
 // This is a EVP_CIPH_FLAG_CUSTOM_CIPHER do cipher method
 // return negative value on failure, and number of bytes written to out on success (may be 0)
-SCOSSL_RETURNLENGTH scossl_aes_gcm_cipher(_Inout_ EVP_CIPHER_CTX *ctx, _Out_ unsigned char *out,
+SCOSSL_RETURNLENGTH e_scossl_aes_gcm_cipher(_Inout_ EVP_CIPHER_CTX *ctx, _Out_ unsigned char *out,
                                _In_reads_bytes_(inl) const unsigned char *in, size_t inl)
 {
     int ret = -1;
@@ -920,7 +920,7 @@ SCOSSL_RETURNLENGTH scossl_aes_gcm_cipher(_Inout_ EVP_CIPHER_CTX *ctx, _Out_ uns
 
     if( cipherCtx->tlsAadSet )
     {
-        return scossl_aes_gcm_tls(ctx, cipherCtx, out, in, inl, EVP_CIPHER_CTX_encrypting(ctx));
+        return e_scossl_aes_gcm_tls(ctx, cipherCtx, out, in, inl, EVP_CIPHER_CTX_encrypting(ctx));
     }
 
     if( !cipherCtx->operationInProgress )
@@ -979,7 +979,7 @@ cleanup:
 // Allows various cipher specific parameters to be determined and set.
 // Returns SCOSSL_SUCCESS on success, SCOSSL_FAILURE on error, or taglen on successful query of
 // EVP_CTRL_AEAD_TLS1_AAD.
-static int scossl_aes_gcm_ctrl(_Inout_ EVP_CIPHER_CTX *ctx, int type, int arg,
+static int e_scossl_aes_gcm_ctrl(_Inout_ EVP_CIPHER_CTX *ctx, int type, int arg,
                                     _Inout_ void *ptr)
 {
     struct cipher_gcm_ctx *cipherCtx = (struct cipher_gcm_ctx *)EVP_CIPHER_CTX_get_cipher_data(ctx);
@@ -1150,7 +1150,7 @@ static int scossl_aes_gcm_ctrl(_Inout_ EVP_CIPHER_CTX *ctx, int type, int arg,
 
 // Initializes ctx with the provided key and iv, along with enc/dec mode.
 // Returns SCOSSL_SUCCESS on success, or SCOSSL_FAILURE on error.
-SCOSSL_STATUS scossl_aes_ccm_init_key(_Inout_ EVP_CIPHER_CTX *ctx, _In_ const unsigned char *key,
+SCOSSL_STATUS e_scossl_aes_ccm_init_key(_Inout_ EVP_CIPHER_CTX *ctx, _In_ const unsigned char *key,
                              _In_ const unsigned char *iv, SCOSSL_ENCRYPTION_MODE enc)
 {
     SYMCRYPT_ERROR scError = SYMCRYPT_NO_ERROR;
@@ -1175,7 +1175,7 @@ SCOSSL_STATUS scossl_aes_ccm_init_key(_Inout_ EVP_CIPHER_CTX *ctx, _In_ const un
 
 // Encrypts or decrypts in, storing result in out, depending on mode set in ctx.
 // Returns length of out on success, or -1 on error.
-static SCOSSL_RETURNLENGTH scossl_aes_ccm_tls(_In_ const EVP_CIPHER_CTX *ctx, _Inout_ struct cipher_ccm_ctx *cipherCtx, _Out_ unsigned char *out,
+static SCOSSL_RETURNLENGTH e_scossl_aes_ccm_tls(_In_ const EVP_CIPHER_CTX *ctx, _Inout_ struct cipher_ccm_ctx *cipherCtx, _Out_ unsigned char *out,
                                _In_reads_bytes_(inl) const unsigned char *in, size_t inl)
 {
     int ret = -1;
@@ -1272,7 +1272,7 @@ cleanup:
 
 // This is a EVP_CIPH_FLAG_CUSTOM_CIPHER do cipher method
 // return negative value on failure, and number of bytes written to out on success (may be 0)
-SCOSSL_RETURNLENGTH scossl_aes_ccm_cipher(_Inout_ EVP_CIPHER_CTX *ctx, _Out_ unsigned char *out,
+SCOSSL_RETURNLENGTH e_scossl_aes_ccm_cipher(_Inout_ EVP_CIPHER_CTX *ctx, _Out_ unsigned char *out,
                                _In_reads_bytes_(inl) const unsigned char *in, size_t inl)
 {
     int ret = -1;
@@ -1283,7 +1283,7 @@ SCOSSL_RETURNLENGTH scossl_aes_ccm_cipher(_Inout_ EVP_CIPHER_CTX *ctx, _Out_ uns
 
     if( cipherCtx->tlsAadSet )
     {
-        return scossl_aes_ccm_tls(ctx, cipherCtx, out, in, inl);
+        return e_scossl_aes_ccm_tls(ctx, cipherCtx, out, in, inl);
     }
 
     // See SCOSSL_CCM_STAGE definition above - callers to CCM must use the API in a very particular way
@@ -1398,7 +1398,7 @@ cleanup:
 // Allows various cipher specific parameters to be determined and set.
 // Returns SCOSSL_SUCCESS on success, SCOSSL_FAILURE on error, or taglen on successful query of
 // EVP_CTRL_AEAD_TLS1_AAD.
-static int scossl_aes_ccm_ctrl(_Inout_ EVP_CIPHER_CTX *ctx, int type, int arg,
+static int e_scossl_aes_ccm_ctrl(_Inout_ EVP_CIPHER_CTX *ctx, int type, int arg,
                                     _Inout_ void *ptr)
 {
     struct cipher_ccm_ctx *cipherCtx = (struct cipher_ccm_ctx *)EVP_CIPHER_CTX_get_cipher_data(ctx);
diff --git a/SymCryptEngine/src/scossl_ciphers.h b/SymCryptEngine/src/scossl_ciphers.h
index 53da04a..90c8072 100644
--- a/SymCryptEngine/src/scossl_ciphers.h
+++ b/SymCryptEngine/src/scossl_ciphers.h
@@ -3,7 +3,6 @@
 //
 
 #include "scossl.h"
-#include "scossl_helpers.h"
 #include <string.h>
 
 #ifdef __cplusplus
@@ -11,16 +10,16 @@ extern "C" {
 #endif
 
 // Initialize all of the _hidden_* cipher variables
-SCOSSL_STATUS scossl_ciphers_init_static();
+SCOSSL_STATUS e_scossl_ciphers_init_static();
 
 // Using ENGINE e, populate cipher with the one asked for by nid.
 // If cipher is NULL, return a list of supported nids in the nids parameter.
 // Returns 1 on success, or 0 on error for cipher case, and number of nids in nids list case.
 _Success_(return > 0)
-int scossl_ciphers(_Inout_ ENGINE *e, _Out_ const EVP_CIPHER **cipher,
+int e_scossl_ciphers(_Inout_ ENGINE *e, _Out_ const EVP_CIPHER **cipher,
                     _Out_ const int **nids, int nid);
 
-void scossl_destroy_ciphers(void);
+void e_scossl_destroy_ciphers(void);
 
 #ifdef __cplusplus
 }
diff --git a/SymCryptEngine/src/scossl_dh.c b/SymCryptEngine/src/scossl_dh.c
index 95ce385..e6bab14 100644
--- a/SymCryptEngine/src/scossl_dh.c
+++ b/SymCryptEngine/src/scossl_dh.c
@@ -8,7 +8,7 @@
 extern "C" {
 #endif
 
-int scossl_dh_idx = -1;
+int e_scossl_dh_idx = -1;
 
 // Largest supported safe-prime group is 4096b => 512 byte Public key
 #define SCOSSL_DH_MAX_PUBLIC_KEY_LEN (512)
@@ -27,7 +27,7 @@ typedef struct _SCOSSL_DH_KEY_CONTEXT {
 } SCOSSL_DH_KEY_CONTEXT;
 typedef       SCOSSL_DH_KEY_CONTEXT * PSCOSSL_DH_KEY_CONTEXT;
 
-void scossl_dh_free_key_context(_Inout_ PSCOSSL_DH_KEY_CONTEXT pKeyCtx)
+void e_scossl_dh_free_key_context(_Inout_ PSCOSSL_DH_KEY_CONTEXT pKeyCtx)
 {
     pKeyCtx->initialized = 0;
     if( pKeyCtx->dlkey )
@@ -49,7 +49,7 @@ static PSYMCRYPT_DLGROUP _hidden_dlgroup_ffdhe4096 = NULL;
 
 // Generates a new keypair using pDlgroup, storing the new keypair in dh and pKeyCtx.
 // Returns SCOSSL_SUCCESS on success or SCOSSL_FAILURE on error.
-SCOSSL_STATUS scossl_dh_generate_keypair(
+SCOSSL_STATUS e_scossl_dh_generate_keypair(
     _Inout_ PSCOSSL_DH_KEY_CONTEXT pKeyCtx, _In_ PCSYMCRYPT_DLGROUP pDlgroup, _Inout_ DH* dh)
 {
     SYMCRYPT_ERROR scError = SYMCRYPT_NO_ERROR;
@@ -155,7 +155,7 @@ cleanup:
     if( res != SCOSSL_SUCCESS )
     {
         // On error free the partially constructed key context
-        scossl_dh_free_key_context(pKeyCtx);
+        e_scossl_dh_free_key_context(pKeyCtx);
     }
 
     BN_clear_free(dh_privkey);
@@ -172,7 +172,7 @@ cleanup:
 // Imports key using dh and dlGroup, into pKeyCtx.
 // Also populates the public key of dh if it only currently has a private key specified.
 // Returns SCOSSL_SUCCESS on success or SCOSSL_FAILURE on error.
-SCOSSL_STATUS scossl_dh_import_keypair(
+SCOSSL_STATUS e_scossl_dh_import_keypair(
     _Inout_ DH* dh, _Inout_ PSCOSSL_DH_KEY_CONTEXT pKeyCtx, _In_ PCSYMCRYPT_DLGROUP pDlgroup )
 {
     SYMCRYPT_ERROR scError = SYMCRYPT_NO_ERROR;
@@ -325,7 +325,7 @@ cleanup:
     if( res != SCOSSL_SUCCESS )
     {
         // On error free the partially constructed key context
-        scossl_dh_free_key_context(pKeyCtx);
+        e_scossl_dh_free_key_context(pKeyCtx);
     }
 
     BN_free(generated_dh_pubkey);
@@ -338,7 +338,7 @@ cleanup:
     return res;
 }
 
-PSYMCRYPT_DLGROUP scossl_initialize_safeprime_dlgroup(_Inout_ PSYMCRYPT_DLGROUP* ppDlgroup,
+PSYMCRYPT_DLGROUP e_scossl_initialize_safeprime_dlgroup(_Inout_ PSYMCRYPT_DLGROUP* ppDlgroup,
     SYMCRYPT_DLGROUP_DH_SAFEPRIMETYPE dhSafePrimeType, UINT32 nBitsOfP )
 {
     SYMCRYPT_ERROR scError = SYMCRYPT_NO_ERROR;
@@ -360,14 +360,14 @@ cleanup:
     return *ppDlgroup;
 }
 
-SCOSSL_STATUS scossl_dh_init_static()
+SCOSSL_STATUS e_scossl_dh_init_static()
 {
-    if( (scossl_initialize_safeprime_dlgroup( &_hidden_dlgroup_ffdhe2048, SYMCRYPT_DLGROUP_DH_SAFEPRIMETYPE_TLS_7919, 2048 ) == NULL) ||
-        (scossl_initialize_safeprime_dlgroup( &_hidden_dlgroup_ffdhe3072, SYMCRYPT_DLGROUP_DH_SAFEPRIMETYPE_TLS_7919, 3072 ) == NULL) ||
-        (scossl_initialize_safeprime_dlgroup( &_hidden_dlgroup_ffdhe4096, SYMCRYPT_DLGROUP_DH_SAFEPRIMETYPE_TLS_7919, 4096 ) == NULL) ||
-        (scossl_initialize_safeprime_dlgroup( &_hidden_dlgroup_modp2048, SYMCRYPT_DLGROUP_DH_SAFEPRIMETYPE_IKE_3526, 2048 ) == NULL) ||
-        (scossl_initialize_safeprime_dlgroup( &_hidden_dlgroup_modp3072, SYMCRYPT_DLGROUP_DH_SAFEPRIMETYPE_IKE_3526, 3072 ) == NULL) ||
-        (scossl_initialize_safeprime_dlgroup( &_hidden_dlgroup_modp4096, SYMCRYPT_DLGROUP_DH_SAFEPRIMETYPE_IKE_3526, 4096 ) == NULL) ||
+    if( (e_scossl_initialize_safeprime_dlgroup( &_hidden_dlgroup_ffdhe2048, SYMCRYPT_DLGROUP_DH_SAFEPRIMETYPE_TLS_7919, 2048 ) == NULL) ||
+        (e_scossl_initialize_safeprime_dlgroup( &_hidden_dlgroup_ffdhe3072, SYMCRYPT_DLGROUP_DH_SAFEPRIMETYPE_TLS_7919, 3072 ) == NULL) ||
+        (e_scossl_initialize_safeprime_dlgroup( &_hidden_dlgroup_ffdhe4096, SYMCRYPT_DLGROUP_DH_SAFEPRIMETYPE_TLS_7919, 4096 ) == NULL) ||
+        (e_scossl_initialize_safeprime_dlgroup( &_hidden_dlgroup_modp2048, SYMCRYPT_DLGROUP_DH_SAFEPRIMETYPE_IKE_3526, 2048 ) == NULL) ||
+        (e_scossl_initialize_safeprime_dlgroup( &_hidden_dlgroup_modp3072, SYMCRYPT_DLGROUP_DH_SAFEPRIMETYPE_IKE_3526, 3072 ) == NULL) ||
+        (e_scossl_initialize_safeprime_dlgroup( &_hidden_dlgroup_modp4096, SYMCRYPT_DLGROUP_DH_SAFEPRIMETYPE_IKE_3526, 4096 ) == NULL) ||
         ((_hidden_bignum_modp2048 = BN_get_rfc3526_prime_2048(NULL)) == NULL) ||
         ((_hidden_bignum_modp3072 = BN_get_rfc3526_prime_3072(NULL)) == NULL) ||
         ((_hidden_bignum_modp4096 = BN_get_rfc3526_prime_4096(NULL)) == NULL) )
@@ -380,7 +380,7 @@ SCOSSL_STATUS scossl_dh_init_static()
 // returns SCOSSL_FALLBACK when the dh is not supported by the engine, so we should fallback to OpenSSL
 // returns SCOSSL_FAILURE on an error
 // returns SCOSSL_SUCCESS and sets pKeyCtx to a pointer to an initialized SCOSSL_DH_KEY_CONTEXT on success
-SCOSSL_STATUS scossl_get_dh_context_ex(_Inout_ DH* dh, _Out_ PSCOSSL_DH_KEY_CONTEXT* ppKeyCtx, BOOL generate)
+SCOSSL_STATUS e_scossl_get_dh_context_ex(_Inout_ DH* dh, _Out_ PSCOSSL_DH_KEY_CONTEXT* ppKeyCtx, BOOL generate)
 {
     PSYMCRYPT_DLGROUP pDlgroup = NULL;
 
@@ -443,7 +443,7 @@ SCOSSL_STATUS scossl_get_dh_context_ex(_Inout_ DH* dh, _Out_ PSCOSSL_DH_KEY_CONT
         return SCOSSL_FAILURE;
     }
 
-    *ppKeyCtx = (PSCOSSL_DH_KEY_CONTEXT) DH_get_ex_data(dh, scossl_dh_idx);
+    *ppKeyCtx = (PSCOSSL_DH_KEY_CONTEXT) DH_get_ex_data(dh, e_scossl_dh_idx);
 
     if( *ppKeyCtx == NULL )
     {
@@ -455,7 +455,7 @@ SCOSSL_STATUS scossl_get_dh_context_ex(_Inout_ DH* dh, _Out_ PSCOSSL_DH_KEY_CONT
             return SCOSSL_FAILURE;
         }
 
-        if( DH_set_ex_data(dh, scossl_dh_idx, pKeyCtx) == 0)
+        if( DH_set_ex_data(dh, e_scossl_dh_idx, pKeyCtx) == 0)
         {
             SCOSSL_LOG_ERROR(SCOSSL_ERR_F_GET_DH_CONTEXT_EX, ERR_R_OPERATION_FAIL,
                 "DH_set_ex_data failed");
@@ -477,32 +477,32 @@ SCOSSL_STATUS scossl_get_dh_context_ex(_Inout_ DH* dh, _Out_ PSCOSSL_DH_KEY_CONT
 
     if( generate && (dh_privkey == NULL) )
     {
-        return scossl_dh_generate_keypair(*ppKeyCtx, pDlgroup, dh);
+        return e_scossl_dh_generate_keypair(*ppKeyCtx, pDlgroup, dh);
     }
     else
     {
-        return scossl_dh_import_keypair(dh, *ppKeyCtx, pDlgroup);
+        return e_scossl_dh_import_keypair(dh, *ppKeyCtx, pDlgroup);
     }
 }
 
 // returns SCOSSL_FALLBACK when the dh is not supported by the engine, so we should fallback to OpenSSL
 // returns SCOSSL_FAILURE on an error
 // returns SCOSSL_SUCCESS and sets pKeyCtx to a pointer to an initialized SCOSSL_DH_KEY_CONTEXT on success
-SCOSSL_STATUS scossl_get_dh_context(_Inout_ DH* dh, _Out_ PSCOSSL_DH_KEY_CONTEXT* ppKeyCtx)
+SCOSSL_STATUS e_scossl_get_dh_context(_Inout_ DH* dh, _Out_ PSCOSSL_DH_KEY_CONTEXT* ppKeyCtx)
 {
-    return scossl_get_dh_context_ex(dh, ppKeyCtx, FALSE);
+    return e_scossl_get_dh_context_ex(dh, ppKeyCtx, FALSE);
 }
 
-SCOSSL_STATUS scossl_dh_generate_key(_Inout_ DH* dh)
+SCOSSL_STATUS e_scossl_dh_generate_key(_Inout_ DH* dh)
 {
     PFN_DH_meth_generate_key pfn_dh_meth_generate_key = NULL;
     PSCOSSL_DH_KEY_CONTEXT pKeyCtx = NULL;
 
-    switch( scossl_get_dh_context_ex(dh, &pKeyCtx, TRUE) )
+    switch( e_scossl_get_dh_context_ex(dh, &pKeyCtx, TRUE) )
     {
     case SCOSSL_FAILURE:
         SCOSSL_LOG_ERROR(SCOSSL_ERR_F_DH_GENERATE_KEY, ERR_R_OPERATION_FAIL,
-            "scossl_get_dh_context_ex failed.");
+            "e_scossl_get_dh_context_ex failed.");
         return SCOSSL_FAILURE;
     case SCOSSL_FALLBACK:
         pfn_dh_meth_generate_key = DH_meth_get_generate_key(DH_OpenSSL());
@@ -515,12 +515,12 @@ SCOSSL_STATUS scossl_dh_generate_key(_Inout_ DH* dh)
         return SCOSSL_SUCCESS;
     default:
         SCOSSL_LOG_ERROR(SCOSSL_ERR_F_DH_GENERATE_KEY, ERR_R_INTERNAL_ERROR,
-            "Unexpected scossl_get_dh_context_ex value");
+            "Unexpected e_scossl_get_dh_context_ex value");
         return SCOSSL_FAILURE;
     }
 }
 
-SCOSSL_RETURNLENGTH scossl_dh_compute_key(_Out_writes_bytes_(DH_size(dh)) unsigned char* key,
+SCOSSL_RETURNLENGTH e_scossl_dh_compute_key(_Out_writes_bytes_(DH_size(dh)) unsigned char* key,
                                             _In_ const BIGNUM* pub_key,
                                             _In_ DH* dh)
 {
@@ -534,11 +534,11 @@ SCOSSL_RETURNLENGTH scossl_dh_compute_key(_Out_writes_bytes_(DH_size(dh)) unsign
 
     int res = -1; // fail
 
-    switch( scossl_get_dh_context(dh, &pKeyCtx) )
+    switch( e_scossl_get_dh_context(dh, &pKeyCtx) )
     {
     case SCOSSL_FAILURE:
         SCOSSL_LOG_ERROR(SCOSSL_ERR_F_DH_COMPUTE_KEY, ERR_R_OPERATION_FAIL,
-            "scossl_get_dh_context failed.");
+            "e_scossl_get_dh_context failed.");
         return res;
     case SCOSSL_FALLBACK:
         pfn_dh_meth_compute_key = DH_meth_get_compute_key(DH_OpenSSL());
@@ -551,7 +551,7 @@ SCOSSL_RETURNLENGTH scossl_dh_compute_key(_Out_writes_bytes_(DH_size(dh)) unsign
         break;
     default:
         SCOSSL_LOG_ERROR(SCOSSL_ERR_F_DH_COMPUTE_KEY, ERR_R_INTERNAL_ERROR,
-            "Unexpected scossl_get_dh_context_ex value");
+            "Unexpected e_scossl_get_dh_context_ex value");
         return res;
     }
 
@@ -612,18 +612,18 @@ cleanup:
     return res;
 }
 
-SCOSSL_STATUS scossl_dh_finish(_Inout_ DH* dh)
+SCOSSL_STATUS e_scossl_dh_finish(_Inout_ DH* dh)
 {
     PFN_DH_meth_finish pfn_dh_meth_finish = DH_meth_get_finish(DH_OpenSSL());
-    PSCOSSL_DH_KEY_CONTEXT pKeyCtx = DH_get_ex_data(dh, scossl_dh_idx);
+    PSCOSSL_DH_KEY_CONTEXT pKeyCtx = DH_get_ex_data(dh, e_scossl_dh_idx);
     if( pKeyCtx )
     {
         if( pKeyCtx->initialized == 1 )
         {
-            scossl_dh_free_key_context(pKeyCtx);
+            e_scossl_dh_free_key_context(pKeyCtx);
         }
         OPENSSL_free(pKeyCtx);
-        DH_set_ex_data(dh, scossl_dh_idx, NULL);
+        DH_set_ex_data(dh, e_scossl_dh_idx, NULL);
     }
 
     // Ensure any buffers initialized by DH_OpenSSL are freed
@@ -634,7 +634,7 @@ SCOSSL_STATUS scossl_dh_finish(_Inout_ DH* dh)
     return pfn_dh_meth_finish(dh);
 }
 
-void scossl_destroy_safeprime_dlgroups(void)
+void e_scossl_destroy_safeprime_dlgroups(void)
 {
     if( _hidden_dlgroup_ffdhe2048 )
     {
diff --git a/SymCryptEngine/src/scossl_dh.h b/SymCryptEngine/src/scossl_dh.h
index 9807b26..64b9a41 100644
--- a/SymCryptEngine/src/scossl_dh.h
+++ b/SymCryptEngine/src/scossl_dh.h
@@ -3,36 +3,35 @@
 //
 
 #include "scossl.h"
-#include "scossl_helpers.h"
 #include <openssl/dh.h>
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-extern int scossl_dh_idx;
+extern int e_scossl_dh_idx;
 
 // Initialize all of the _hidden_* dh variables
-SCOSSL_STATUS scossl_dh_init_static();
+SCOSSL_STATUS e_scossl_dh_init_static();
 
 // Generates public and private DH values.
 // Expects shared parameters dh->p and dh->g to be set.
 // Generates a random private DH key unless dh->priv_key set, and computes corresponding
 // public value dh->pub_key.
 // Returns 1 on success, 0 otherwise
-SCOSSL_STATUS scossl_dh_generate_key(_Inout_ DH* dh);
+SCOSSL_STATUS e_scossl_dh_generate_key(_Inout_ DH* dh);
 
 // Computes the shared secret from the private DH value in dh and the other party's public
 // value in pub_key and stores it in key. key must point to DH_size(dh) bytes of memory.
 // Returns size of shared secret on success, or -1 on error.
-SCOSSL_RETURNLENGTH scossl_dh_compute_key(_Out_writes_bytes_(DH_size(dh)) unsigned char* key, _In_ const BIGNUM* pub_key, _In_ DH* dh);
+SCOSSL_RETURNLENGTH e_scossl_dh_compute_key(_Out_writes_bytes_(DH_size(dh)) unsigned char* key, _In_ const BIGNUM* pub_key, _In_ DH* dh);
 
 // Destroys instance of DH object. The memory for dh is not freed by this function.
 // Returns 1 on success, or 0 on error
-SCOSSL_STATUS scossl_dh_finish(_Inout_ DH* dh);
+SCOSSL_STATUS e_scossl_dh_finish(_Inout_ DH* dh);
 
 // Frees internal SymCrypt safe-prime Dlgroups, only to be used on engine destruction.
-void scossl_destroy_safeprime_dlgroups(void);
+void e_scossl_destroy_safeprime_dlgroups(void);
 
 #ifdef __cplusplus
 }
diff --git a/SymCryptEngine/src/scossl_digests.c b/SymCryptEngine/src/scossl_digests.c
index 8c7006b..1890932 100644
--- a/SymCryptEngine/src/scossl_digests.c
+++ b/SymCryptEngine/src/scossl_digests.c
@@ -8,7 +8,7 @@
 extern "C" {
 #endif
 
-static int scossl_digest_nids[] = {
+static int e_scossl_digest_nids[] = {
     NID_md5,
     NID_sha1,
     NID_sha256,
@@ -17,22 +17,22 @@ static int scossl_digest_nids[] = {
 };
 
 /* MD5 */
-static SCOSSL_STATUS scossl_digest_md5_init(_Out_ EVP_MD_CTX *ctx);
-static SCOSSL_STATUS scossl_digest_md5_update(_Inout_ EVP_MD_CTX *ctx, _In_reads_bytes_(count) const void *data, size_t count);
-static SCOSSL_STATUS scossl_digest_md5_final(_Inout_ EVP_MD_CTX *ctx, _Out_writes_(SYMCRYPT_MD5_RESULT_SIZE) unsigned char *md);
-static SCOSSL_STATUS scossl_digest_md5_copy(_Out_ EVP_MD_CTX *to, _In_ const EVP_MD_CTX *from);
+static SCOSSL_STATUS e_scossl_digest_md5_init(_Out_ EVP_MD_CTX *ctx);
+static SCOSSL_STATUS e_scossl_digest_md5_update(_Inout_ EVP_MD_CTX *ctx, _In_reads_bytes_(count) const void *data, size_t count);
+static SCOSSL_STATUS e_scossl_digest_md5_final(_Inout_ EVP_MD_CTX *ctx, _Out_writes_(SYMCRYPT_MD5_RESULT_SIZE) unsigned char *md);
+static SCOSSL_STATUS e_scossl_digest_md5_copy(_Out_ EVP_MD_CTX *to, _In_ const EVP_MD_CTX *from);
 static EVP_MD *_hidden_md5_md = NULL;
-static const EVP_MD *scossl_digest_md5(void)
+static const EVP_MD *e_scossl_digest_md5(void)
 {
     if ((_hidden_md5_md = EVP_MD_meth_new(NID_md5, NID_md5WithRSAEncryption)) == NULL
         || !EVP_MD_meth_set_result_size(_hidden_md5_md, MD5_DIGEST_LENGTH)
         || !EVP_MD_meth_set_input_blocksize(_hidden_md5_md, MD5_CBLOCK)
         || !EVP_MD_meth_set_app_datasize(_hidden_md5_md, sizeof(SYMCRYPT_MD5_STATE))
         || !EVP_MD_meth_set_flags(_hidden_md5_md, 0)
-        || !EVP_MD_meth_set_init(_hidden_md5_md, scossl_digest_md5_init)
-        || !EVP_MD_meth_set_update(_hidden_md5_md, scossl_digest_md5_update)
-        || !EVP_MD_meth_set_final(_hidden_md5_md, scossl_digest_md5_final)
-        || !EVP_MD_meth_set_copy(_hidden_md5_md, scossl_digest_md5_copy)
+        || !EVP_MD_meth_set_init(_hidden_md5_md, e_scossl_digest_md5_init)
+        || !EVP_MD_meth_set_update(_hidden_md5_md, e_scossl_digest_md5_update)
+        || !EVP_MD_meth_set_final(_hidden_md5_md, e_scossl_digest_md5_final)
+        || !EVP_MD_meth_set_copy(_hidden_md5_md, e_scossl_digest_md5_copy)
         )
     {
         EVP_MD_meth_free(_hidden_md5_md);
@@ -42,22 +42,22 @@ static const EVP_MD *scossl_digest_md5(void)
 }
 
 /* SHA1 */
-static SCOSSL_STATUS scossl_digest_sha1_init(_Out_ EVP_MD_CTX *ctx);
-static SCOSSL_STATUS scossl_digest_sha1_update(_Inout_ EVP_MD_CTX *ctx, _In_reads_bytes_(count) const void *data, size_t count);
-static SCOSSL_STATUS scossl_digest_sha1_final(_Inout_ EVP_MD_CTX *ctx, _Out_writes_(SYMCRYPT_SHA1_RESULT_SIZE) unsigned char *md);
-static SCOSSL_STATUS scossl_digest_sha1_copy(_Out_ EVP_MD_CTX *to, _In_ const EVP_MD_CTX *from);
+static SCOSSL_STATUS e_scossl_digest_sha1_init(_Out_ EVP_MD_CTX *ctx);
+static SCOSSL_STATUS e_scossl_digest_sha1_update(_Inout_ EVP_MD_CTX *ctx, _In_reads_bytes_(count) const void *data, size_t count);
+static SCOSSL_STATUS e_scossl_digest_sha1_final(_Inout_ EVP_MD_CTX *ctx, _Out_writes_(SYMCRYPT_SHA1_RESULT_SIZE) unsigned char *md);
+static SCOSSL_STATUS e_scossl_digest_sha1_copy(_Out_ EVP_MD_CTX *to, _In_ const EVP_MD_CTX *from);
 static EVP_MD *_hidden_sha1_md = NULL;
-static const EVP_MD *scossl_digest_sha1(void)
+static const EVP_MD *e_scossl_digest_sha1(void)
 {
     if( (_hidden_sha1_md = EVP_MD_meth_new(NID_sha1, NID_sha1WithRSAEncryption)) == NULL
         || !EVP_MD_meth_set_result_size(_hidden_sha1_md, SHA_DIGEST_LENGTH)
         || !EVP_MD_meth_set_input_blocksize(_hidden_sha1_md, SHA_CBLOCK)
         || !EVP_MD_meth_set_app_datasize(_hidden_sha1_md, sizeof(SYMCRYPT_SHA1_STATE))
         || !EVP_MD_meth_set_flags(_hidden_sha1_md, EVP_MD_FLAG_DIGALGID_ABSENT | EVP_MD_FLAG_FIPS)
-        || !EVP_MD_meth_set_init(_hidden_sha1_md, scossl_digest_sha1_init)
-        || !EVP_MD_meth_set_update(_hidden_sha1_md, scossl_digest_sha1_update)
-        || !EVP_MD_meth_set_final(_hidden_sha1_md, scossl_digest_sha1_final)
-        || !EVP_MD_meth_set_copy(_hidden_sha1_md, scossl_digest_sha1_copy)
+        || !EVP_MD_meth_set_init(_hidden_sha1_md, e_scossl_digest_sha1_init)
+        || !EVP_MD_meth_set_update(_hidden_sha1_md, e_scossl_digest_sha1_update)
+        || !EVP_MD_meth_set_final(_hidden_sha1_md, e_scossl_digest_sha1_final)
+        || !EVP_MD_meth_set_copy(_hidden_sha1_md, e_scossl_digest_sha1_copy)
         )
     {
         EVP_MD_meth_free(_hidden_sha1_md);
@@ -67,22 +67,22 @@ static const EVP_MD *scossl_digest_sha1(void)
 }
 
 /* SHA256 */
-static SCOSSL_STATUS scossl_digest_sha256_init(_Out_ EVP_MD_CTX *ctx);
-static SCOSSL_STATUS scossl_digest_sha256_update(_Inout_ EVP_MD_CTX *ctx, _In_reads_bytes_(count) const void *data, size_t count);
-static SCOSSL_STATUS scossl_digest_sha256_final(_Inout_ EVP_MD_CTX *ctx, _Out_writes_(SYMCRYPT_SHA256_RESULT_SIZE) unsigned char *md);
-static SCOSSL_STATUS scossl_digest_sha256_copy(_Out_ EVP_MD_CTX *to, _In_ const EVP_MD_CTX *from);
+static SCOSSL_STATUS e_scossl_digest_sha256_init(_Out_ EVP_MD_CTX *ctx);
+static SCOSSL_STATUS e_scossl_digest_sha256_update(_Inout_ EVP_MD_CTX *ctx, _In_reads_bytes_(count) const void *data, size_t count);
+static SCOSSL_STATUS e_scossl_digest_sha256_final(_Inout_ EVP_MD_CTX *ctx, _Out_writes_(SYMCRYPT_SHA256_RESULT_SIZE) unsigned char *md);
+static SCOSSL_STATUS e_scossl_digest_sha256_copy(_Out_ EVP_MD_CTX *to, _In_ const EVP_MD_CTX *from);
 static EVP_MD *_hidden_sha256_md = NULL;
-static const EVP_MD *scossl_digest_sha256(void)
+static const EVP_MD *e_scossl_digest_sha256(void)
 {
     if( (_hidden_sha256_md = EVP_MD_meth_new(NID_sha256, NID_sha256WithRSAEncryption)) == NULL
         || !EVP_MD_meth_set_result_size(_hidden_sha256_md, SHA256_DIGEST_LENGTH)
         || !EVP_MD_meth_set_input_blocksize(_hidden_sha256_md, SHA256_CBLOCK)
         || !EVP_MD_meth_set_app_datasize(_hidden_sha256_md, sizeof(SYMCRYPT_SHA256_STATE))
         || !EVP_MD_meth_set_flags(_hidden_sha256_md, EVP_MD_FLAG_DIGALGID_ABSENT | EVP_MD_FLAG_FIPS)
-        || !EVP_MD_meth_set_init(_hidden_sha256_md, scossl_digest_sha256_init)
-        || !EVP_MD_meth_set_update(_hidden_sha256_md, scossl_digest_sha256_update)
-        || !EVP_MD_meth_set_final(_hidden_sha256_md, scossl_digest_sha256_final)
-        || !EVP_MD_meth_set_copy(_hidden_sha256_md, scossl_digest_sha256_copy)
+        || !EVP_MD_meth_set_init(_hidden_sha256_md, e_scossl_digest_sha256_init)
+        || !EVP_MD_meth_set_update(_hidden_sha256_md, e_scossl_digest_sha256_update)
+        || !EVP_MD_meth_set_final(_hidden_sha256_md, e_scossl_digest_sha256_final)
+        || !EVP_MD_meth_set_copy(_hidden_sha256_md, e_scossl_digest_sha256_copy)
         )
     {
         EVP_MD_meth_free(_hidden_sha256_md);
@@ -92,22 +92,22 @@ static const EVP_MD *scossl_digest_sha256(void)
 }
 
 /* SHA384 */
-static SCOSSL_STATUS scossl_digest_sha384_init(_Out_ EVP_MD_CTX *ctx);
-static SCOSSL_STATUS scossl_digest_sha384_update(_Inout_ EVP_MD_CTX *ctx, _In_reads_bytes_(count) const void *data, size_t count);
-static SCOSSL_STATUS scossl_digest_sha384_final(_Inout_ EVP_MD_CTX *ctx, _Out_writes_(SYMCRYPT_SHA384_RESULT_SIZE) unsigned char *md);
-static SCOSSL_STATUS scossl_digest_sha384_copy(_Out_ EVP_MD_CTX *to, _In_ const EVP_MD_CTX *from);
+static SCOSSL_STATUS e_scossl_digest_sha384_init(_Out_ EVP_MD_CTX *ctx);
+static SCOSSL_STATUS e_scossl_digest_sha384_update(_Inout_ EVP_MD_CTX *ctx, _In_reads_bytes_(count) const void *data, size_t count);
+static SCOSSL_STATUS e_scossl_digest_sha384_final(_Inout_ EVP_MD_CTX *ctx, _Out_writes_(SYMCRYPT_SHA384_RESULT_SIZE) unsigned char *md);
+static SCOSSL_STATUS e_scossl_digest_sha384_copy(_Out_ EVP_MD_CTX *to, _In_ const EVP_MD_CTX *from);
 static EVP_MD *_hidden_sha384_md = NULL;
-static const EVP_MD *scossl_digest_sha384(void)
+static const EVP_MD *e_scossl_digest_sha384(void)
 {
     if( (_hidden_sha384_md = EVP_MD_meth_new(NID_sha384, NID_sha384WithRSAEncryption)) == NULL
         || !EVP_MD_meth_set_result_size(_hidden_sha384_md, SHA384_DIGEST_LENGTH)
         || !EVP_MD_meth_set_input_blocksize(_hidden_sha384_md, SHA512_CBLOCK)
         || !EVP_MD_meth_set_app_datasize(_hidden_sha384_md, sizeof(SYMCRYPT_SHA384_STATE))
         || !EVP_MD_meth_set_flags(_hidden_sha384_md, EVP_MD_FLAG_DIGALGID_ABSENT | EVP_MD_FLAG_FIPS)
-        || !EVP_MD_meth_set_init(_hidden_sha384_md, scossl_digest_sha384_init)
-        || !EVP_MD_meth_set_update(_hidden_sha384_md, scossl_digest_sha384_update)
-        || !EVP_MD_meth_set_final(_hidden_sha384_md, scossl_digest_sha384_final)
-        || !EVP_MD_meth_set_copy(_hidden_sha384_md, scossl_digest_sha384_copy)
+        || !EVP_MD_meth_set_init(_hidden_sha384_md, e_scossl_digest_sha384_init)
+        || !EVP_MD_meth_set_update(_hidden_sha384_md, e_scossl_digest_sha384_update)
+        || !EVP_MD_meth_set_final(_hidden_sha384_md, e_scossl_digest_sha384_final)
+        || !EVP_MD_meth_set_copy(_hidden_sha384_md, e_scossl_digest_sha384_copy)
         )
     {
         EVP_MD_meth_free(_hidden_sha384_md);
@@ -117,22 +117,22 @@ static const EVP_MD *scossl_digest_sha384(void)
 }
 
 /* SHA512 */
-static SCOSSL_STATUS scossl_digest_sha512_init(_Out_ EVP_MD_CTX *ctx);
-static SCOSSL_STATUS scossl_digest_sha512_update(_Inout_ EVP_MD_CTX *ctx, _In_reads_bytes_(count) const void *data, size_t count);
-static SCOSSL_STATUS scossl_digest_sha512_final(_Inout_ EVP_MD_CTX *ctx, _Out_writes_(SYMCRYPT_SHA512_RESULT_SIZE) unsigned char *md);
-static SCOSSL_STATUS scossl_digest_sha512_copy(_Out_ EVP_MD_CTX *to, _In_ const EVP_MD_CTX *from);
+static SCOSSL_STATUS e_scossl_digest_sha512_init(_Out_ EVP_MD_CTX *ctx);
+static SCOSSL_STATUS e_scossl_digest_sha512_update(_Inout_ EVP_MD_CTX *ctx, _In_reads_bytes_(count) const void *data, size_t count);
+static SCOSSL_STATUS e_scossl_digest_sha512_final(_Inout_ EVP_MD_CTX *ctx, _Out_writes_(SYMCRYPT_SHA512_RESULT_SIZE) unsigned char *md);
+static SCOSSL_STATUS e_scossl_digest_sha512_copy(_Out_ EVP_MD_CTX *to, _In_ const EVP_MD_CTX *from);
 static EVP_MD *_hidden_sha512_md = NULL;
-static const EVP_MD *scossl_digest_sha512(void)
+static const EVP_MD *e_scossl_digest_sha512(void)
 {
     if( (_hidden_sha512_md = EVP_MD_meth_new(NID_sha512, NID_sha512WithRSAEncryption)) == NULL
         || !EVP_MD_meth_set_result_size(_hidden_sha512_md, SHA512_DIGEST_LENGTH)
         || !EVP_MD_meth_set_input_blocksize(_hidden_sha512_md, SHA512_CBLOCK)
         || !EVP_MD_meth_set_app_datasize(_hidden_sha512_md, sizeof(SYMCRYPT_SHA512_STATE))
         || !EVP_MD_meth_set_flags(_hidden_sha512_md, EVP_MD_FLAG_DIGALGID_ABSENT | EVP_MD_FLAG_FIPS)
-        || !EVP_MD_meth_set_init(_hidden_sha512_md, scossl_digest_sha512_init)
-        || !EVP_MD_meth_set_update(_hidden_sha512_md, scossl_digest_sha512_update)
-        || !EVP_MD_meth_set_final(_hidden_sha512_md, scossl_digest_sha512_final)
-        || !EVP_MD_meth_set_copy(_hidden_sha512_md, scossl_digest_sha512_copy)
+        || !EVP_MD_meth_set_init(_hidden_sha512_md, e_scossl_digest_sha512_init)
+        || !EVP_MD_meth_set_update(_hidden_sha512_md, e_scossl_digest_sha512_update)
+        || !EVP_MD_meth_set_final(_hidden_sha512_md, e_scossl_digest_sha512_final)
+        || !EVP_MD_meth_set_copy(_hidden_sha512_md, e_scossl_digest_sha512_copy)
         )
     {
         EVP_MD_meth_free(_hidden_sha512_md);
@@ -141,7 +141,7 @@ static const EVP_MD *scossl_digest_sha512(void)
     return _hidden_sha512_md;
 }
 
-void scossl_destroy_digests(void)
+void e_scossl_destroy_digests(void)
 {
     EVP_MD_meth_free(_hidden_md5_md);
     EVP_MD_meth_free(_hidden_sha1_md);
@@ -155,13 +155,13 @@ void scossl_destroy_digests(void)
     _hidden_sha512_md = NULL;
 }
 
-SCOSSL_STATUS scossl_digests_init_static()
+SCOSSL_STATUS e_scossl_digests_init_static()
 {
-    if( (scossl_digest_md5() == NULL) ||
-        (scossl_digest_sha1() == NULL) ||
-        (scossl_digest_sha256() == NULL) ||
-        (scossl_digest_sha384() == NULL) ||
-        (scossl_digest_sha512() == NULL) )
+    if( (e_scossl_digest_md5() == NULL) ||
+        (e_scossl_digest_sha1() == NULL) ||
+        (e_scossl_digest_sha256() == NULL) ||
+        (e_scossl_digest_sha384() == NULL) ||
+        (e_scossl_digest_sha512() == NULL) )
     {
         return SCOSSL_FAILURE;
     }
@@ -169,16 +169,16 @@ SCOSSL_STATUS scossl_digests_init_static()
 }
 
 _Success_(return > 0)
-int scossl_digests(_Inout_ ENGINE *e, _Out_opt_ const EVP_MD **digest,
+int e_scossl_digests(_Inout_ ENGINE *e, _Out_opt_ const EVP_MD **digest,
                           _Out_opt_ const int **nids, int nid)
 {
     int ok = 1;
     if( !digest )
     {
         /* We are returning a list of supported nids */
-        *nids = scossl_digest_nids;
-        return (sizeof(scossl_digest_nids))
-               / sizeof(scossl_digest_nids[0]);
+        *nids = e_scossl_digest_nids;
+        return (sizeof(e_scossl_digest_nids))
+               / sizeof(e_scossl_digest_nids[0]);
     }
 
     /* We are being asked for a specific digest */
@@ -210,7 +210,7 @@ int scossl_digests(_Inout_ ENGINE *e, _Out_opt_ const EVP_MD **digest,
 /*
  * MD5 implementation.
  */
-static SCOSSL_STATUS scossl_digest_md5_init(_Out_ EVP_MD_CTX *ctx)
+static SCOSSL_STATUS e_scossl_digest_md5_init(_Out_ EVP_MD_CTX *ctx)
 {
     PSYMCRYPT_MD5_STATE state = (PSYMCRYPT_MD5_STATE)EVP_MD_CTX_md_data(ctx);
     if( state == NULL )
@@ -223,7 +223,7 @@ static SCOSSL_STATUS scossl_digest_md5_init(_Out_ EVP_MD_CTX *ctx)
     return SCOSSL_SUCCESS;
 }
 
-static SCOSSL_STATUS scossl_digest_md5_update(_Inout_ EVP_MD_CTX *ctx, _In_reads_bytes_(count) const void *data,
+static SCOSSL_STATUS e_scossl_digest_md5_update(_Inout_ EVP_MD_CTX *ctx, _In_reads_bytes_(count) const void *data,
                              size_t count)
 {
     PSYMCRYPT_MD5_STATE state = (PSYMCRYPT_MD5_STATE)EVP_MD_CTX_md_data(ctx);
@@ -237,7 +237,7 @@ static SCOSSL_STATUS scossl_digest_md5_update(_Inout_ EVP_MD_CTX *ctx, _In_reads
     return SCOSSL_SUCCESS;
 }
 
-static SCOSSL_STATUS scossl_digest_md5_final(_Inout_ EVP_MD_CTX *ctx, _Out_writes_(SYMCRYPT_MD5_RESULT_SIZE) unsigned char *md)
+static SCOSSL_STATUS e_scossl_digest_md5_final(_Inout_ EVP_MD_CTX *ctx, _Out_writes_(SYMCRYPT_MD5_RESULT_SIZE) unsigned char *md)
 {
     PSYMCRYPT_MD5_STATE state = (PSYMCRYPT_MD5_STATE)EVP_MD_CTX_md_data(ctx);
     if( state == NULL )
@@ -250,7 +250,7 @@ static SCOSSL_STATUS scossl_digest_md5_final(_Inout_ EVP_MD_CTX *ctx, _Out_write
     return SCOSSL_SUCCESS;
 }
 
-static SCOSSL_STATUS scossl_digest_md5_copy(_Out_ EVP_MD_CTX *to, _In_ const EVP_MD_CTX *from)
+static SCOSSL_STATUS e_scossl_digest_md5_copy(_Out_ EVP_MD_CTX *to, _In_ const EVP_MD_CTX *from)
 {
     PSYMCRYPT_MD5_STATE state_to = (PSYMCRYPT_MD5_STATE)EVP_MD_CTX_md_data(to);
     PSYMCRYPT_MD5_STATE state_from = (PSYMCRYPT_MD5_STATE)EVP_MD_CTX_md_data(from);
@@ -266,7 +266,7 @@ static SCOSSL_STATUS scossl_digest_md5_copy(_Out_ EVP_MD_CTX *to, _In_ const EVP
 /*
  * SHA1 implementation.
  */
-static SCOSSL_STATUS scossl_digest_sha1_init(_Out_ EVP_MD_CTX *ctx)
+static SCOSSL_STATUS e_scossl_digest_sha1_init(_Out_ EVP_MD_CTX *ctx)
 {
     PSYMCRYPT_SHA1_STATE state = (PSYMCRYPT_SHA1_STATE)EVP_MD_CTX_md_data(ctx);
     if( state == NULL )
@@ -279,7 +279,7 @@ static SCOSSL_STATUS scossl_digest_sha1_init(_Out_ EVP_MD_CTX *ctx)
     return SCOSSL_SUCCESS;
 }
 
-static SCOSSL_STATUS scossl_digest_sha1_update(_Inout_ EVP_MD_CTX *ctx, _In_reads_bytes_(count) const void *data,
+static SCOSSL_STATUS e_scossl_digest_sha1_update(_Inout_ EVP_MD_CTX *ctx, _In_reads_bytes_(count) const void *data,
                               size_t count)
 {
     PSYMCRYPT_SHA1_STATE state = (PSYMCRYPT_SHA1_STATE)EVP_MD_CTX_md_data(ctx);
@@ -293,7 +293,7 @@ static SCOSSL_STATUS scossl_digest_sha1_update(_Inout_ EVP_MD_CTX *ctx, _In_read
     return SCOSSL_SUCCESS;
 }
 
-static SCOSSL_STATUS scossl_digest_sha1_final(_Inout_ EVP_MD_CTX *ctx, _Out_writes_(SYMCRYPT_SHA1_RESULT_SIZE) unsigned char *md)
+static SCOSSL_STATUS e_scossl_digest_sha1_final(_Inout_ EVP_MD_CTX *ctx, _Out_writes_(SYMCRYPT_SHA1_RESULT_SIZE) unsigned char *md)
 {
     PSYMCRYPT_SHA1_STATE state = (PSYMCRYPT_SHA1_STATE)EVP_MD_CTX_md_data(ctx);
     if( state == NULL )
@@ -306,7 +306,7 @@ static SCOSSL_STATUS scossl_digest_sha1_final(_Inout_ EVP_MD_CTX *ctx, _Out_writ
     return SCOSSL_SUCCESS;
 }
 
-static SCOSSL_STATUS scossl_digest_sha1_copy(_Out_ EVP_MD_CTX *to, _In_ const EVP_MD_CTX *from)
+static SCOSSL_STATUS e_scossl_digest_sha1_copy(_Out_ EVP_MD_CTX *to, _In_ const EVP_MD_CTX *from)
 {
     PSYMCRYPT_SHA1_STATE state_to = (PSYMCRYPT_SHA1_STATE)EVP_MD_CTX_md_data(to);
     PSYMCRYPT_SHA1_STATE state_from = (PSYMCRYPT_SHA1_STATE)EVP_MD_CTX_md_data(from);
@@ -323,7 +323,7 @@ static SCOSSL_STATUS scossl_digest_sha1_copy(_Out_ EVP_MD_CTX *to, _In_ const EV
 /*
  * SHA256 implementation.
  */
-static SCOSSL_STATUS scossl_digest_sha256_init(_Out_ EVP_MD_CTX *ctx)
+static SCOSSL_STATUS e_scossl_digest_sha256_init(_Out_ EVP_MD_CTX *ctx)
 {
     PSYMCRYPT_SHA256_STATE state = (PSYMCRYPT_SHA256_STATE)EVP_MD_CTX_md_data(ctx);
     if( state == NULL )
@@ -336,7 +336,7 @@ static SCOSSL_STATUS scossl_digest_sha256_init(_Out_ EVP_MD_CTX *ctx)
     return SCOSSL_SUCCESS;
 }
 
-static SCOSSL_STATUS scossl_digest_sha256_update(_Inout_ EVP_MD_CTX *ctx, _In_reads_bytes_(count) const void *data,
+static SCOSSL_STATUS e_scossl_digest_sha256_update(_Inout_ EVP_MD_CTX *ctx, _In_reads_bytes_(count) const void *data,
                                 size_t count)
 {
     PSYMCRYPT_SHA256_STATE state = (PSYMCRYPT_SHA256_STATE)EVP_MD_CTX_md_data(ctx);
@@ -350,7 +350,7 @@ static SCOSSL_STATUS scossl_digest_sha256_update(_Inout_ EVP_MD_CTX *ctx, _In_re
     return SCOSSL_SUCCESS;
 }
 
-static SCOSSL_STATUS scossl_digest_sha256_final(_Inout_ EVP_MD_CTX *ctx, _Out_writes_(SYMCRYPT_SHA256_RESULT_SIZE) unsigned char *md)
+static SCOSSL_STATUS e_scossl_digest_sha256_final(_Inout_ EVP_MD_CTX *ctx, _Out_writes_(SYMCRYPT_SHA256_RESULT_SIZE) unsigned char *md)
 {
     PSYMCRYPT_SHA256_STATE state = (PSYMCRYPT_SHA256_STATE)EVP_MD_CTX_md_data(ctx);
     if( state == NULL )
@@ -363,7 +363,7 @@ static SCOSSL_STATUS scossl_digest_sha256_final(_Inout_ EVP_MD_CTX *ctx, _Out_wr
     return SCOSSL_SUCCESS;
 }
 
-static SCOSSL_STATUS scossl_digest_sha256_copy(_Out_ EVP_MD_CTX *to, _In_ const EVP_MD_CTX *from)
+static SCOSSL_STATUS e_scossl_digest_sha256_copy(_Out_ EVP_MD_CTX *to, _In_ const EVP_MD_CTX *from)
 {
     PSYMCRYPT_SHA256_STATE state_to = (PSYMCRYPT_SHA256_STATE)EVP_MD_CTX_md_data(to);
     PSYMCRYPT_SHA256_STATE state_from = (PSYMCRYPT_SHA256_STATE)EVP_MD_CTX_md_data(from);
@@ -379,7 +379,7 @@ static SCOSSL_STATUS scossl_digest_sha256_copy(_Out_ EVP_MD_CTX *to, _In_ const
 /*
  * SHA384 implementation.
  */
-static SCOSSL_STATUS scossl_digest_sha384_init(_Out_ EVP_MD_CTX *ctx)
+static SCOSSL_STATUS e_scossl_digest_sha384_init(_Out_ EVP_MD_CTX *ctx)
 {
     PSYMCRYPT_SHA384_STATE state = (PSYMCRYPT_SHA384_STATE)EVP_MD_CTX_md_data(ctx);
     if( state == NULL )
@@ -392,7 +392,7 @@ static SCOSSL_STATUS scossl_digest_sha384_init(_Out_ EVP_MD_CTX *ctx)
     return SCOSSL_SUCCESS;
 }
 
-static SCOSSL_STATUS scossl_digest_sha384_update(_Inout_ EVP_MD_CTX *ctx, _In_reads_bytes_(count) const void *data,
+static SCOSSL_STATUS e_scossl_digest_sha384_update(_Inout_ EVP_MD_CTX *ctx, _In_reads_bytes_(count) const void *data,
                                 size_t count)
 {
     PSYMCRYPT_SHA384_STATE state = (PSYMCRYPT_SHA384_STATE)EVP_MD_CTX_md_data(ctx);
@@ -406,7 +406,7 @@ static SCOSSL_STATUS scossl_digest_sha384_update(_Inout_ EVP_MD_CTX *ctx, _In_re
     return SCOSSL_SUCCESS;
 }
 
-static SCOSSL_STATUS scossl_digest_sha384_final(_Inout_ EVP_MD_CTX *ctx, _Out_writes_(SYMCRYPT_SHA384_RESULT_SIZE) unsigned char *md)
+static SCOSSL_STATUS e_scossl_digest_sha384_final(_Inout_ EVP_MD_CTX *ctx, _Out_writes_(SYMCRYPT_SHA384_RESULT_SIZE) unsigned char *md)
 {
     PSYMCRYPT_SHA384_STATE state = (PSYMCRYPT_SHA384_STATE)EVP_MD_CTX_md_data(ctx);
     if( state == NULL )
@@ -419,7 +419,7 @@ static SCOSSL_STATUS scossl_digest_sha384_final(_Inout_ EVP_MD_CTX *ctx, _Out_wr
     return SCOSSL_SUCCESS;
 }
 
-static SCOSSL_STATUS scossl_digest_sha384_copy(_Out_ EVP_MD_CTX *to, _In_ const EVP_MD_CTX *from)
+static SCOSSL_STATUS e_scossl_digest_sha384_copy(_Out_ EVP_MD_CTX *to, _In_ const EVP_MD_CTX *from)
 {
     PSYMCRYPT_SHA384_STATE state_to = (PSYMCRYPT_SHA384_STATE)EVP_MD_CTX_md_data(to);
     PSYMCRYPT_SHA384_STATE state_from = (PSYMCRYPT_SHA384_STATE)EVP_MD_CTX_md_data(from);
@@ -435,7 +435,7 @@ static SCOSSL_STATUS scossl_digest_sha384_copy(_Out_ EVP_MD_CTX *to, _In_ const
 /*
  * SHA512 implementation.
  */
-static SCOSSL_STATUS scossl_digest_sha512_init(_Out_ EVP_MD_CTX *ctx)
+static SCOSSL_STATUS e_scossl_digest_sha512_init(_Out_ EVP_MD_CTX *ctx)
 {
     PSYMCRYPT_SHA512_STATE state = (PSYMCRYPT_SHA512_STATE)EVP_MD_CTX_md_data(ctx);
     if( state == NULL )
@@ -448,7 +448,7 @@ static SCOSSL_STATUS scossl_digest_sha512_init(_Out_ EVP_MD_CTX *ctx)
     return SCOSSL_SUCCESS;
 }
 
-static SCOSSL_STATUS scossl_digest_sha512_update(_Inout_ EVP_MD_CTX *ctx, _In_reads_bytes_(count) const void *data,
+static SCOSSL_STATUS e_scossl_digest_sha512_update(_Inout_ EVP_MD_CTX *ctx, _In_reads_bytes_(count) const void *data,
                                 size_t count)
 {
     PSYMCRYPT_SHA512_STATE state = (PSYMCRYPT_SHA512_STATE)EVP_MD_CTX_md_data(ctx);
@@ -462,7 +462,7 @@ static SCOSSL_STATUS scossl_digest_sha512_update(_Inout_ EVP_MD_CTX *ctx, _In_re
     return SCOSSL_SUCCESS;
 }
 
-static SCOSSL_STATUS scossl_digest_sha512_final(_Inout_ EVP_MD_CTX *ctx, _Out_writes_(SYMCRYPT_SHA512_RESULT_SIZE) unsigned char *md)
+static SCOSSL_STATUS e_scossl_digest_sha512_final(_Inout_ EVP_MD_CTX *ctx, _Out_writes_(SYMCRYPT_SHA512_RESULT_SIZE) unsigned char *md)
 {
     PSYMCRYPT_SHA512_STATE state = (PSYMCRYPT_SHA512_STATE)EVP_MD_CTX_md_data(ctx);
     if( state == NULL )
@@ -475,7 +475,7 @@ static SCOSSL_STATUS scossl_digest_sha512_final(_Inout_ EVP_MD_CTX *ctx, _Out_wr
     return SCOSSL_SUCCESS;
 }
 
-static SCOSSL_STATUS scossl_digest_sha512_copy(_Out_ EVP_MD_CTX *to, _In_ const EVP_MD_CTX *from)
+static SCOSSL_STATUS e_scossl_digest_sha512_copy(_Out_ EVP_MD_CTX *to, _In_ const EVP_MD_CTX *from)
 {
     PSYMCRYPT_SHA512_STATE state_to = (PSYMCRYPT_SHA512_STATE)EVP_MD_CTX_md_data(to);
     PSYMCRYPT_SHA512_STATE state_from = (PSYMCRYPT_SHA512_STATE)EVP_MD_CTX_md_data(from);
diff --git a/SymCryptEngine/src/scossl_digests.h b/SymCryptEngine/src/scossl_digests.h
index 6aa4c47..f8a4253 100644
--- a/SymCryptEngine/src/scossl_digests.h
+++ b/SymCryptEngine/src/scossl_digests.h
@@ -3,7 +3,6 @@
 //
 
 #include "scossl.h"
-#include "scossl_helpers.h"
 #include <openssl/sha.h>
 #include <openssl/md5.h>
 #include <openssl/md4.h>
@@ -14,20 +13,20 @@ extern "C" {
 #endif
 
 // Initialize all of the _hidden_* digests variables
-SCOSSL_STATUS scossl_digests_init_static();
+SCOSSL_STATUS e_scossl_digests_init_static();
 
 /*
  * Returns either the digest for 'nid', or a list of supported 'nids'.
  * If the framework wants the EVP_MD for 'nid', it will call
- * scossl_digests(e, &p_evp_digest, NULL, nid); (return zero for failure)
+ * e_scossl_digests(e, &p_evp_digest, NULL, nid); (return zero for failure)
  * If the framework wants a list of supported 'nid's, it will call
- * scossl_digests(e, NULL, &p_nids, 0); (returns number of 'nids' or -1 for error)
+ * e_scossl_digests(e, NULL, &p_nids, 0); (returns number of 'nids' or -1 for error)
  */
 _Success_(return > 0)
-int scossl_digests(_Inout_ ENGINE *e, _Out_opt_ const EVP_MD **digest,
+int e_scossl_digests(_Inout_ ENGINE *e, _Out_opt_ const EVP_MD **digest,
                      _Out_opt_ const int **nids, int nid);
 
-void scossl_destroy_digests(void);
+void e_scossl_destroy_digests(void);
 
 #ifdef __cplusplus
 }
diff --git a/SymCryptEngine/src/scossl_dsa.c b/SymCryptEngine/src/scossl_dsa.c
index bd4f895..5fcb009 100644
--- a/SymCryptEngine/src/scossl_dsa.c
+++ b/SymCryptEngine/src/scossl_dsa.c
@@ -15,7 +15,7 @@ typedef int (*PFN_DSA_meth_init)(DSA* dsa);
 typedef int (*PFN_DSA_meth_finish)(DSA* dsa);
 
 _Success_(return != NULL)
-DSA_SIG* scossl_dsa_sign(_In_reads_bytes_(dlen) const unsigned char* dgst, int dlen, _In_ DSA* dsa)
+DSA_SIG* e_scossl_dsa_sign(_In_reads_bytes_(dlen) const unsigned char* dgst, int dlen, _In_ DSA* dsa)
 {
     const DSA_METHOD* ossl_dsa_meth = DSA_OpenSSL();
     PFN_DSA_meth_sign pfn_dsa_sign = DSA_meth_get_sign(ossl_dsa_meth);
@@ -26,7 +26,7 @@ DSA_SIG* scossl_dsa_sign(_In_reads_bytes_(dlen) const unsigned char* dgst, int d
     return pfn_dsa_sign(dgst, dlen, dsa);
 }
 
-SCOSSL_STATUS scossl_dsa_sign_setup(_In_ DSA* dsa, _In_ BN_CTX* ctx_in,
+SCOSSL_STATUS e_scossl_dsa_sign_setup(_In_ DSA* dsa, _In_ BN_CTX* ctx_in,
     _Out_ BIGNUM** kinvp, _Out_ BIGNUM** rp)
 {
     const DSA_METHOD* ossl_dsa_meth = DSA_OpenSSL();
@@ -38,7 +38,7 @@ SCOSSL_STATUS scossl_dsa_sign_setup(_In_ DSA* dsa, _In_ BN_CTX* ctx_in,
     return pfn_dsa_sign_setup(dsa, ctx_in, kinvp, rp);
 }
 
-SCOSSL_STATUS scossl_dsa_verify(_In_reads_bytes_(dgst_len) const unsigned char* dgst, int dgst_len,
+SCOSSL_STATUS e_scossl_dsa_verify(_In_reads_bytes_(dgst_len) const unsigned char* dgst, int dgst_len,
     _In_ DSA_SIG* sig, _In_ DSA* dsa)
 {
     const DSA_METHOD* ossl_dsa_meth = DSA_OpenSSL();
@@ -50,7 +50,7 @@ SCOSSL_STATUS scossl_dsa_verify(_In_reads_bytes_(dgst_len) const unsigned char*
     return pfn_dsa_verify(dgst, dgst_len, sig, dsa);
 }
 
-SCOSSL_STATUS scossl_dsa_init(_Inout_ DSA* dsa)
+SCOSSL_STATUS e_scossl_dsa_init(_Inout_ DSA* dsa)
 {
     const DSA_METHOD* ossl_dsa_meth = DSA_OpenSSL();
     PFN_DSA_meth_init pfn_dsa_init = DSA_meth_get_init(ossl_dsa_meth);
@@ -61,7 +61,7 @@ SCOSSL_STATUS scossl_dsa_init(_Inout_ DSA* dsa)
     return pfn_dsa_init(dsa);
 }
 
-SCOSSL_STATUS scossl_dsa_finish(_Inout_ DSA* dsa)
+SCOSSL_STATUS e_scossl_dsa_finish(_Inout_ DSA* dsa)
 {
     const DSA_METHOD* ossl_dsa_meth = DSA_OpenSSL();
     PFN_DSA_meth_finish pfn_dsa_finish = DSA_meth_get_finish(ossl_dsa_meth);
diff --git a/SymCryptEngine/src/scossl_dsa.h b/SymCryptEngine/src/scossl_dsa.h
index 97badbd..13fbabe 100644
--- a/SymCryptEngine/src/scossl_dsa.h
+++ b/SymCryptEngine/src/scossl_dsa.h
@@ -3,7 +3,6 @@
 //
 
 #include "scossl.h"
-#include "scossl_helpers.h"
 #include <openssl/dsa.h>
 
 #ifdef __cplusplus
@@ -15,24 +14,24 @@ extern "C" {
 // and returns it in a newly allocated DSA_SIG structure.
 // Returns the signature on success, or NULL on error.
 _Success_(return != NULL)
-DSA_SIG* scossl_dsa_sign(_In_reads_bytes_(dlen) const unsigned char* dgst, int dlen, _In_ DSA* dsa);
+DSA_SIG* e_scossl_dsa_sign(_In_reads_bytes_(dlen) const unsigned char* dgst, int dlen, _In_ DSA* dsa);
 
 // Precalculates the DSA signature values k^-1 and r.
 // Returns 1 on success, or 0 on error.
-SCOSSL_STATUS scossl_dsa_sign_setup(_In_ DSA* dsa, _In_ BN_CTX* ctx_in, _Out_ BIGNUM** kinvp, _Out_ BIGNUM** rp);
+SCOSSL_STATUS e_scossl_dsa_sign_setup(_In_ DSA* dsa, _In_ BN_CTX* ctx_in, _Out_ BIGNUM** kinvp, _Out_ BIGNUM** rp);
 
 // Verifies that the signature sig matches a given message digest dgst of size dgst_len.
 // dsa is the signer's public key.
 // Returns 1 for a valid signature, 0 for an incorrect signature, and -1 on error.
-SCOSSL_STATUS scossl_dsa_verify(_In_reads_bytes_(dgst_len) const unsigned char* dgst, int dgst_len, _In_ DSA_SIG* sig, _In_ DSA* dsa);
+SCOSSL_STATUS e_scossl_dsa_verify(_In_reads_bytes_(dgst_len) const unsigned char* dgst, int dgst_len, _In_ DSA_SIG* sig, _In_ DSA* dsa);
 
 // Initializes a new DSA instance.
 // Returns 1 on success, or 0 on error
-SCOSSL_STATUS scossl_dsa_init(_Inout_ DSA* dsa);
+SCOSSL_STATUS e_scossl_dsa_init(_Inout_ DSA* dsa);
 
 // Destroys instance of DSA object. The memory for dsa is not freed by this function.
 // Returns 1 on success, or 0 on error
-SCOSSL_STATUS scossl_dsa_finish(_Inout_ DSA* dsa);
+SCOSSL_STATUS e_scossl_dsa_finish(_Inout_ DSA* dsa);
 
 #ifdef __cplusplus
 }
diff --git a/SymCryptEngine/src/scossl_ecc.c b/SymCryptEngine/src/scossl_ecc.c
index c9ea6b1..c29ce94 100644
--- a/SymCryptEngine/src/scossl_ecc.c
+++ b/SymCryptEngine/src/scossl_ecc.c
@@ -37,7 +37,7 @@ typedef struct _SCOSSL_ECC_KEY_CONTEXT {
     PSYMCRYPT_ECKEY key;
 } SCOSSL_ECC_KEY_CONTEXT;
 
-int scossl_eckey_idx = -1;
+int e_scossl_eckey_idx = -1;
 
 
 // If r and s are both 0, the DER encoding would be 8 bytes
@@ -55,7 +55,7 @@ int scossl_eckey_idx = -1;
 // Largest supported curve is P521 => 66 * 2 byte Public key
 #define SCOSSL_ECDH_MAX_PUBLIC_KEY_LEN (132)
 
-static SCOSSL_STATUS scossl_ecdsa_der_check_tag_and_get_value_and_length(
+static SCOSSL_STATUS e_scossl_ecdsa_der_check_tag_and_get_value_and_length(
     _In_reads_bytes_(cbDerField) PCBYTE pbDerField, SIZE_T cbDerField, BYTE expectedTag, _Out_writes_bytes_(pcbContent) PCBYTE* ppbContent, SIZE_T* pcbContent )
 {
     PCBYTE pbContent = NULL;
@@ -118,7 +118,7 @@ cleanup:
 // Quick hack function to parse precisely the DER encodings which we expect for ECDSA signatures for the NIST prime curves
 // Extracts the encoded R and S and places them in a buffer with 2 same-sized big-endian encodings (BER encoding expected by SymCrypt)
 // Returns SCOSSL_SUCCESS on success, or SCOSSL_FAILURE on failure.
-static SCOSSL_STATUS scossl_ecdsa_remove_der(_In_reads_bytes_(cbDerSignature) PCBYTE pbDerSignature, SIZE_T cbDerSignature,
+static SCOSSL_STATUS e_scossl_ecdsa_remove_der(_In_reads_bytes_(cbDerSignature) PCBYTE pbDerSignature, SIZE_T cbDerSignature,
                                                 _Out_writes_bytes_(cbSymCryptSignature) PBYTE pbSymCryptSignature, SIZE_T cbSymCryptSignature)
 {
     PCBYTE pbSeq = NULL;
@@ -145,7 +145,7 @@ static SCOSSL_STATUS scossl_ecdsa_remove_der(_In_reads_bytes_(cbDerSignature) PC
     }
 
 
-    if( scossl_ecdsa_der_check_tag_and_get_value_and_length(
+    if( e_scossl_ecdsa_der_check_tag_and_get_value_and_length(
             pbDerSignature, cbDerSignature, 0x30, &pbSeq, &cbSeq) == 0 )
     {
         goto cleanup;
@@ -160,7 +160,7 @@ static SCOSSL_STATUS scossl_ecdsa_remove_der(_In_reads_bytes_(cbDerSignature) PC
         goto cleanup;
     }
 
-    if( scossl_ecdsa_der_check_tag_and_get_value_and_length(
+    if( e_scossl_ecdsa_der_check_tag_and_get_value_and_length(
             pbSeq, cbSeq, 0x02, &pbR, &cbR) == 0 )
     {
         goto cleanup;
@@ -175,7 +175,7 @@ static SCOSSL_STATUS scossl_ecdsa_remove_der(_In_reads_bytes_(cbDerSignature) PC
         goto cleanup;
     }
 
-    if( scossl_ecdsa_der_check_tag_and_get_value_and_length(
+    if( e_scossl_ecdsa_der_check_tag_and_get_value_and_length(
             pbR+cbR, (pbSeq+cbSeq)-(pbR+cbR), 0x02, &pbS, &cbS) == 0 )
     {
         goto cleanup;
@@ -234,7 +234,7 @@ cleanup:
 // Quick hack function to generate precisely the DER encodings which we want for ECDSA signatures for the NIST prime curves
 // Takes 2 same-size big-endian integers output from SymCrypt and encodes them in the minimally sized (strict) equivalent DER encoding
 // Returns SCOSSL_SUCCESS on success, or SCOSSL_FAILURE on failure.
-static SCOSSL_STATUS scossl_ecdsa_apply_der(_In_reads_bytes_(cbSymCryptSignature) PCBYTE pbSymCryptSignature, SIZE_T cbSymCryptSignature,
+static SCOSSL_STATUS e_scossl_ecdsa_apply_der(_In_reads_bytes_(cbSymCryptSignature) PCBYTE pbSymCryptSignature, SIZE_T cbSymCryptSignature,
                                                 _Out_writes_bytes_(cbDerSignature) PBYTE pbDerSignature, unsigned int* cbDerSignature)
 {
     PBYTE  pbWrite = pbDerSignature;
@@ -333,7 +333,7 @@ cleanup:
     return res;
 }
 
-void scossl_ecc_free_key_context(_Inout_ SCOSSL_ECC_KEY_CONTEXT *keyCtx)
+void e_scossl_ecc_free_key_context(_Inout_ SCOSSL_ECC_KEY_CONTEXT *keyCtx)
 {
     keyCtx->initialized = 0;
     if( keyCtx->key )
@@ -346,17 +346,17 @@ void scossl_ecc_free_key_context(_Inout_ SCOSSL_ECC_KEY_CONTEXT *keyCtx)
 #define NID_secp192r1 (NID_X9_62_prime192v1)
 #define NID_secp256r1 (NID_X9_62_prime256v1)
 
-void scossl_eckey_finish(_Inout_ EC_KEY *key)
+void e_scossl_eckey_finish(_Inout_ EC_KEY *key)
 {
-    SCOSSL_ECC_KEY_CONTEXT *keyCtx = EC_KEY_get_ex_data(key, scossl_eckey_idx);
+    SCOSSL_ECC_KEY_CONTEXT *keyCtx = EC_KEY_get_ex_data(key, e_scossl_eckey_idx);
     if( keyCtx )
     {
         if( keyCtx->initialized == 1 )
         {
-            scossl_ecc_free_key_context(keyCtx);
+            e_scossl_ecc_free_key_context(keyCtx);
         }
         OPENSSL_free(keyCtx);
-        EC_KEY_set_ex_data(key, scossl_eckey_idx, NULL);
+        EC_KEY_set_ex_data(key, e_scossl_eckey_idx, NULL);
     }
 }
 
@@ -368,7 +368,7 @@ static PSYMCRYPT_ECURVE _hidden_curve_P521 = NULL;
 
 // Generates a new keypair using pCurve, storing the new keypair in eckey and pKeyCtx.
 // Returns SCOSSL_SUCCESS on success or SCOSSL_FAILURE on error.
-SCOSSL_STATUS scossl_ecc_generate_keypair(_Inout_ SCOSSL_ECC_KEY_CONTEXT* pKeyCtx, _In_ PCSYMCRYPT_ECURVE pCurve,
+SCOSSL_STATUS e_scossl_ecc_generate_keypair(_Inout_ SCOSSL_ECC_KEY_CONTEXT* pKeyCtx, _In_ PCSYMCRYPT_ECURVE pCurve,
                                         _In_ const EC_GROUP* ecgroup, _Inout_ EC_KEY* eckey)
 {
     SYMCRYPT_ERROR scError = SYMCRYPT_NO_ERROR;
@@ -493,7 +493,7 @@ cleanup:
     if( res != SCOSSL_SUCCESS )
     {
         // On error free the partially constructed key context
-        scossl_ecc_free_key_context(pKeyCtx);
+        e_scossl_ecc_free_key_context(pKeyCtx);
     }
 
     if( pbData )
@@ -513,7 +513,7 @@ cleanup:
 
 // Imports key using eckey, ecgroup, and pCurve into pKeyCtx.
 // Returns SCOSSL_SUCCESS on success or SCOSSL_FAILURE on error.
-SCOSSL_STATUS scossl_ecc_import_keypair(_In_ const EC_KEY* eckey, _In_ const EC_GROUP* ecgroup,
+SCOSSL_STATUS e_scossl_ecc_import_keypair(_In_ const EC_KEY* eckey, _In_ const EC_GROUP* ecgroup,
                                         _Inout_ SCOSSL_ECC_KEY_CONTEXT* pKeyCtx, _In_ PCSYMCRYPT_ECURVE pCurve)
 {
     SYMCRYPT_ERROR scError = SYMCRYPT_NO_ERROR;
@@ -631,7 +631,7 @@ cleanup:
     if( res != SCOSSL_SUCCESS )
     {
         // On error free the partially constructed key context
-        scossl_ecc_free_key_context(pKeyCtx);
+        e_scossl_ecc_free_key_context(pKeyCtx);
     }
 
     if( pbData )
@@ -647,7 +647,7 @@ cleanup:
     return res;
 }
 
-SCOSSL_STATUS scossl_ecc_init_static()
+SCOSSL_STATUS e_scossl_ecc_init_static()
 {
     if( ((_hidden_curve_P192 = SymCryptEcurveAllocate(SymCryptEcurveParamsNistP192, 0)) == NULL) ||
         ((_hidden_curve_P224 = SymCryptEcurveAllocate(SymCryptEcurveParamsNistP224, 0)) == NULL) ||
@@ -663,7 +663,7 @@ SCOSSL_STATUS scossl_ecc_init_static()
 // returns SCOSSL_FALLBACK when the eckey is not supported by the engine, so we should fallback to OpenSSL
 // returns SCOSSL_FAILURE on an error
 // returns SCOSSL_SUCCESS and sets pKeyCtx to a pointer to an initialized SCOSSL_ECC_KEY_CONTEXT on success
-SCOSSL_STATUS scossl_get_ecc_context_ex(_Inout_ EC_KEY* eckey, _Out_ SCOSSL_ECC_KEY_CONTEXT** ppKeyCtx, BOOL generate)
+SCOSSL_STATUS e_scossl_get_ecc_context_ex(_Inout_ EC_KEY* eckey, _Out_ SCOSSL_ECC_KEY_CONTEXT** ppKeyCtx, BOOL generate)
 {
     PCSYMCRYPT_ECURVE pCurve = NULL;
 
@@ -702,7 +702,7 @@ SCOSSL_STATUS scossl_get_ecc_context_ex(_Inout_ EC_KEY* eckey, _Out_ SCOSSL_ECC_
         return SCOSSL_FAILURE;
     }
 
-    *ppKeyCtx = (SCOSSL_ECC_KEY_CONTEXT*) EC_KEY_get_ex_data(eckey, scossl_eckey_idx);
+    *ppKeyCtx = (SCOSSL_ECC_KEY_CONTEXT*) EC_KEY_get_ex_data(eckey, e_scossl_eckey_idx);
 
     if( *ppKeyCtx == NULL )
     {
@@ -714,7 +714,7 @@ SCOSSL_STATUS scossl_get_ecc_context_ex(_Inout_ EC_KEY* eckey, _Out_ SCOSSL_ECC_
             return SCOSSL_FAILURE;
         }
 
-        if( EC_KEY_set_ex_data(eckey, scossl_eckey_idx, keyCtx) == 0)
+        if( EC_KEY_set_ex_data(eckey, e_scossl_eckey_idx, keyCtx) == 0)
         {
             SCOSSL_LOG_ERROR(SCOSSL_ERR_F_GET_ECC_CONTEXT_EX, ERR_R_OPERATION_FAIL,
                 "EC_KEY_set_ex_data failed");
@@ -728,7 +728,7 @@ SCOSSL_STATUS scossl_get_ecc_context_ex(_Inout_ EC_KEY* eckey, _Out_ SCOSSL_ECC_
     // If we are asked to generate a key - make sure to free any existing key
     if( generate )
     {
-        scossl_ecc_free_key_context(*ppKeyCtx);
+        e_scossl_ecc_free_key_context(*ppKeyCtx);
     }
 
     if( (*ppKeyCtx)->initialized == 1 )
@@ -738,23 +738,23 @@ SCOSSL_STATUS scossl_get_ecc_context_ex(_Inout_ EC_KEY* eckey, _Out_ SCOSSL_ECC_
 
     if( generate )
     {
-        return scossl_ecc_generate_keypair(*ppKeyCtx, pCurve, ecgroup, eckey);
+        return e_scossl_ecc_generate_keypair(*ppKeyCtx, pCurve, ecgroup, eckey);
     }
     else
     {
-        return scossl_ecc_import_keypair(eckey, ecgroup, *ppKeyCtx, pCurve);
+        return e_scossl_ecc_import_keypair(eckey, ecgroup, *ppKeyCtx, pCurve);
     }
 }
 
 // returns SCOSSL_FALLBACK when the eckey is not supported by the engine, so we should fallback to OpenSSL
 // returns SCOSSL_FAILURE on an error
 // returns SCOSSL_SUCCESS and sets pKeyCtx to a pointer to an initialized SCOSSL_ECC_KEY_CONTEXT on success
-SCOSSL_STATUS scossl_get_ecc_context(_Inout_ EC_KEY* eckey, _Out_ SCOSSL_ECC_KEY_CONTEXT** ppKeyCtx)
+SCOSSL_STATUS e_scossl_get_ecc_context(_Inout_ EC_KEY* eckey, _Out_ SCOSSL_ECC_KEY_CONTEXT** ppKeyCtx)
 {
-    return scossl_get_ecc_context_ex(eckey, ppKeyCtx, FALSE);
+    return e_scossl_get_ecc_context_ex(eckey, ppKeyCtx, FALSE);
 }
 
-SCOSSL_STATUS scossl_eckey_sign(int type,
+SCOSSL_STATUS e_scossl_eckey_sign(int type,
                         _In_reads_bytes_(dlen) const unsigned char* dgst,
                         int dlen,
                         _Out_writes_bytes_(*siglen) unsigned char* sig,
@@ -769,11 +769,11 @@ SCOSSL_STATUS scossl_eckey_sign(int type,
     BYTE buf[SCOSSL_ECDSA_MAX_SYMCRYPT_SIGNATURE_LEN] = { 0 };
     SIZE_T cbSymCryptSig = 0;
 
-    switch( scossl_get_ecc_context(eckey, &keyCtx) )
+    switch( e_scossl_get_ecc_context(eckey, &keyCtx) )
     {
     case SCOSSL_FAILURE:
         SCOSSL_LOG_ERROR(SCOSSL_ERR_F_ECKEY_SIGN, ERR_R_OPERATION_FAIL,
-            "scossl_get_ecc_context failed.");
+            "e_scossl_get_ecc_context failed.");
         return SCOSSL_FAILURE;
     case SCOSSL_FALLBACK:
         ossl_eckey_method = EC_KEY_OpenSSL();
@@ -788,7 +788,7 @@ SCOSSL_STATUS scossl_eckey_sign(int type,
         break;
     default:
         SCOSSL_LOG_ERROR(SCOSSL_ERR_F_ECKEY_SIGN, ERR_R_INTERNAL_ERROR,
-            "Unexpected scossl_get_ecc_context value");
+            "Unexpected e_scossl_get_ecc_context value");
         return SCOSSL_FAILURE;
     }
 
@@ -831,27 +831,27 @@ SCOSSL_STATUS scossl_eckey_sign(int type,
         return SCOSSL_FAILURE;
     }
 
-    if( scossl_ecdsa_apply_der(buf, cbSymCryptSig, sig, siglen) == 0 )
+    if( e_scossl_ecdsa_apply_der(buf, cbSymCryptSig, sig, siglen) == 0 )
     {
         SCOSSL_LOG_ERROR(SCOSSL_ERR_F_ECKEY_SIGN, ERR_R_OPERATION_FAIL,
-            "scossl_ecdsa_apply_der failed");
+            "e_scossl_ecdsa_apply_der failed");
         return SCOSSL_FAILURE;
     }
 
     return SCOSSL_SUCCESS;
 }
 
-SCOSSL_STATUS scossl_eckey_sign_setup(_In_ EC_KEY* eckey, _In_ BN_CTX* ctx_in, _Out_ BIGNUM** kinvp, _Out_ BIGNUM** rp)
+SCOSSL_STATUS e_scossl_eckey_sign_setup(_In_ EC_KEY* eckey, _In_ BN_CTX* ctx_in, _Out_ BIGNUM** kinvp, _Out_ BIGNUM** rp)
 {
     SCOSSL_ECC_KEY_CONTEXT *keyCtx = NULL;
     const EC_KEY_METHOD* ossl_eckey_method = EC_KEY_OpenSSL();
     PFN_eckey_sign_setup pfn_eckey_sign_setup = NULL;
 
-    switch( scossl_get_ecc_context(eckey, &keyCtx) )
+    switch( e_scossl_get_ecc_context(eckey, &keyCtx) )
     {
     case SCOSSL_FAILURE:
         SCOSSL_LOG_ERROR(SCOSSL_ERR_F_ECKEY_SIGN_SETUP, ERR_R_OPERATION_FAIL,
-            "scossl_get_ecc_context failed.");
+            "e_scossl_get_ecc_context failed.");
         return SCOSSL_FAILURE;
     case SCOSSL_FALLBACK:
     case SCOSSL_SUCCESS:
@@ -865,12 +865,12 @@ SCOSSL_STATUS scossl_eckey_sign_setup(_In_ EC_KEY* eckey, _In_ BN_CTX* ctx_in, _
         return pfn_eckey_sign_setup(eckey, ctx_in, kinvp, rp);
     default:
         SCOSSL_LOG_ERROR(SCOSSL_ERR_F_ECKEY_SIGN_SETUP, ERR_R_INTERNAL_ERROR,
-            "Unexpected scossl_get_ecc_context value");
+            "Unexpected e_scossl_get_ecc_context value");
         return SCOSSL_FAILURE;
     }
 }
 
-ECDSA_SIG* scossl_eckey_sign_sig(_In_reads_bytes_(dgstlen) const unsigned char* dgst, int dgst_len,
+ECDSA_SIG* e_scossl_eckey_sign_sig(_In_reads_bytes_(dgstlen) const unsigned char* dgst, int dgst_len,
                                    _In_opt_ const BIGNUM* in_kinv, _In_opt_ const BIGNUM* in_r,
                                    _In_ EC_KEY* eckey)
 {
@@ -883,11 +883,11 @@ ECDSA_SIG* scossl_eckey_sign_sig(_In_reads_bytes_(dgstlen) const unsigned char*
     BYTE buf[SCOSSL_ECDSA_MAX_SYMCRYPT_SIGNATURE_LEN] = { 0 };
     SIZE_T cbSymCryptSig = 0;
 
-    switch( scossl_get_ecc_context(eckey, &keyCtx) )
+    switch( e_scossl_get_ecc_context(eckey, &keyCtx) )
     {
     case SCOSSL_FAILURE:
         SCOSSL_LOG_ERROR(SCOSSL_ERR_F_ECKEY_SIGN_SIG, ERR_R_OPERATION_FAIL,
-            "scossl_get_ecc_context failed.");
+            "e_scossl_get_ecc_context failed.");
         return NULL;
     case SCOSSL_FALLBACK:
         ossl_eckey_method = EC_KEY_OpenSSL();
@@ -902,7 +902,7 @@ ECDSA_SIG* scossl_eckey_sign_sig(_In_reads_bytes_(dgstlen) const unsigned char*
         break;
     default:
         SCOSSL_LOG_ERROR(SCOSSL_ERR_F_ECKEY_SIGN_SIG, ERR_R_INTERNAL_ERROR,
-            "Unexpected scossl_get_ecc_context value");
+            "Unexpected e_scossl_get_ecc_context value");
         return NULL;
     }
 
@@ -975,7 +975,7 @@ ECDSA_SIG* scossl_eckey_sign_sig(_In_reads_bytes_(dgstlen) const unsigned char*
     return returnSignature;
 }
 
-SCOSSL_STATUS scossl_eckey_verify(int type, _In_reads_bytes_(dgst_len) const unsigned char* dgst, int dgst_len,
+SCOSSL_STATUS e_scossl_eckey_verify(int type, _In_reads_bytes_(dgst_len) const unsigned char* dgst, int dgst_len,
                           _In_reads_bytes_(sig_len) const unsigned char* sigbuf, int sig_len, _In_ EC_KEY* eckey)
 {
     const EC_KEY_METHOD* ossl_eckey_method = NULL;
@@ -984,11 +984,11 @@ SCOSSL_STATUS scossl_eckey_verify(int type, _In_reads_bytes_(dgst_len) const uns
     BYTE buf[SCOSSL_ECDSA_MAX_SYMCRYPT_SIGNATURE_LEN] = { 0 };
     SIZE_T cbSymCryptSig = 0;
 
-    switch( scossl_get_ecc_context(eckey, &keyCtx) )
+    switch( e_scossl_get_ecc_context(eckey, &keyCtx) )
     {
     case SCOSSL_FAILURE:
         SCOSSL_LOG_ERROR(SCOSSL_ERR_F_ECKEY_VERIFY, ERR_R_OPERATION_FAIL,
-            "scossl_get_ecc_context failed.");
+            "e_scossl_get_ecc_context failed.");
         return SCOSSL_FAILURE;
     case SCOSSL_FALLBACK:
         ossl_eckey_method = EC_KEY_OpenSSL();
@@ -1003,15 +1003,15 @@ SCOSSL_STATUS scossl_eckey_verify(int type, _In_reads_bytes_(dgst_len) const uns
         break;
     default:
         SCOSSL_LOG_ERROR(SCOSSL_ERR_F_ECKEY_VERIFY, ERR_R_INTERNAL_ERROR,
-            "Unexpected scossl_get_ecc_context value");
+            "Unexpected e_scossl_get_ecc_context value");
         return SCOSSL_FAILURE;
     }
 
     cbSymCryptSig = 2*SymCryptEcurveSizeofFieldElement( keyCtx->key->pCurve );
-    if( scossl_ecdsa_remove_der(sigbuf, sig_len, &buf[0], cbSymCryptSig) == 0 )
+    if( e_scossl_ecdsa_remove_der(sigbuf, sig_len, &buf[0], cbSymCryptSig) == 0 )
     {
         SCOSSL_LOG_ERROR(SCOSSL_ERR_F_ECKEY_VERIFY, ERR_R_OPERATION_FAIL,
-            "scossl_ecdsa_remove_der failed");
+            "e_scossl_ecdsa_remove_der failed");
         return SCOSSL_FAILURE;
     }
 
@@ -1036,7 +1036,7 @@ SCOSSL_STATUS scossl_eckey_verify(int type, _In_reads_bytes_(dgst_len) const uns
     return SCOSSL_SUCCESS;
 }
 
-SCOSSL_STATUS scossl_eckey_verify_sig(_In_reads_bytes_(dgst_len) const unsigned char* dgst, int dgst_len,
+SCOSSL_STATUS e_scossl_eckey_verify_sig(_In_reads_bytes_(dgst_len) const unsigned char* dgst, int dgst_len,
                               _In_ const ECDSA_SIG* sig, _In_ EC_KEY* eckey)
 {
     const EC_KEY_METHOD* ossl_eckey_method = NULL;
@@ -1048,11 +1048,11 @@ SCOSSL_STATUS scossl_eckey_verify_sig(_In_reads_bytes_(dgst_len) const unsigned
     const BIGNUM* r = NULL;
     const BIGNUM* s = NULL;
 
-    switch( scossl_get_ecc_context(eckey, &keyCtx) )
+    switch( e_scossl_get_ecc_context(eckey, &keyCtx) )
     {
     case SCOSSL_FAILURE:
         SCOSSL_LOG_ERROR(SCOSSL_ERR_F_ECKEY_VERIFY_SIG, ERR_R_OPERATION_FAIL,
-            "scossl_get_ecc_context failed.");
+            "e_scossl_get_ecc_context failed.");
         return SCOSSL_FAILURE;
     case SCOSSL_FALLBACK:
         ossl_eckey_method = EC_KEY_OpenSSL();
@@ -1067,7 +1067,7 @@ SCOSSL_STATUS scossl_eckey_verify_sig(_In_reads_bytes_(dgst_len) const unsigned
         break;
     default:
         SCOSSL_LOG_ERROR(SCOSSL_ERR_F_ECKEY_VERIFY_SIG, ERR_R_INTERNAL_ERROR,
-            "Unexpected scossl_get_ecc_context value");
+            "Unexpected e_scossl_get_ecc_context value");
         return SCOSSL_FAILURE;
     }
 
@@ -1098,16 +1098,16 @@ SCOSSL_STATUS scossl_eckey_verify_sig(_In_reads_bytes_(dgst_len) const unsigned
     return SCOSSL_SUCCESS;
 }
 
-SCOSSL_STATUS scossl_eckey_keygen(_Inout_ EC_KEY *key)
+SCOSSL_STATUS e_scossl_eckey_keygen(_Inout_ EC_KEY *key)
 {
     const EC_KEY_METHOD* ossl_eckey_method = NULL;
     SCOSSL_ECC_KEY_CONTEXT *keyCtx = NULL;
 
-    switch( scossl_get_ecc_context_ex(key, &keyCtx, TRUE) )
+    switch( e_scossl_get_ecc_context_ex(key, &keyCtx, TRUE) )
     {
     case SCOSSL_FAILURE:
         SCOSSL_LOG_ERROR(SCOSSL_ERR_F_ECKEY_KEYGEN, ERR_R_OPERATION_FAIL,
-            "scossl_get_ecc_context_ex failed.");
+            "e_scossl_get_ecc_context_ex failed.");
         return SCOSSL_FAILURE;
     case SCOSSL_FALLBACK:
         ossl_eckey_method = EC_KEY_OpenSSL();
@@ -1122,12 +1122,12 @@ SCOSSL_STATUS scossl_eckey_keygen(_Inout_ EC_KEY *key)
         return SCOSSL_SUCCESS;
     default:
         SCOSSL_LOG_ERROR(SCOSSL_ERR_F_ECKEY_KEYGEN, ERR_R_INTERNAL_ERROR,
-            "Unexpected scossl_get_ecc_context_ex value");
+            "Unexpected e_scossl_get_ecc_context_ex value");
         return SCOSSL_FAILURE;
     }
 }
 
-SCOSSL_RETURNLENGTH scossl_eckey_compute_key(_Out_writes_bytes_(*pseclen) unsigned char **psec,
+SCOSSL_RETURNLENGTH e_scossl_eckey_compute_key(_Out_writes_bytes_(*pseclen) unsigned char **psec,
                                                 _Out_ size_t *pseclen,
                                                 _In_ const EC_POINT *pub_key,
                                                 _In_ const EC_KEY *ecdh)
@@ -1146,11 +1146,11 @@ SCOSSL_RETURNLENGTH scossl_eckey_compute_key(_Out_writes_bytes_(*pseclen) unsign
 
     int res = -1; // fail
 
-    switch( scossl_get_ecc_context((EC_KEY*)ecdh, &keyCtx) ) // removing const cast as code path in this instance will not alter ecdh. TODO: refactor scossl_get_ecc_context
+    switch( e_scossl_get_ecc_context((EC_KEY*)ecdh, &keyCtx) ) // removing const cast as code path in this instance will not alter ecdh. TODO: refactor e_scossl_get_ecc_context
     {
     case SCOSSL_FAILURE:
         SCOSSL_LOG_ERROR(SCOSSL_ERR_F_ECKEY_COMPUTE_KEY, ERR_R_OPERATION_FAIL,
-            "scossl_get_ecc_context failed.");
+            "e_scossl_get_ecc_context failed.");
         return -1;
     case SCOSSL_FALLBACK:
         ossl_eckey_method = EC_KEY_OpenSSL();
@@ -1165,7 +1165,7 @@ SCOSSL_RETURNLENGTH scossl_eckey_compute_key(_Out_writes_bytes_(*pseclen) unsign
         break;
     default:
         SCOSSL_LOG_ERROR(SCOSSL_ERR_F_ECKEY_COMPUTE_KEY, ERR_R_INTERNAL_ERROR,
-            "Unexpected scossl_get_ecc_context value");
+            "Unexpected e_scossl_get_ecc_context value");
         return -1;
     }
 
@@ -1280,7 +1280,7 @@ cleanup:
     return res;
 }
 
-void scossl_destroy_ecc_curves(void)
+void e_scossl_destroy_ecc_curves(void)
 {
     if( _hidden_curve_P192 )
     {
diff --git a/SymCryptEngine/src/scossl_ecc.h b/SymCryptEngine/src/scossl_ecc.h
index 1382dc6..ba5fee0 100644
--- a/SymCryptEngine/src/scossl_ecc.h
+++ b/SymCryptEngine/src/scossl_ecc.h
@@ -3,14 +3,13 @@
 //
 
 #include "scossl.h"
-#include "scossl_helpers.h"
 #include <openssl/ec.h>
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-extern int scossl_eckey_idx;
+extern int e_scossl_eckey_idx;
 
 typedef int (*PFN_eckey_copy)(EC_KEY *dest, const EC_KEY *src);
 typedef int (*PFN_eckey_set_group)(EC_KEY *key, const EC_GROUP *grp);
@@ -18,20 +17,20 @@ typedef int (*PFN_eckey_set_private)(EC_KEY *key, const BIGNUM *priv_key);
 typedef int (*PFN_eckey_set_public)(EC_KEY *key, const EC_POINT *pub_key);
 
 // Initialize all of the _hidden_* ecc variables
-SCOSSL_STATUS scossl_ecc_init_static();
+SCOSSL_STATUS e_scossl_ecc_init_static();
 
 // Frees SymCrypt-specific components of key
-void scossl_eckey_finish(_Inout_ EC_KEY *key);
+void e_scossl_eckey_finish(_Inout_ EC_KEY *key);
 
 // Generates a new public and private key for the supplied key object.
 // key must have an EC_GROUP object associated with it before calling this function.
 // Returns 1 on success or 0 on error.
-SCOSSL_STATUS scossl_eckey_keygen(_Inout_ EC_KEY *key);
+SCOSSL_STATUS e_scossl_eckey_keygen(_Inout_ EC_KEY *key);
 
 // Computes shared secret psec and secret length pseclen using pub_key and ecdh.
 // Allocates psec on success.
 // Returns length of secret on success, or -1 on error.
-SCOSSL_RETURNLENGTH scossl_eckey_compute_key(_Out_writes_bytes_(*pseclen) unsigned char **psec,
+SCOSSL_RETURNLENGTH e_scossl_eckey_compute_key(_Out_writes_bytes_(*pseclen) unsigned char **psec,
                                                 _Out_ size_t *pseclen,
                                                 _In_ const EC_POINT *pub_key,
                                                 _In_ const EC_KEY *ecdh);
@@ -40,7 +39,7 @@ SCOSSL_RETURNLENGTH scossl_eckey_compute_key(_Out_writes_bytes_(*pseclen) unsign
 // and the optional pre-computed values kinv and r. The DER encoded signature is stored in sig and its length
 // is returned in siglen. (sig must point to ECDSA_size(eckey) bytes of memory). The parameter type is ignored.
 // Returns 1 on success or 0 on error.
-SCOSSL_STATUS scossl_eckey_sign(int type,
+SCOSSL_STATUS e_scossl_eckey_sign(int type,
                         _In_reads_bytes_(dlen) const unsigned char* dgst,
                         int dlen,
                         _Out_writes_bytes_(*siglen) unsigned char* sig,
@@ -53,29 +52,29 @@ SCOSSL_STATUS scossl_eckey_sign(int type,
 // structure (or NULL). The precomputed values are returned in kinv and rp and can be used in a later call
 // to ECDSA_sign_ex or ECDSA_do_sign_ex.
 // Returns 1 on success or 0 on error.
-SCOSSL_STATUS scossl_eckey_sign_setup(_In_ EC_KEY* eckey, _In_ BN_CTX* ctx_in, _Out_ BIGNUM** kinvp, _Out_ BIGNUM** rp);
+SCOSSL_STATUS e_scossl_eckey_sign_setup(_In_ EC_KEY* eckey, _In_ BN_CTX* ctx_in, _Out_ BIGNUM** kinvp, _Out_ BIGNUM** rp);
 
 // Computes a digital signature of the dgst_len bytes hash value dgst using the private EC key eckey
 // and the optional pre-computed values in_kinv and in_r.
 // Returns the signature in a newly allocated ECDSA_SIG structure, or NULL on error.
-ECDSA_SIG* scossl_eckey_sign_sig(_In_reads_bytes_(dgstlen) const unsigned char* dgst, int dgst_len,
+ECDSA_SIG* e_scossl_eckey_sign_sig(_In_reads_bytes_(dgstlen) const unsigned char* dgst, int dgst_len,
                                    _In_opt_ const BIGNUM* in_kinv, _In_opt_ const BIGNUM* in_r,
                                    _In_ EC_KEY* eckey);
 
 // Verifies that the signature in sigbuf of size sig_len is a valid ECDSA signature of the hash value dgst
 // of size dgst_len using the public key eckey. The parameter type is ignored.
 // Returns 1 for a valid signature, 0 for an invalid signature, and -1 on error.
-SCOSSL_STATUS scossl_eckey_verify(int type, _In_reads_bytes_(dgst_len) const unsigned char* dgst, int dgst_len,
+SCOSSL_STATUS e_scossl_eckey_verify(int type, _In_reads_bytes_(dgst_len) const unsigned char* dgst, int dgst_len,
                           _In_reads_bytes_(sig_len) const unsigned char* sigbuf, int sig_len, _In_ EC_KEY* eckey);
 
 // Verifies that the signature in sig is a valid ECDSA signature of the hash value dgst of size dgst_len
 // using the public key eckey.
 // Returns 1 for a valid signature, 0 for an invalid signature, and -1 on error.
-SCOSSL_STATUS scossl_eckey_verify_sig(_In_reads_bytes_(dgst_len) const unsigned char* dgst, int dgst_len,
+SCOSSL_STATUS e_scossl_eckey_verify_sig(_In_reads_bytes_(dgst_len) const unsigned char* dgst, int dgst_len,
                               _In_ const ECDSA_SIG* sig, _In_ EC_KEY* eckey);
 
 // Frees internal SymCrypt curves, only to be used on engine destruction.
-void scossl_destroy_ecc_curves(void);
+void e_scossl_destroy_ecc_curves(void);
 
 #ifdef __cplusplus
 }
diff --git a/SymCryptEngine/src/scossl_hkdf.c b/SymCryptEngine/src/scossl_hkdf.c
index e72ad99..8e2580e 100644
--- a/SymCryptEngine/src/scossl_hkdf.c
+++ b/SymCryptEngine/src/scossl_hkdf.c
@@ -23,74 +23,74 @@ typedef struct {
 } SCOSSL_HKDF_PKEY_CTX;
 
 
-SCOSSL_STATUS scossl_hkdf_init(_Inout_ EVP_PKEY_CTX *ctx)
+SCOSSL_STATUS e_scossl_hkdf_init(_Inout_ EVP_PKEY_CTX *ctx)
 {
-    SCOSSL_HKDF_PKEY_CTX *scossl_hkdf_context;
-    if ((scossl_hkdf_context = OPENSSL_zalloc(sizeof(*scossl_hkdf_context))) == NULL) {
+    SCOSSL_HKDF_PKEY_CTX *e_scossl_hkdf_context;
+    if ((e_scossl_hkdf_context = OPENSSL_zalloc(sizeof(*e_scossl_hkdf_context))) == NULL) {
         SCOSSL_LOG_ERROR(SCOSSL_ERR_F_HKDF_INIT, ERR_R_MALLOC_FAILURE,
             "OPENSSL_zalloc returned NULL");
         return SCOSSL_FAILURE;
     }
-    EVP_PKEY_CTX_set_data(ctx, scossl_hkdf_context);
+    EVP_PKEY_CTX_set_data(ctx, e_scossl_hkdf_context);
     return SCOSSL_SUCCESS;
 }
 
-void scossl_hkdf_cleanup(_Inout_ EVP_PKEY_CTX *ctx)
+void e_scossl_hkdf_cleanup(_Inout_ EVP_PKEY_CTX *ctx)
 {
-    SCOSSL_HKDF_PKEY_CTX *scossl_hkdf_context = NULL;
+    SCOSSL_HKDF_PKEY_CTX *e_scossl_hkdf_context = NULL;
 
-    scossl_hkdf_context = (SCOSSL_HKDF_PKEY_CTX *)EVP_PKEY_CTX_get_data(ctx);
-    if (scossl_hkdf_context == NULL) {
+    e_scossl_hkdf_context = (SCOSSL_HKDF_PKEY_CTX *)EVP_PKEY_CTX_get_data(ctx);
+    if (e_scossl_hkdf_context == NULL) {
         return;
     }
-    OPENSSL_clear_free(scossl_hkdf_context->salt, scossl_hkdf_context->salt_len);
-    OPENSSL_clear_free(scossl_hkdf_context->key, scossl_hkdf_context->key_len);
-    OPENSSL_cleanse(scossl_hkdf_context->info, scossl_hkdf_context->info_len);
-    OPENSSL_free(scossl_hkdf_context);
+    OPENSSL_clear_free(e_scossl_hkdf_context->salt, e_scossl_hkdf_context->salt_len);
+    OPENSSL_clear_free(e_scossl_hkdf_context->key, e_scossl_hkdf_context->key_len);
+    OPENSSL_cleanse(e_scossl_hkdf_context->info, e_scossl_hkdf_context->info_len);
+    OPENSSL_free(e_scossl_hkdf_context);
     EVP_PKEY_CTX_set_data(ctx, NULL);
 }
 
-SCOSSL_STATUS scossl_hkdf_ctrl(EVP_PKEY_CTX *ctx, int type, int p1, void *p2)
+SCOSSL_STATUS e_scossl_hkdf_ctrl(EVP_PKEY_CTX *ctx, int type, int p1, void *p2)
 {
-    SCOSSL_HKDF_PKEY_CTX *scossl_hkdf_context = (SCOSSL_HKDF_PKEY_CTX *)EVP_PKEY_CTX_get_data(ctx);
+    SCOSSL_HKDF_PKEY_CTX *e_scossl_hkdf_context = (SCOSSL_HKDF_PKEY_CTX *)EVP_PKEY_CTX_get_data(ctx);
     switch (type) {
     case EVP_PKEY_CTRL_HKDF_MD:
         if (p2 == NULL)
             return SCOSSL_FAILURE;
-        scossl_hkdf_context->md = p2;
+        e_scossl_hkdf_context->md = p2;
         return SCOSSL_SUCCESS;
     case EVP_PKEY_CTRL_HKDF_MODE:
-        scossl_hkdf_context->mode = p1;
+        e_scossl_hkdf_context->mode = p1;
         return SCOSSL_SUCCESS;
     case EVP_PKEY_CTRL_HKDF_SALT:
         if (p1 == 0 || p2 == NULL)
             return SCOSSL_SUCCESS;
         if (p1 < 0)
             return SCOSSL_FAILURE;
-        if (scossl_hkdf_context->salt != NULL)
-            OPENSSL_clear_free(scossl_hkdf_context->salt, scossl_hkdf_context->salt_len);
-        scossl_hkdf_context->salt = OPENSSL_memdup(p2, p1);
-        if (scossl_hkdf_context->salt == NULL)
+        if (e_scossl_hkdf_context->salt != NULL)
+            OPENSSL_clear_free(e_scossl_hkdf_context->salt, e_scossl_hkdf_context->salt_len);
+        e_scossl_hkdf_context->salt = OPENSSL_memdup(p2, p1);
+        if (e_scossl_hkdf_context->salt == NULL)
             return SCOSSL_FAILURE;
-        scossl_hkdf_context->salt_len = p1;
+        e_scossl_hkdf_context->salt_len = p1;
         return SCOSSL_SUCCESS;
     case EVP_PKEY_CTRL_HKDF_KEY:
         if (p1 < 0)
             return SCOSSL_FAILURE;
-        if (scossl_hkdf_context->key != NULL)
-            OPENSSL_clear_free(scossl_hkdf_context->key, scossl_hkdf_context->key_len);
-        scossl_hkdf_context->key = OPENSSL_memdup(p2, p1);
-        if (scossl_hkdf_context->key == NULL)
+        if (e_scossl_hkdf_context->key != NULL)
+            OPENSSL_clear_free(e_scossl_hkdf_context->key, e_scossl_hkdf_context->key_len);
+        e_scossl_hkdf_context->key = OPENSSL_memdup(p2, p1);
+        if (e_scossl_hkdf_context->key == NULL)
             return SCOSSL_FAILURE;
-        scossl_hkdf_context->key_len  = p1;
+        e_scossl_hkdf_context->key_len  = p1;
         return SCOSSL_SUCCESS;
     case EVP_PKEY_CTRL_HKDF_INFO:
         if (p1 == 0 || p2 == NULL)
             return SCOSSL_SUCCESS;
-        if (p1 < 0 || p1 > (int)(HKDF_MAXBUF - scossl_hkdf_context->info_len))
+        if (p1 < 0 || p1 > (int)(HKDF_MAXBUF - e_scossl_hkdf_context->info_len))
             return SCOSSL_FAILURE;
-        memcpy(scossl_hkdf_context->info + scossl_hkdf_context->info_len, p2, p1);
-        scossl_hkdf_context->info_len += p1;
+        memcpy(e_scossl_hkdf_context->info + e_scossl_hkdf_context->info_len, p2, p1);
+        e_scossl_hkdf_context->info_len += p1;
         return SCOSSL_SUCCESS;
     default:
         SCOSSL_LOG_ERROR(SCOSSL_ERR_F_HKDF_CTRL, SCOSSL_ERR_R_NOT_IMPLEMENTED,
@@ -99,13 +99,13 @@ SCOSSL_STATUS scossl_hkdf_ctrl(EVP_PKEY_CTX *ctx, int type, int p1, void *p2)
     }
 }
 
-SCOSSL_STATUS scossl_hkdf_derive_init(_Inout_ EVP_PKEY_CTX *ctx)
+SCOSSL_STATUS e_scossl_hkdf_derive_init(_Inout_ EVP_PKEY_CTX *ctx)
 {
-    SCOSSL_HKDF_PKEY_CTX *scossl_hkdf_context = (SCOSSL_HKDF_PKEY_CTX *)EVP_PKEY_CTX_get_data(ctx);
-    OPENSSL_clear_free(scossl_hkdf_context->key, scossl_hkdf_context->key_len);
-    OPENSSL_clear_free(scossl_hkdf_context->salt, scossl_hkdf_context->salt_len);
-    OPENSSL_cleanse(scossl_hkdf_context->info, scossl_hkdf_context->info_len);
-    memset(scossl_hkdf_context, 0, sizeof(*scossl_hkdf_context));
+    SCOSSL_HKDF_PKEY_CTX *e_scossl_hkdf_context = (SCOSSL_HKDF_PKEY_CTX *)EVP_PKEY_CTX_get_data(ctx);
+    OPENSSL_clear_free(e_scossl_hkdf_context->key, e_scossl_hkdf_context->key_len);
+    OPENSSL_clear_free(e_scossl_hkdf_context->salt, e_scossl_hkdf_context->salt_len);
+    OPENSSL_cleanse(e_scossl_hkdf_context->info, e_scossl_hkdf_context->info_len);
+    memset(e_scossl_hkdf_context, 0, sizeof(*e_scossl_hkdf_context));
     return SCOSSL_SUCCESS;
 }
 
@@ -206,7 +206,7 @@ static unsigned char *HKDF(const EVP_MD *evp_md,
     return ret;
 }
 
-static PCSYMCRYPT_MAC scossl_get_symcrypt_mac_algorithm( _In_ const EVP_MD *evp_md )
+static PCSYMCRYPT_MAC e_scossl_get_symcrypt_mac_algorithm( _In_ const EVP_MD *evp_md )
 {
     int type = EVP_MD_type(evp_md);
 
@@ -225,35 +225,35 @@ static PCSYMCRYPT_MAC scossl_get_symcrypt_mac_algorithm( _In_ const EVP_MD *evp_
     return NULL;
 }
 
-SCOSSL_STATUS scossl_hkdf_derive(_Inout_ EVP_PKEY_CTX *ctx, _Out_writes_opt_(*keylen) unsigned char *key,
+SCOSSL_STATUS e_scossl_hkdf_derive(_Inout_ EVP_PKEY_CTX *ctx, _Out_writes_opt_(*keylen) unsigned char *key,
                                     _Inout_ size_t *keylen)
 {
     SYMCRYPT_ERROR scError = SYMCRYPT_NO_ERROR;
-    SCOSSL_HKDF_PKEY_CTX *scossl_hkdf_context = (SCOSSL_HKDF_PKEY_CTX *)EVP_PKEY_CTX_get_data(ctx);
-    PCSYMCRYPT_MAC scossl_mac_algo = NULL;
+    SCOSSL_HKDF_PKEY_CTX *e_scossl_hkdf_context = (SCOSSL_HKDF_PKEY_CTX *)EVP_PKEY_CTX_get_data(ctx);
+    PCSYMCRYPT_MAC e_scossl_mac_algo = NULL;
     SYMCRYPT_HKDF_EXPANDED_KEY  scExpandedKey;
 
-    if (scossl_hkdf_context->md == NULL) {
+    if (e_scossl_hkdf_context->md == NULL) {
         SCOSSL_LOG_ERROR(SCOSSL_ERR_F_HKDF_DERIVE, ERR_R_INTERNAL_ERROR,
             "Missing Digest");
         return SCOSSL_FAILURE;
     }
-    scossl_mac_algo = scossl_get_symcrypt_mac_algorithm(scossl_hkdf_context->md);
-    if (scossl_hkdf_context->key == NULL) {
+    e_scossl_mac_algo = e_scossl_get_symcrypt_mac_algorithm(e_scossl_hkdf_context->md);
+    if (e_scossl_hkdf_context->key == NULL) {
         SCOSSL_LOG_ERROR(SCOSSL_ERR_F_HKDF_DERIVE, ERR_R_INTERNAL_ERROR,
             "Missing Key");
         return SCOSSL_FAILURE;
     }
 
-    switch (scossl_hkdf_context->mode) {
+    switch (e_scossl_hkdf_context->mode) {
     case EVP_PKEY_HKDEF_MODE_EXTRACT_AND_EXPAND:
-        if( scossl_mac_algo != NULL )
+        if( e_scossl_mac_algo != NULL )
         {
             scError = SymCryptHkdf(
-                scossl_mac_algo,
-                scossl_hkdf_context->key, scossl_hkdf_context->key_len,
-                scossl_hkdf_context->salt, scossl_hkdf_context->salt_len,
-                scossl_hkdf_context->info, scossl_hkdf_context->info_len,
+                e_scossl_mac_algo,
+                e_scossl_hkdf_context->key, e_scossl_hkdf_context->key_len,
+                e_scossl_hkdf_context->salt, e_scossl_hkdf_context->salt_len,
+                e_scossl_hkdf_context->info, e_scossl_hkdf_context->info_len,
                 key, *keylen);
             if (scError != SYMCRYPT_NO_ERROR)
             {
@@ -263,28 +263,28 @@ SCOSSL_STATUS scossl_hkdf_derive(_Inout_ EVP_PKEY_CTX *ctx, _Out_writes_opt_(*ke
         else
         {
             SCOSSL_LOG_INFO(SCOSSL_ERR_F_HKDF_DERIVE, SCOSSL_ERR_R_OPENSSL_FALLBACK,
-                "SymCrypt engine does not support Mac algorithm %d - falling back to OpenSSL", EVP_MD_type(scossl_hkdf_context->md));
+                "SymCrypt engine does not support Mac algorithm %d - falling back to OpenSSL", EVP_MD_type(e_scossl_hkdf_context->md));
 
             return HKDF(
-                scossl_hkdf_context->md,
-                scossl_hkdf_context->salt, scossl_hkdf_context->salt_len,
-                scossl_hkdf_context->key, scossl_hkdf_context->key_len,
-                scossl_hkdf_context->info, scossl_hkdf_context->info_len,
+                e_scossl_hkdf_context->md,
+                e_scossl_hkdf_context->salt, e_scossl_hkdf_context->salt_len,
+                e_scossl_hkdf_context->key, e_scossl_hkdf_context->key_len,
+                e_scossl_hkdf_context->info, e_scossl_hkdf_context->info_len,
                 key, *keylen) != NULL;
         }
         return SCOSSL_SUCCESS;
     case EVP_PKEY_HKDEF_MODE_EXTRACT_ONLY:
         if (key == NULL) {
-            *keylen = EVP_MD_size(scossl_hkdf_context->md);
+            *keylen = EVP_MD_size(e_scossl_hkdf_context->md);
             return SCOSSL_SUCCESS;
         }
 
-        if( scossl_mac_algo != NULL )
+        if( e_scossl_mac_algo != NULL )
         {
             scError = SymCryptHkdfExtractPrk(
-                scossl_mac_algo,
-                scossl_hkdf_context->key, scossl_hkdf_context->key_len,
-                scossl_hkdf_context->salt, scossl_hkdf_context->salt_len,
+                e_scossl_mac_algo,
+                e_scossl_hkdf_context->key, e_scossl_hkdf_context->key_len,
+                e_scossl_hkdf_context->salt, e_scossl_hkdf_context->salt_len,
                 key, *keylen );
             if (scError != SYMCRYPT_NO_ERROR)
             {
@@ -294,22 +294,22 @@ SCOSSL_STATUS scossl_hkdf_derive(_Inout_ EVP_PKEY_CTX *ctx, _Out_writes_opt_(*ke
         else
         {
             SCOSSL_LOG_INFO(SCOSSL_ERR_F_HKDF_DERIVE, SCOSSL_ERR_R_OPENSSL_FALLBACK,
-                "SymCrypt engine does not support Mac algorithm %d - falling back to OpenSSL", EVP_MD_type(scossl_hkdf_context->md));
+                "SymCrypt engine does not support Mac algorithm %d - falling back to OpenSSL", EVP_MD_type(e_scossl_hkdf_context->md));
 
             return HKDF_Extract(
-                    scossl_hkdf_context->md,
-                    scossl_hkdf_context->salt, scossl_hkdf_context->salt_len,
-                    scossl_hkdf_context->key, scossl_hkdf_context->key_len,
+                    e_scossl_hkdf_context->md,
+                    e_scossl_hkdf_context->salt, e_scossl_hkdf_context->salt_len,
+                    e_scossl_hkdf_context->key, e_scossl_hkdf_context->key_len,
                     key, keylen) != NULL;
         }
         return SCOSSL_SUCCESS;
     case EVP_PKEY_HKDEF_MODE_EXPAND_ONLY:
-        if( scossl_mac_algo != NULL )
+        if( e_scossl_mac_algo != NULL )
         {
             scError = SymCryptHkdfPrkExpandKey(
                 &scExpandedKey,
-                scossl_mac_algo,
-                scossl_hkdf_context->key, scossl_hkdf_context->key_len );
+                e_scossl_mac_algo,
+                e_scossl_hkdf_context->key, e_scossl_hkdf_context->key_len );
             if (scError != SYMCRYPT_NO_ERROR)
             {
                 return SCOSSL_FAILURE;
@@ -317,7 +317,7 @@ SCOSSL_STATUS scossl_hkdf_derive(_Inout_ EVP_PKEY_CTX *ctx, _Out_writes_opt_(*ke
 
             scError = SymCryptHkdfDerive(
                 &scExpandedKey,
-                scossl_hkdf_context->info, scossl_hkdf_context->info_len,
+                e_scossl_hkdf_context->info, e_scossl_hkdf_context->info_len,
                 key,
                 *keylen);
             if (scError != SYMCRYPT_NO_ERROR)
@@ -328,12 +328,12 @@ SCOSSL_STATUS scossl_hkdf_derive(_Inout_ EVP_PKEY_CTX *ctx, _Out_writes_opt_(*ke
         else
         {
             SCOSSL_LOG_INFO(SCOSSL_ERR_F_HKDF_DERIVE, SCOSSL_ERR_R_OPENSSL_FALLBACK,
-                "SymCrypt engine does not support Mac algorithm %d - falling back to OpenSSL", EVP_MD_type(scossl_hkdf_context->md));
+                "SymCrypt engine does not support Mac algorithm %d - falling back to OpenSSL", EVP_MD_type(e_scossl_hkdf_context->md));
 
             return HKDF_Expand(
-                    scossl_hkdf_context->md,
-                    scossl_hkdf_context->key, scossl_hkdf_context->key_len,
-                    scossl_hkdf_context->info, scossl_hkdf_context->info_len,
+                    e_scossl_hkdf_context->md,
+                    e_scossl_hkdf_context->key, e_scossl_hkdf_context->key_len,
+                    e_scossl_hkdf_context->info, e_scossl_hkdf_context->info_len,
                     key, *keylen) != NULL;
         }
         return SCOSSL_SUCCESS;
diff --git a/SymCryptEngine/src/scossl_hkdf.h b/SymCryptEngine/src/scossl_hkdf.h
index 9f1d506..574591e 100644
--- a/SymCryptEngine/src/scossl_hkdf.h
+++ b/SymCryptEngine/src/scossl_hkdf.h
@@ -3,7 +3,6 @@
 //
 
 #include "scossl.h"
-#include "scossl_helpers.h"
 
 #ifdef __cplusplus
 extern "C" {
@@ -11,25 +10,25 @@ extern "C" {
 
 // Allocate internal context and attach to ctx.
 // Returns SCOSSL_SUCCESS on success, or SCOSSL_FAILURE on error.
-SCOSSL_STATUS scossl_hkdf_init(_Inout_ EVP_PKEY_CTX *ctx);
+SCOSSL_STATUS e_scossl_hkdf_init(_Inout_ EVP_PKEY_CTX *ctx);
 
 // Frees the internal context of ctx.
-void scossl_hkdf_cleanup(_Inout_ EVP_PKEY_CTX *ctx);
+void e_scossl_hkdf_cleanup(_Inout_ EVP_PKEY_CTX *ctx);
 
 // Sends a control operation to context ctx. type indicates which operation, and
 // p1 and p2 are optional parameters depending on which type is used.
 // Returns SCOSSL_SUCCESS on success, or SCOSSL_FAILURE on error, or SCOSSL_UNSUPPORTED on not supported.
-SCOSSL_STATUS scossl_hkdf_ctrl(_Inout_ EVP_PKEY_CTX *ctx, int type, int p1, _In_ void *p2);
+SCOSSL_STATUS e_scossl_hkdf_ctrl(_Inout_ EVP_PKEY_CTX *ctx, int type, int p1, _In_ void *p2);
 
 // Initializes context ctx.
 // Returns SCOSSL_SUCCESS on success, or SCOSSL_FAILURE on error.
-SCOSSL_STATUS scossl_hkdf_derive_init(_Inout_ EVP_PKEY_CTX *ctx);
+SCOSSL_STATUS e_scossl_hkdf_derive_init(_Inout_ EVP_PKEY_CTX *ctx);
 
 // Derives a shared secret using ctx. If key is NULL then the maximum size of the output buffer
 // is written to the keylen parameter. If key is not NULL, then keylen should contain the length of
 // the key buffer, the shared secret is written to key and the amount of data written to keylen.
 // Returns SCOSSL_SUCCESS on success, or SCOSSL_FAILURE or a negative value for failure.
-SCOSSL_STATUS scossl_hkdf_derive(_Inout_ EVP_PKEY_CTX *ctx, _Out_writes_opt_(*keylen) unsigned char *key,
+SCOSSL_STATUS e_scossl_hkdf_derive(_Inout_ EVP_PKEY_CTX *ctx, _Out_writes_opt_(*keylen) unsigned char *key,
                                     _Inout_ size_t *keylen);
 
 #ifdef __cplusplus
diff --git a/SymCryptEngine/src/scossl_hmac.c b/SymCryptEngine/src/scossl_hmac.c
index 1f43d53..7b55958 100644
--- a/SymCryptEngine/src/scossl_hmac.c
+++ b/SymCryptEngine/src/scossl_hmac.c
@@ -19,7 +19,7 @@ typedef struct {
 } SCOSSL_HMAC_PKEY_CTX;
 
 
-static PCSYMCRYPT_MAC scossl_get_symcrypt_hmac_algorithm( _In_ const EVP_MD *evp_md )
+static PCSYMCRYPT_MAC e_scossl_get_symcrypt_hmac_algorithm( _In_ const EVP_MD *evp_md )
 {
     int type = EVP_MD_type(evp_md);
 
@@ -38,44 +38,44 @@ static PCSYMCRYPT_MAC scossl_get_symcrypt_hmac_algorithm( _In_ const EVP_MD *evp
 }
 
 
-SCOSSL_STATUS scossl_hmac_init(_Inout_ EVP_PKEY_CTX *ctx)
+SCOSSL_STATUS e_scossl_hmac_init(_Inout_ EVP_PKEY_CTX *ctx)
 {
-    SCOSSL_HMAC_PKEY_CTX *scossl_hmac_context;
+    SCOSSL_HMAC_PKEY_CTX *e_scossl_hmac_context;
     
-    if ((scossl_hmac_context = OPENSSL_zalloc(sizeof(*scossl_hmac_context))) == NULL) {
+    if ((e_scossl_hmac_context = OPENSSL_zalloc(sizeof(*e_scossl_hmac_context))) == NULL) {
         SCOSSL_LOG_ERROR(SCOSSL_ERR_F_HMAC_INIT, ERR_R_MALLOC_FAILURE,
             "OPENSSL_zalloc returned NULL");
         return SCOSSL_FAILURE;
     }
     
-    EVP_PKEY_CTX_set_data(ctx, scossl_hmac_context);
+    EVP_PKEY_CTX_set_data(ctx, e_scossl_hmac_context);
 
     return SCOSSL_SUCCESS;
 }
 
 
-void scossl_hmac_cleanup(_Inout_ EVP_PKEY_CTX *ctx)
+void e_scossl_hmac_cleanup(_Inout_ EVP_PKEY_CTX *ctx)
 {
-    SCOSSL_HMAC_PKEY_CTX *scossl_hmac_context = (SCOSSL_HMAC_PKEY_CTX *)EVP_PKEY_CTX_get_data(ctx);
+    SCOSSL_HMAC_PKEY_CTX *e_scossl_hmac_context = (SCOSSL_HMAC_PKEY_CTX *)EVP_PKEY_CTX_get_data(ctx);
     
-    if (!scossl_hmac_context) {
+    if (!e_scossl_hmac_context) {
         return;
     }
 
-    OPENSSL_clear_free(scossl_hmac_context->key.data, scossl_hmac_context->key.length);
-    OPENSSL_clear_free(scossl_hmac_context, sizeof(*scossl_hmac_context));
+    OPENSSL_clear_free(e_scossl_hmac_context->key.data, e_scossl_hmac_context->key.length);
+    OPENSSL_clear_free(e_scossl_hmac_context, sizeof(*e_scossl_hmac_context));
 
     EVP_PKEY_CTX_set_data(ctx, NULL);
 }
 
 
-SCOSSL_STATUS scossl_hmac_copy(_Out_ EVP_PKEY_CTX *dst, _In_ EVP_PKEY_CTX *src)
+SCOSSL_STATUS e_scossl_hmac_copy(_Out_ EVP_PKEY_CTX *dst, _In_ EVP_PKEY_CTX *src)
 {
     SCOSSL_STATUS ret = SCOSSL_SUCCESS;
     SCOSSL_HMAC_PKEY_CTX *src_ctx, *dst_ctx;
     ASN1_OCTET_STRING *pkey;
 
-    ret = scossl_hmac_init(dst);
+    ret = e_scossl_hmac_init(dst);
 
     if (ret != SCOSSL_SUCCESS) {
         goto end;
@@ -151,7 +151,7 @@ SCOSSL_STATUS scossl_hmac_copy(_Out_ EVP_PKEY_CTX *dst, _In_ EVP_PKEY_CTX *src)
 cleanup:
 
     if(ret != SCOSSL_SUCCESS) {
-        scossl_hmac_cleanup(dst);
+        e_scossl_hmac_cleanup(dst);
     }
 
 end:
@@ -160,10 +160,10 @@ end:
 }
 
 
-SCOSSL_STATUS scossl_hmac_ctrl(EVP_PKEY_CTX *ctx, int type, int p1, void *p2)
+SCOSSL_STATUS e_scossl_hmac_ctrl(EVP_PKEY_CTX *ctx, int type, int p1, void *p2)
 {
     SCOSSL_STATUS ret = SCOSSL_SUCCESS;
-    SCOSSL_HMAC_PKEY_CTX *scossl_hmac_context = (SCOSSL_HMAC_PKEY_CTX *)EVP_PKEY_CTX_get_data(ctx);
+    SCOSSL_HMAC_PKEY_CTX *e_scossl_hmac_context = (SCOSSL_HMAC_PKEY_CTX *)EVP_PKEY_CTX_get_data(ctx);
     EVP_PKEY *pkey;
     ASN1_OCTET_STRING *key;
 
@@ -176,7 +176,7 @@ SCOSSL_STATUS scossl_hmac_ctrl(EVP_PKEY_CTX *ctx, int type, int p1, void *p2)
             ret = SCOSSL_FAILURE;
             break;
         }
-        scossl_hmac_context->mac = scossl_get_symcrypt_hmac_algorithm((const EVP_MD*)p2);
+        e_scossl_hmac_context->mac = e_scossl_get_symcrypt_hmac_algorithm((const EVP_MD*)p2);
         break;
 
     case EVP_PKEY_CTRL_SET_MAC_KEY:
@@ -187,11 +187,11 @@ SCOSSL_STATUS scossl_hmac_ctrl(EVP_PKEY_CTX *ctx, int type, int p1, void *p2)
             break;
         }
 
-        if(scossl_hmac_context->key.data) {
-            OPENSSL_clear_free(scossl_hmac_context->key.data, scossl_hmac_context->key.length);
+        if(e_scossl_hmac_context->key.data) {
+            OPENSSL_clear_free(e_scossl_hmac_context->key.data, e_scossl_hmac_context->key.length);
         }
 
-        if(!ASN1_OCTET_STRING_set(&scossl_hmac_context->key, p2, p1)) {
+        if(!ASN1_OCTET_STRING_set(&e_scossl_hmac_context->key, p2, p1)) {
             ret = SCOSSL_FAILURE;
             break;
         }
@@ -213,14 +213,14 @@ SCOSSL_STATUS scossl_hmac_ctrl(EVP_PKEY_CTX *ctx, int type, int p1, void *p2)
             break;
         }
 
-        if(scossl_hmac_context->mac->expandKeyFunc(&scossl_hmac_context->expandedKey, 
+        if(e_scossl_hmac_context->mac->expandKeyFunc(&e_scossl_hmac_context->expandedKey, 
                                                     key->data,
                                                     key->length) != SYMCRYPT_NO_ERROR) {
 
             ret = SCOSSL_FAILURE;
             break;
         }
-        scossl_hmac_context->mac->initFunc(&scossl_hmac_context->macState, &scossl_hmac_context->expandedKey);
+        e_scossl_hmac_context->mac->initFunc(&e_scossl_hmac_context->macState, &e_scossl_hmac_context->expandedKey);
         break;
 
     default:
@@ -232,18 +232,18 @@ SCOSSL_STATUS scossl_hmac_ctrl(EVP_PKEY_CTX *ctx, int type, int p1, void *p2)
     return ret;
 }
 
-SCOSSL_STATUS scossl_hmac_keygen(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey)
+SCOSSL_STATUS e_scossl_hmac_keygen(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey)
 {
     SCOSSL_STATUS ret = SCOSSL_SUCCESS;
-    SCOSSL_HMAC_PKEY_CTX *scossl_hmac_context = (SCOSSL_HMAC_PKEY_CTX *)EVP_PKEY_CTX_get_data(ctx);
+    SCOSSL_HMAC_PKEY_CTX *e_scossl_hmac_context = (SCOSSL_HMAC_PKEY_CTX *)EVP_PKEY_CTX_get_data(ctx);
     ASN1_OCTET_STRING *key;
 
-    if(!scossl_hmac_context->key.data) {
+    if(!e_scossl_hmac_context->key.data) {
         ret = SCOSSL_FAILURE;
         goto end;
     }
 
-    key =  ASN1_OCTET_STRING_dup(&scossl_hmac_context->key);
+    key =  ASN1_OCTET_STRING_dup(&e_scossl_hmac_context->key);
 
     if(!key) {
         ret = SCOSSL_FAILURE;
@@ -257,46 +257,46 @@ end:
     return ret;
 }
 
-SCOSSL_STATUS scossl_hmac_update(EVP_MD_CTX *ctx, const void *data, size_t count)
+SCOSSL_STATUS e_scossl_hmac_update(EVP_MD_CTX *ctx, const void *data, size_t count)
 {
-    SCOSSL_HMAC_PKEY_CTX *scossl_hmac_context = (SCOSSL_HMAC_PKEY_CTX *)EVP_PKEY_CTX_get_data(EVP_MD_CTX_pkey_ctx(ctx));
+    SCOSSL_HMAC_PKEY_CTX *e_scossl_hmac_context = (SCOSSL_HMAC_PKEY_CTX *)EVP_PKEY_CTX_get_data(EVP_MD_CTX_pkey_ctx(ctx));
 
-    scossl_hmac_context->mac->appendFunc(&scossl_hmac_context->macState, data, count);
+    e_scossl_hmac_context->mac->appendFunc(&e_scossl_hmac_context->macState, data, count);
 
     return SCOSSL_SUCCESS;
 }
 
 
-SCOSSL_STATUS scossl_hmac_signctx_init(EVP_PKEY_CTX *ctx, EVP_MD_CTX *mdctx)
+SCOSSL_STATUS e_scossl_hmac_signctx_init(EVP_PKEY_CTX *ctx, EVP_MD_CTX *mdctx)
 {
     EVP_MD_CTX_set_flags(mdctx, EVP_MD_CTX_FLAG_NO_INIT);
 
-    EVP_MD_CTX_set_update_fn(mdctx, scossl_hmac_update);
+    EVP_MD_CTX_set_update_fn(mdctx, e_scossl_hmac_update);
 
     return SCOSSL_SUCCESS;
 }
 
 
-SCOSSL_STATUS scossl_hmac_signctx(_Inout_ EVP_PKEY_CTX *ctx, _Out_ unsigned char *sig, _Out_ size_t *siglen, _In_ EVP_MD_CTX *mdctx)
+SCOSSL_STATUS e_scossl_hmac_signctx(_Inout_ EVP_PKEY_CTX *ctx, _Out_ unsigned char *sig, _Out_ size_t *siglen, _In_ EVP_MD_CTX *mdctx)
 {
     SCOSSL_STATUS ret = SCOSSL_SUCCESS;
-    SCOSSL_HMAC_PKEY_CTX *scossl_hmac_context = (SCOSSL_HMAC_PKEY_CTX *)EVP_PKEY_CTX_get_data(ctx);
+    SCOSSL_HMAC_PKEY_CTX *e_scossl_hmac_context = (SCOSSL_HMAC_PKEY_CTX *)EVP_PKEY_CTX_get_data(ctx);
 
     if(!sig) {
 
-        *siglen = scossl_hmac_context->mac->resultSize;
+        *siglen = e_scossl_hmac_context->mac->resultSize;
         goto end;
     }
 
-    if(*siglen < scossl_hmac_context->mac->resultSize) {
+    if(*siglen < e_scossl_hmac_context->mac->resultSize) {
 
         ret = SCOSSL_FAILURE;
         goto end;
     }
 
-    scossl_hmac_context->mac->resultFunc(&scossl_hmac_context->macState, sig);
+    e_scossl_hmac_context->mac->resultFunc(&e_scossl_hmac_context->macState, sig);
     
-    *siglen = scossl_hmac_context->mac->resultSize;
+    *siglen = e_scossl_hmac_context->mac->resultSize;
 
 end:
 
diff --git a/SymCryptEngine/src/scossl_hmac.h b/SymCryptEngine/src/scossl_hmac.h
index 2597b6f..4a69da3 100644
--- a/SymCryptEngine/src/scossl_hmac.h
+++ b/SymCryptEngine/src/scossl_hmac.h
@@ -3,7 +3,6 @@
 //
 
 #include "scossl.h"
-#include "scossl_helpers.h"
 
 #ifdef __cplusplus
 extern "C" {
@@ -11,30 +10,30 @@ extern "C" {
 
 // Allocate internal context and attach to ctx.
 // Returns SCOSSL_SUCCESS on success, or SCOSSL_FAILURE on error.
-SCOSSL_STATUS scossl_hmac_init(_Inout_ EVP_PKEY_CTX *ctx);
+SCOSSL_STATUS e_scossl_hmac_init(_Inout_ EVP_PKEY_CTX *ctx);
 
 // Frees the internal context of ctx.
-void scossl_hmac_cleanup(_Inout_ EVP_PKEY_CTX *ctx);
+void e_scossl_hmac_cleanup(_Inout_ EVP_PKEY_CTX *ctx);
 
 // Makes a copy of internal context src
-SCOSSL_STATUS scossl_hmac_copy(_Out_ EVP_PKEY_CTX *dst, _In_ EVP_PKEY_CTX *src);
+SCOSSL_STATUS e_scossl_hmac_copy(_Out_ EVP_PKEY_CTX *dst, _In_ EVP_PKEY_CTX *src);
 
 // Sends a control operation to context ctx. type indicates which operation, and
 // p1 and p2 are optional parameters depending on which type is used.
 // Returns SCOSSL_SUCCESS on success, or SCOSSL_FAILURE on error, or SCOSSL_UNSUPPORTED on not supported.
-SCOSSL_STATUS scossl_hmac_ctrl(_Inout_ EVP_PKEY_CTX *ctx, int type, int p1, _In_ void *p2);
+SCOSSL_STATUS e_scossl_hmac_ctrl(_Inout_ EVP_PKEY_CTX *ctx, int type, int p1, _In_ void *p2);
 
 // Initializes pkey with the HMAC key from the internal context.
-SCOSSL_STATUS scossl_hmac_keygen(_Inout_ EVP_PKEY_CTX *ctx, EVP_PKEY *pkey);
+SCOSSL_STATUS e_scossl_hmac_keygen(_Inout_ EVP_PKEY_CTX *ctx, EVP_PKEY *pkey);
 
 // Performs initialization on the mdctx object, such as setting the message update function.
-SCOSSL_STATUS scossl_hmac_signctx_init(_Inout_ EVP_PKEY_CTX *ctx, _In_ EVP_MD_CTX *mdctx);
+SCOSSL_STATUS e_scossl_hmac_signctx_init(_Inout_ EVP_PKEY_CTX *ctx, _In_ EVP_MD_CTX *mdctx);
 
-// Finalizes the HMAC computation by calling the resultFunc of the HMAC algorithm on the mac state 
+// Finalizes the HMAC computation by calling the resultFunc of the HMAC algorithm on the mac state
 // stored in the internal context.
 // If sig is NULL siglen is set to HMAC output length.
 // If sig is not NULL, the length siglen points to should not not be smaller than the HMAC output length.
-SCOSSL_STATUS scossl_hmac_signctx(_Inout_ EVP_PKEY_CTX *ctx, _Out_ unsigned char *sig, _Out_ size_t *siglen, _In_ EVP_MD_CTX *mdctx);
+SCOSSL_STATUS e_scossl_hmac_signctx(_Inout_ EVP_PKEY_CTX *ctx, _Out_ unsigned char *sig, _Out_ size_t *siglen, _In_ EVP_MD_CTX *mdctx);
 
 #ifdef __cplusplus
 }
diff --git a/SymCryptEngine/src/scossl_pkey_meths.c b/SymCryptEngine/src/scossl_pkey_meths.c
index 9189db7..7dd9f80 100644
--- a/SymCryptEngine/src/scossl_pkey_meths.c
+++ b/SymCryptEngine/src/scossl_pkey_meths.c
@@ -15,7 +15,7 @@ extern "C" {
 #endif
 
 
-static int scossl_evp_nids[] = {
+static int e_scossl_evp_nids[] = {
     EVP_PKEY_RSA,
     EVP_PKEY_RSA_PSS,
     EVP_PKEY_TLS1_PRF,
@@ -23,7 +23,7 @@ static int scossl_evp_nids[] = {
     EVP_PKEY_HMAC,
     // EVP_PKEY_X25519 - Future
 };
-static const int scossl_evp_nids_count = sizeof(scossl_evp_nids) / sizeof(scossl_evp_nids[0]);
+static const int e_scossl_evp_nids_count = sizeof(e_scossl_evp_nids) / sizeof(e_scossl_evp_nids[0]);
 
 
 
@@ -34,7 +34,7 @@ static int (*_openssl_pkey_rsa_verify) (EVP_PKEY_CTX *ctx, const unsigned char *
                                         const unsigned char *tbs, size_t tbslen) = NULL;
 
 // Call SymCrypt engine sign if PSS padding, otherwise OpenSSL version.
-static int scossl_pkey_rsa_sign(_Inout_ EVP_PKEY_CTX *ctx, _Out_writes_bytes_(*siglen) unsigned char *sig,
+static int e_scossl_pkey_rsa_sign(_Inout_ EVP_PKEY_CTX *ctx, _Out_writes_bytes_(*siglen) unsigned char *sig,
                                     _Out_ size_t *siglen, _In_reads_bytes_(tbslen) const unsigned char *tbs, size_t tbslen)
 {
     int padding;
@@ -48,14 +48,14 @@ static int scossl_pkey_rsa_sign(_Inout_ EVP_PKEY_CTX *ctx, _Out_writes_bytes_(*s
 
     if( padding == RSA_PKCS1_PSS_PADDING )
     {
-        return scossl_rsapss_sign(ctx, sig, siglen, tbs, tbslen);
+        return e_scossl_rsapss_sign(ctx, sig, siglen, tbs, tbslen);
     }
 
     return _openssl_pkey_rsa_sign(ctx, sig, siglen, tbs, tbslen);
 }
 
 // Call SymCrypt engine RSA-PSS verify, unless auto salt-length specified (not yet supported by SymCrypt)
-static int scossl_pkey_rsapss_verify(_Inout_ EVP_PKEY_CTX *ctx, _In_reads_bytes_(siglen) const unsigned char *sig, size_t siglen,
+static int e_scossl_pkey_rsapss_verify(_Inout_ EVP_PKEY_CTX *ctx, _In_reads_bytes_(siglen) const unsigned char *sig, size_t siglen,
                                       _In_reads_bytes_(tbslen) const unsigned char *tbs, size_t tbslen)
 {
     int cbSalt = RSA_PSS_SALTLEN_DIGEST;
@@ -68,7 +68,7 @@ static int scossl_pkey_rsapss_verify(_Inout_ EVP_PKEY_CTX *ctx, _In_reads_bytes_
     }
     if( cbSalt != RSA_PSS_SALTLEN_AUTO )
     {
-        return scossl_rsapss_verify(ctx, sig, siglen, tbs, tbslen);
+        return e_scossl_rsapss_verify(ctx, sig, siglen, tbs, tbslen);
     }
     SCOSSL_LOG_INFO(SCOSSL_ERR_F_PKEY_RSA_VERIFY, SCOSSL_ERR_R_OPENSSL_FALLBACK,
         "SymCrypt Engine does not support RSA_PSS_SALTLEN_AUTO saltlen - falling back to OpenSSL");
@@ -77,7 +77,7 @@ static int scossl_pkey_rsapss_verify(_Inout_ EVP_PKEY_CTX *ctx, _In_reads_bytes_
 }
 
 // Call SymCrypt engine verify if PSS padding, otherwise OpenSSL version.
-static int scossl_pkey_rsa_verify(_Inout_ EVP_PKEY_CTX *ctx, _In_reads_bytes_(siglen) const unsigned char *sig, size_t siglen,
+static int e_scossl_pkey_rsa_verify(_Inout_ EVP_PKEY_CTX *ctx, _In_reads_bytes_(siglen) const unsigned char *sig, size_t siglen,
                                     _In_reads_bytes_(tbslen) const unsigned char *tbs, size_t tbslen)
 {
     int padding;
@@ -91,16 +91,16 @@ static int scossl_pkey_rsa_verify(_Inout_ EVP_PKEY_CTX *ctx, _In_reads_bytes_(si
 
     if( padding == RSA_PKCS1_PSS_PADDING )
     {
-        return scossl_pkey_rsapss_verify(ctx, sig, siglen, tbs, tbslen);
+        return e_scossl_pkey_rsapss_verify(ctx, sig, siglen, tbs, tbslen);
     }
 
     return _openssl_pkey_rsa_verify(ctx, sig, siglen, tbs, tbslen);
 }
 
-static EVP_PKEY_METHOD *_scossl_pkey_rsa = NULL;
+static EVP_PKEY_METHOD *_e_scossl_pkey_rsa = NULL;
 
 // Creates and returns the internal RSA method structure holding methods for RSA functions
-static EVP_PKEY_METHOD *scossl_pkey_rsa(void)
+static EVP_PKEY_METHOD *e_scossl_pkey_rsa(void)
 {
     int (*psign_init) (EVP_PKEY_CTX *ctx) = NULL;
     int (*pverify_init) (EVP_PKEY_CTX *ctx) = NULL;
@@ -108,27 +108,27 @@ static EVP_PKEY_METHOD *scossl_pkey_rsa(void)
 
     EVP_PKEY_meth_get0_info( NULL, &flags, _openssl_pkey_rsa );
 
-    if( (_scossl_pkey_rsa = EVP_PKEY_meth_new(EVP_PKEY_RSA, flags)) != NULL )
+    if( (_e_scossl_pkey_rsa = EVP_PKEY_meth_new(EVP_PKEY_RSA, flags)) != NULL )
     {
         // start with the default openssl method
-        EVP_PKEY_meth_copy(_scossl_pkey_rsa, _openssl_pkey_rsa);
+        EVP_PKEY_meth_copy(_e_scossl_pkey_rsa, _openssl_pkey_rsa);
 
         // overwrite the sign and verify methods
         // we just want to use the pss method if pss padding is specified
-        EVP_PKEY_meth_get_sign(_scossl_pkey_rsa, &psign_init, &_openssl_pkey_rsa_sign);
-        EVP_PKEY_meth_get_verify(_scossl_pkey_rsa, &pverify_init, &_openssl_pkey_rsa_verify);
+        EVP_PKEY_meth_get_sign(_e_scossl_pkey_rsa, &psign_init, &_openssl_pkey_rsa_sign);
+        EVP_PKEY_meth_get_verify(_e_scossl_pkey_rsa, &pverify_init, &_openssl_pkey_rsa_verify);
 
-        EVP_PKEY_meth_set_sign(_scossl_pkey_rsa, psign_init, scossl_pkey_rsa_sign);
-        EVP_PKEY_meth_set_verify(_scossl_pkey_rsa, pverify_init, scossl_pkey_rsa_verify);
+        EVP_PKEY_meth_set_sign(_e_scossl_pkey_rsa, psign_init, e_scossl_pkey_rsa_sign);
+        EVP_PKEY_meth_set_verify(_e_scossl_pkey_rsa, pverify_init, e_scossl_pkey_rsa_verify);
     }
-    return _scossl_pkey_rsa;
+    return _e_scossl_pkey_rsa;
 }
 
 static const EVP_PKEY_METHOD *_openssl_pkey_rsa_pss = NULL;
-static EVP_PKEY_METHOD *_scossl_pkey_rsa_pss = NULL;
+static EVP_PKEY_METHOD *_e_scossl_pkey_rsa_pss = NULL;
 
 // Creates and returns the internal RSA PSS method structure holding methods for RSA PSS functions
-static EVP_PKEY_METHOD *scossl_pkey_rsa_pss(void)
+static EVP_PKEY_METHOD *e_scossl_pkey_rsa_pss(void)
 {
     int (*psign_init) (EVP_PKEY_CTX *ctx) = NULL;
     int (*psign) (EVP_PKEY_CTX *ctx, unsigned char *sig, size_t *siglen, const unsigned char *tbs, size_t tbslen) = NULL;
@@ -138,26 +138,26 @@ static EVP_PKEY_METHOD *scossl_pkey_rsa_pss(void)
 
     EVP_PKEY_meth_get0_info( NULL, &flags, _openssl_pkey_rsa_pss );
 
-    if( (_scossl_pkey_rsa_pss = EVP_PKEY_meth_new(EVP_PKEY_RSA_PSS, flags)) != NULL )
+    if( (_e_scossl_pkey_rsa_pss = EVP_PKEY_meth_new(EVP_PKEY_RSA_PSS, flags)) != NULL )
     {
         // start with the default openssl method
-        EVP_PKEY_meth_copy(_scossl_pkey_rsa_pss, _openssl_pkey_rsa_pss);
+        EVP_PKEY_meth_copy(_e_scossl_pkey_rsa_pss, _openssl_pkey_rsa_pss);
 
         // overwrite the sign and verify methods specifically
-        EVP_PKEY_meth_get_sign(_scossl_pkey_rsa_pss, &psign_init, &psign);
-        EVP_PKEY_meth_get_verify(_scossl_pkey_rsa_pss, &pverify_init, &pverify);
+        EVP_PKEY_meth_get_sign(_e_scossl_pkey_rsa_pss, &psign_init, &psign);
+        EVP_PKEY_meth_get_verify(_e_scossl_pkey_rsa_pss, &pverify_init, &pverify);
 
-        EVP_PKEY_meth_set_sign(_scossl_pkey_rsa_pss, psign_init, scossl_rsapss_sign);
-        EVP_PKEY_meth_set_verify(_scossl_pkey_rsa_pss, pverify_init, scossl_pkey_rsapss_verify);
+        EVP_PKEY_meth_set_sign(_e_scossl_pkey_rsa_pss, psign_init, e_scossl_rsapss_sign);
+        EVP_PKEY_meth_set_verify(_e_scossl_pkey_rsa_pss, pverify_init, e_scossl_pkey_rsapss_verify);
     }
-    return _scossl_pkey_rsa_pss;
+    return _e_scossl_pkey_rsa_pss;
 }
 
 static const EVP_PKEY_METHOD *_openssl_pkey_tls1_prf = NULL;
-static EVP_PKEY_METHOD *_scossl_pkey_tls1_prf = NULL;
+static EVP_PKEY_METHOD *_e_scossl_pkey_tls1_prf = NULL;
 
 // Creates and returns the internal TLS1 PRF method structure holding methods for TLS1 PRF functions
-static EVP_PKEY_METHOD *scossl_pkey_tls1_prf(void)
+static EVP_PKEY_METHOD *e_scossl_pkey_tls1_prf(void)
 {
     int (*pctrl) (EVP_PKEY_CTX *ctx, int type, int p1, void *p2) = NULL;
     int (*pctrl_str) (EVP_PKEY_CTX *ctx, const char *type, const char *value) = NULL;
@@ -165,24 +165,24 @@ static EVP_PKEY_METHOD *scossl_pkey_tls1_prf(void)
 
     EVP_PKEY_meth_get0_info( NULL, &flags, _openssl_pkey_tls1_prf );
 
-    if((_scossl_pkey_tls1_prf = EVP_PKEY_meth_new(EVP_PKEY_TLS1_PRF, flags)) != NULL)
+    if((_e_scossl_pkey_tls1_prf = EVP_PKEY_meth_new(EVP_PKEY_TLS1_PRF, flags)) != NULL)
     {
         // Use the default ctrl_str implementation, internally calls our ctrl method
         EVP_PKEY_meth_get_ctrl(_openssl_pkey_tls1_prf, &pctrl, &pctrl_str);
 
-        EVP_PKEY_meth_set_init(_scossl_pkey_tls1_prf, scossl_tls1prf_init);
-        EVP_PKEY_meth_set_cleanup(_scossl_pkey_tls1_prf, scossl_tls1prf_cleanup);
-        EVP_PKEY_meth_set_derive(_scossl_pkey_tls1_prf, scossl_tls1prf_derive_init, scossl_tls1prf_derive);
-        EVP_PKEY_meth_set_ctrl(_scossl_pkey_tls1_prf, scossl_tls1prf_ctrl, pctrl_str);
+        EVP_PKEY_meth_set_init(_e_scossl_pkey_tls1_prf, e_scossl_tls1prf_init);
+        EVP_PKEY_meth_set_cleanup(_e_scossl_pkey_tls1_prf, e_scossl_tls1prf_cleanup);
+        EVP_PKEY_meth_set_derive(_e_scossl_pkey_tls1_prf, e_scossl_tls1prf_derive_init, e_scossl_tls1prf_derive);
+        EVP_PKEY_meth_set_ctrl(_e_scossl_pkey_tls1_prf, e_scossl_tls1prf_ctrl, pctrl_str);
     }
-    return _scossl_pkey_tls1_prf;
+    return _e_scossl_pkey_tls1_prf;
 }
 
 static const EVP_PKEY_METHOD *_openssl_pkey_hkdf = NULL;
-static EVP_PKEY_METHOD *_scossl_pkey_hkdf = NULL;
+static EVP_PKEY_METHOD *_e_scossl_pkey_hkdf = NULL;
 
 // Creates and returns the internal HKDF method structure holding methods for HKDF functions
-static EVP_PKEY_METHOD *scossl_pkey_hkdf(void)
+static EVP_PKEY_METHOD *e_scossl_pkey_hkdf(void)
 {
     int (*pctrl) (EVP_PKEY_CTX *ctx, int type, int p1, void *p2) = NULL;
     int (*pctrl_str) (EVP_PKEY_CTX *ctx, const char *type, const char *value) = NULL;
@@ -190,24 +190,24 @@ static EVP_PKEY_METHOD *scossl_pkey_hkdf(void)
 
     EVP_PKEY_meth_get0_info( NULL, &flags, _openssl_pkey_hkdf );
 
-    if((_scossl_pkey_hkdf = EVP_PKEY_meth_new(EVP_PKEY_HKDF, flags)) != NULL)
+    if((_e_scossl_pkey_hkdf = EVP_PKEY_meth_new(EVP_PKEY_HKDF, flags)) != NULL)
     {
         // Use the default ctrl_str implementation, internally calls our ctrl method
         EVP_PKEY_meth_get_ctrl(_openssl_pkey_hkdf, &pctrl, &pctrl_str);
 
-        EVP_PKEY_meth_set_init(_scossl_pkey_hkdf, scossl_hkdf_init);
-        EVP_PKEY_meth_set_cleanup(_scossl_pkey_hkdf, scossl_hkdf_cleanup);
-        EVP_PKEY_meth_set_derive(_scossl_pkey_hkdf, scossl_hkdf_derive_init, scossl_hkdf_derive);
-        EVP_PKEY_meth_set_ctrl(_scossl_pkey_hkdf, scossl_hkdf_ctrl, pctrl_str);
+        EVP_PKEY_meth_set_init(_e_scossl_pkey_hkdf, e_scossl_hkdf_init);
+        EVP_PKEY_meth_set_cleanup(_e_scossl_pkey_hkdf, e_scossl_hkdf_cleanup);
+        EVP_PKEY_meth_set_derive(_e_scossl_pkey_hkdf, e_scossl_hkdf_derive_init, e_scossl_hkdf_derive);
+        EVP_PKEY_meth_set_ctrl(_e_scossl_pkey_hkdf, e_scossl_hkdf_ctrl, pctrl_str);
     }
-    return _scossl_pkey_hkdf;
+    return _e_scossl_pkey_hkdf;
 }
 
 static const EVP_PKEY_METHOD *_openssl_pkey_hmac = NULL;
-static EVP_PKEY_METHOD *_scossl_pkey_hmac = NULL;
+static EVP_PKEY_METHOD *_e_scossl_pkey_hmac = NULL;
 
 // Creates and returns the internal HMAC method structure holding methods for HMAC functions
-static EVP_PKEY_METHOD *scossl_pkey_hmac(void)
+static EVP_PKEY_METHOD *e_scossl_pkey_hmac(void)
 {
     int (*pctrl) (EVP_PKEY_CTX *ctx, int type, int p1, void *p2) = NULL;
     int (*pctrl_str) (EVP_PKEY_CTX *ctx, const char *type, const char *value) = NULL;
@@ -215,28 +215,28 @@ static EVP_PKEY_METHOD *scossl_pkey_hmac(void)
 
     EVP_PKEY_meth_get0_info( NULL, &flags, _openssl_pkey_hmac );
 
-    if((_scossl_pkey_hmac = EVP_PKEY_meth_new(EVP_PKEY_HMAC, flags)) != NULL)
+    if((_e_scossl_pkey_hmac = EVP_PKEY_meth_new(EVP_PKEY_HMAC, flags)) != NULL)
     {
         // Use the default ctrl_str implementation, internally calls our ctrl method
         EVP_PKEY_meth_get_ctrl(_openssl_pkey_hmac, &pctrl, &pctrl_str);
 
-        EVP_PKEY_meth_set_init(_scossl_pkey_hmac, scossl_hmac_init);
-        EVP_PKEY_meth_set_cleanup(_scossl_pkey_hmac, scossl_hmac_cleanup);
-        EVP_PKEY_meth_set_copy(_scossl_pkey_hmac, scossl_hmac_copy);
-        EVP_PKEY_meth_set_ctrl(_scossl_pkey_hmac, scossl_hmac_ctrl, pctrl_str);
-        EVP_PKEY_meth_set_keygen(_scossl_pkey_hmac, NULL, scossl_hmac_keygen);
-        EVP_PKEY_meth_set_signctx(_scossl_pkey_hmac, scossl_hmac_signctx_init, scossl_hmac_signctx);
+        EVP_PKEY_meth_set_init(_e_scossl_pkey_hmac, e_scossl_hmac_init);
+        EVP_PKEY_meth_set_cleanup(_e_scossl_pkey_hmac, e_scossl_hmac_cleanup);
+        EVP_PKEY_meth_set_copy(_e_scossl_pkey_hmac, e_scossl_hmac_copy);
+        EVP_PKEY_meth_set_ctrl(_e_scossl_pkey_hmac, e_scossl_hmac_ctrl, pctrl_str);
+        EVP_PKEY_meth_set_keygen(_e_scossl_pkey_hmac, NULL, e_scossl_hmac_keygen);
+        EVP_PKEY_meth_set_signctx(_e_scossl_pkey_hmac, e_scossl_hmac_signctx_init, e_scossl_hmac_signctx);
     }
-    return _scossl_pkey_hmac;
+    return _e_scossl_pkey_hmac;
 }
 
-SCOSSL_STATUS scossl_pkey_methods_init_static()
+SCOSSL_STATUS e_scossl_pkey_methods_init_static()
 {
-    if( (scossl_pkey_rsa() == NULL) ||
-        (scossl_pkey_rsa_pss() == NULL) ||
-        (scossl_pkey_tls1_prf() == NULL) ||
-        (scossl_pkey_hkdf() == NULL) ||
-        (scossl_pkey_hmac() == NULL) 
+    if( (e_scossl_pkey_rsa() == NULL) ||
+        (e_scossl_pkey_rsa_pss() == NULL) ||
+        (e_scossl_pkey_tls1_prf() == NULL) ||
+        (e_scossl_pkey_hkdf() == NULL) ||
+        (e_scossl_pkey_hmac() == NULL) 
         )
     {
         return SCOSSL_FAILURE;
@@ -245,7 +245,7 @@ SCOSSL_STATUS scossl_pkey_methods_init_static()
 }
 
 _Success_(return > 0)
-int scossl_pkey_methods(_Inout_ ENGINE *e, _Out_opt_ EVP_PKEY_METHOD **pmeth,
+int e_scossl_pkey_methods(_Inout_ ENGINE *e, _Out_opt_ EVP_PKEY_METHOD **pmeth,
                                _Out_opt_ const int **nids, int nid)
 {
     int ok = 1;
@@ -262,27 +262,27 @@ int scossl_pkey_methods(_Inout_ ENGINE *e, _Out_opt_ EVP_PKEY_METHOD **pmeth,
     if( !pmeth )
     {
         /* We are returning a list of supported nids */
-        *nids = scossl_evp_nids;
-        return scossl_evp_nids_count;
+        *nids = e_scossl_evp_nids;
+        return e_scossl_evp_nids_count;
     }
 
     /* We are being asked for a specific pkey method */
     switch( nid )
     {
     case EVP_PKEY_RSA:
-        *pmeth = _scossl_pkey_rsa;
+        *pmeth = _e_scossl_pkey_rsa;
         break;
     case EVP_PKEY_RSA_PSS:
-        *pmeth = _scossl_pkey_rsa_pss;
+        *pmeth = _e_scossl_pkey_rsa_pss;
         break;
     case EVP_PKEY_TLS1_PRF:
-        *pmeth = _scossl_pkey_tls1_prf;
+        *pmeth = _e_scossl_pkey_tls1_prf;
         break;
     case EVP_PKEY_HKDF:
-        *pmeth = _scossl_pkey_hkdf;
+        *pmeth = _e_scossl_pkey_hkdf;
         break;
     case EVP_PKEY_HMAC:
-        *pmeth = _scossl_pkey_hmac;
+        *pmeth = _e_scossl_pkey_hmac;
         break;
     default:
         SCOSSL_LOG_ERROR(SCOSSL_ERR_F_PKEY_METHODS, SCOSSL_ERR_R_NOT_IMPLEMENTED,
@@ -294,23 +294,23 @@ int scossl_pkey_methods(_Inout_ ENGINE *e, _Out_opt_ EVP_PKEY_METHOD **pmeth,
     return ok;
 }
 
-void scossl_destroy_pkey_methods(void)
+void e_scossl_destroy_pkey_methods(void)
 {
     // It seems that explicitly freeing these methods in the destroy method causes a double free as
     // OpenSSL automatically frees pkey methods associated with an engine in destroying the engine
     // (seen in SslPlay with sanitizers on, or in OpenSSL applications using the engine)
     // For now just don't free these methods here, but keep an eye out for memory leaks
 
-    // EVP_PKEY_meth_free(_scossl_pkey_hmac);
-    // EVP_PKEY_meth_free(_scossl_pkey_hkdf);
-    // EVP_PKEY_meth_free(_scossl_pkey_tls1_prf);
-    // EVP_PKEY_meth_free(_scossl_pkey_rsa_pss);
-    // EVP_PKEY_meth_free(_scossl_pkey_rsa);
-    _scossl_pkey_hmac = NULL;
-    _scossl_pkey_hkdf = NULL;
-    _scossl_pkey_tls1_prf = NULL;
-    _scossl_pkey_rsa_pss = NULL;
-    _scossl_pkey_rsa = NULL;
+    // EVP_PKEY_meth_free(_e_scossl_pkey_hmac);
+    // EVP_PKEY_meth_free(_e_scossl_pkey_hkdf);
+    // EVP_PKEY_meth_free(_e_scossl_pkey_tls1_prf);
+    // EVP_PKEY_meth_free(_e_scossl_pkey_rsa_pss);
+    // EVP_PKEY_meth_free(_e_scossl_pkey_rsa);
+    _e_scossl_pkey_hmac = NULL;
+    _e_scossl_pkey_hkdf = NULL;
+    _e_scossl_pkey_tls1_prf = NULL;
+    _e_scossl_pkey_rsa_pss = NULL;
+    _e_scossl_pkey_rsa = NULL;
     _openssl_pkey_hmac = NULL;
     _openssl_pkey_hkdf = NULL;
     _openssl_pkey_tls1_prf = NULL;
diff --git a/SymCryptEngine/src/scossl_pkey_meths.h b/SymCryptEngine/src/scossl_pkey_meths.h
index 8b72655..b348f4b 100644
--- a/SymCryptEngine/src/scossl_pkey_meths.h
+++ b/SymCryptEngine/src/scossl_pkey_meths.h
@@ -3,7 +3,6 @@
 //
 
 #include "scossl.h"
-#include "scossl_helpers.h"
 #include <openssl/dh.h>
 
 #ifdef __cplusplus
@@ -11,17 +10,17 @@ extern "C" {
 #endif
 
 // Initialize all of the _hidden_* pkey method variables
-SCOSSL_STATUS scossl_pkey_methods_init_static();
+SCOSSL_STATUS e_scossl_pkey_methods_init_static();
 
 // Return a list of supported nids if pmeth is NULL, or a particular pkey
 // method in pmeth determined by nid. Returns number of supported nids in the first case.
 // Returns 1 on success in second case, or 0 on failure.
 _Success_(return > 0)
-int scossl_pkey_methods(_Inout_ ENGINE *e, _Out_opt_ EVP_PKEY_METHOD **pmeth,
+int e_scossl_pkey_methods(_Inout_ ENGINE *e, _Out_opt_ EVP_PKEY_METHOD **pmeth,
                                _Out_opt_ const int **nids, int nid);
 
 // Destroys internal methods
-void scossl_destroy_pkey_methods(void);
+void e_scossl_destroy_pkey_methods(void);
 
 #ifdef __cplusplus
 }
diff --git a/SymCryptEngine/src/scossl_rand.c b/SymCryptEngine/src/scossl_rand.c
index fa90de1..c816685 100644
--- a/SymCryptEngine/src/scossl_rand.c
+++ b/SymCryptEngine/src/scossl_rand.c
@@ -10,7 +10,7 @@ extern "C" {
 
 // RAND_seed() returns SCOSSL_SUCCESS on success, SCOSSL_FAILURE otherwise.
 // Since an error internally is fatal, we always return SCOSSL_SUCCESS here.
-static SCOSSL_STATUS scossl_rand_seed(_In_reads_bytes_(num) const void *buf, _In_ int num)
+static SCOSSL_STATUS e_scossl_rand_seed(_In_reads_bytes_(num) const void *buf, _In_ int num)
 {
     SymCryptProvideEntropy(buf, num);
     return SCOSSL_SUCCESS;
@@ -18,7 +18,7 @@ static SCOSSL_STATUS scossl_rand_seed(_In_reads_bytes_(num) const void *buf, _In
 
 // RAND_bytes() returns SCOSSL_SUCCESS on success, SCOSSL_FAILURE otherwise.
 // Since an error internally is fatal, we always return SCOSSL_SUCCESS here.
-static SCOSSL_STATUS scossl_rand_bytes(_Out_writes_bytes_(num) unsigned char *buf, _In_ int num)
+static SCOSSL_STATUS e_scossl_rand_bytes(_Out_writes_bytes_(num) unsigned char *buf, _In_ int num)
 {
     SymCryptRandom(buf, num);
     return SCOSSL_SUCCESS;
@@ -26,7 +26,7 @@ static SCOSSL_STATUS scossl_rand_bytes(_Out_writes_bytes_(num) unsigned char *bu
 
 // RAND_add() returns SCOSSL_SUCCESS on success, SCOSSL_FAILURE otherwise.
 // Since an error internally is fatal, we always return SCOSSL_SUCCESS here.
-static SCOSSL_STATUS scossl_rand_add(_In_reads_bytes_(num) const void *buf, _In_ int num, _In_ double randomness)
+static SCOSSL_STATUS e_scossl_rand_add(_In_reads_bytes_(num) const void *buf, _In_ int num, _In_ double randomness)
 {
     SymCryptProvideEntropy(buf, num);
     return SCOSSL_SUCCESS;
@@ -35,7 +35,7 @@ static SCOSSL_STATUS scossl_rand_add(_In_reads_bytes_(num) const void *buf, _In_
 // RAND_pseudo_bytes() returns SCOSSL_SUCCESS if the bytes generated are cryptographically strong,
 // SCOSSL_FAILURE otherwise.
 // Since an error internally is fatal, we always return SCOSSL_SUCCESS here.
-static SCOSSL_STATUS scossl_rand_pseudorand(_Out_writes_bytes_(num) unsigned char *buf, _In_ int num)
+static SCOSSL_STATUS e_scossl_rand_pseudorand(_Out_writes_bytes_(num) unsigned char *buf, _In_ int num)
 {
     SymCryptRandom(buf, num);
     return SCOSSL_SUCCESS;
@@ -44,23 +44,23 @@ static SCOSSL_STATUS scossl_rand_pseudorand(_Out_writes_bytes_(num) unsigned cha
 // RAND_status() returns SCOSSL_SUCCESS if the PRNG has been seeded with enough data, SCOSSL_FAILURE
 // otherwise.
 // Since we guarantee this, we return always return SCOSSL_SUCCESS here.
-static SCOSSL_STATUS scossl_rand_status(void)
+static SCOSSL_STATUS e_scossl_rand_status(void)
 {
     return SCOSSL_SUCCESS;
 }
 
-RAND_METHOD _scossl_rand_meth = {
-    scossl_rand_seed,
-    scossl_rand_bytes,
+RAND_METHOD _e_scossl_rand_meth = {
+    e_scossl_rand_seed,
+    e_scossl_rand_bytes,
     NULL,
-    scossl_rand_add,
-    scossl_rand_pseudorand,
-    scossl_rand_status
+    e_scossl_rand_add,
+    e_scossl_rand_pseudorand,
+    e_scossl_rand_status
 };
 
-RAND_METHOD *scossl_rand_method(void)
+RAND_METHOD *e_scossl_rand_method(void)
 {
-    return &_scossl_rand_meth;
+    return &_e_scossl_rand_meth;
 }
 
 #ifdef __cplusplus
diff --git a/SymCryptEngine/src/scossl_rand.h b/SymCryptEngine/src/scossl_rand.h
index 7f3cc9b..91c237f 100644
--- a/SymCryptEngine/src/scossl_rand.h
+++ b/SymCryptEngine/src/scossl_rand.h
@@ -3,14 +3,13 @@
 //
 
 #include "scossl.h"
-#include "scossl_helpers.h"
 #include <openssl/rand.h>
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-RAND_METHOD *scossl_rand_method(void);
+RAND_METHOD *e_scossl_rand_method(void);
 
 #ifdef __cplusplus
 }
diff --git a/SymCryptEngine/src/scossl_rsa.c b/SymCryptEngine/src/scossl_rsa.c
index 2900b86..3a55fdc 100644
--- a/SymCryptEngine/src/scossl_rsa.c
+++ b/SymCryptEngine/src/scossl_rsa.c
@@ -8,7 +8,7 @@
 extern "C" {
 #endif
 
-int scossl_rsa_idx = -1;
+int e_scossl_rsa_idx = -1;
 
 typedef int (*PFN_RSA_meth_pub_enc)(int flen, const unsigned char* from,
                          unsigned char* to, RSA* rsa,
@@ -37,7 +37,7 @@ typedef int (*PFN_RSA_meth_priv_dec)(int flen, const unsigned char *from,
 #define SCOSSL_SHA384_DIGEST_LENGTH (48)
 #define SCOSSL_SHA512_DIGEST_LENGTH (64)
 
-SCOSSL_RETURNLENGTH scossl_rsa_pub_enc(int flen, _In_reads_bytes_(flen) const unsigned char* from,
+SCOSSL_RETURNLENGTH e_scossl_rsa_pub_enc(int flen, _In_reads_bytes_(flen) const unsigned char* from,
     _Out_writes_bytes_(RSA_size(rsa)) unsigned char* to, _In_ RSA* rsa,
     int padding)
 {
@@ -47,7 +47,7 @@ SCOSSL_RETURNLENGTH scossl_rsa_pub_enc(int flen, _In_reads_bytes_(flen) const un
     int ret = -1;
     const RSA_METHOD *ossl_rsa_meth = NULL;
     PFN_RSA_meth_pub_enc pfn_rsa_meth_pub_enc = NULL;
-    SCOSSL_RSA_KEY_CONTEXT *keyCtx = RSA_get_ex_data(rsa, scossl_rsa_idx);
+    SCOSSL_RSA_KEY_CONTEXT *keyCtx = RSA_get_ex_data(rsa, e_scossl_rsa_idx);
 
     if( keyCtx == NULL )
     {
@@ -57,7 +57,7 @@ SCOSSL_RETURNLENGTH scossl_rsa_pub_enc(int flen, _In_reads_bytes_(flen) const un
     }
     if( keyCtx->initialized == 0 )
     {
-        if( scossl_initialize_rsa_key((RSA *)rsa, keyCtx) == 0 )
+        if( e_scossl_initialize_rsa_key((RSA *)rsa, keyCtx) == 0 )
         {
             goto cleanup;
         }
@@ -157,7 +157,7 @@ cleanup:
     return ret;
 }
 
-SCOSSL_RETURNLENGTH scossl_rsa_priv_dec(int flen, _In_reads_bytes_(flen) const unsigned char* from,
+SCOSSL_RETURNLENGTH e_scossl_rsa_priv_dec(int flen, _In_reads_bytes_(flen) const unsigned char* from,
     _Out_writes_bytes_(RSA_size(rsa)) unsigned char* to, _In_ RSA* rsa, int padding)
 {
     SYMCRYPT_ERROR scError = SYMCRYPT_NO_ERROR;
@@ -167,7 +167,7 @@ SCOSSL_RETURNLENGTH scossl_rsa_priv_dec(int flen, _In_reads_bytes_(flen) const u
     int ret = -1;
     const RSA_METHOD *ossl_rsa_meth = NULL;
     PFN_RSA_meth_priv_dec pfn_rsa_meth_priv_dec = NULL;
-    SCOSSL_RSA_KEY_CONTEXT *keyCtx = RSA_get_ex_data(rsa, scossl_rsa_idx);
+    SCOSSL_RSA_KEY_CONTEXT *keyCtx = RSA_get_ex_data(rsa, e_scossl_rsa_idx);
 
     if( keyCtx == NULL )
     {
@@ -177,7 +177,7 @@ SCOSSL_RETURNLENGTH scossl_rsa_priv_dec(int flen, _In_reads_bytes_(flen) const u
     }
     if( keyCtx->initialized == 0 )
     {
-        if( scossl_initialize_rsa_key((RSA *)rsa, keyCtx) == 0 )
+        if( e_scossl_initialize_rsa_key((RSA *)rsa, keyCtx) == 0 )
         {
             goto cleanup;
         }
@@ -277,7 +277,7 @@ cleanup:
     return ret;
 }
 
-SCOSSL_RETURNLENGTH scossl_rsa_priv_enc(int flen, _In_reads_bytes_(flen) const unsigned char* from,
+SCOSSL_RETURNLENGTH e_scossl_rsa_priv_enc(int flen, _In_reads_bytes_(flen) const unsigned char* from,
     _Out_writes_bytes_(RSA_size(rsa)) unsigned char* to, _In_ RSA* rsa, int padding)
 {
     SCOSSL_LOG_INFO(SCOSSL_ERR_F_RSA_PRIV_ENC, SCOSSL_ERR_R_OPENSSL_FALLBACK,
@@ -293,7 +293,7 @@ SCOSSL_RETURNLENGTH scossl_rsa_priv_enc(int flen, _In_reads_bytes_(flen) const u
     return pfn_rsa_meth_priv_enc(flen, from, to, rsa, padding);
 }
 
-SCOSSL_RETURNLENGTH scossl_rsa_pub_dec(int flen, _In_reads_bytes_(flen) const unsigned char* from,
+SCOSSL_RETURNLENGTH e_scossl_rsa_pub_dec(int flen, _In_reads_bytes_(flen) const unsigned char* from,
     _Out_writes_bytes_(RSA_size(rsa)) unsigned char* to, _In_ RSA* rsa,
     int padding)
 {
@@ -310,7 +310,7 @@ SCOSSL_RETURNLENGTH scossl_rsa_pub_dec(int flen, _In_reads_bytes_(flen) const un
     return pfn_rsa_meth_pub_dec(flen, from, to, rsa, padding);
 }
 
-SCOSSL_STATUS scossl_rsa_sign(int type, _In_reads_bytes_(m_length) const unsigned char* m, unsigned int m_length,
+SCOSSL_STATUS e_scossl_rsa_sign(int type, _In_reads_bytes_(m_length) const unsigned char* m, unsigned int m_length,
     _Out_writes_bytes_(siglen) unsigned char* sigret, _Out_ unsigned int* siglen,
     _In_ const RSA* rsa)
 {
@@ -318,7 +318,7 @@ SCOSSL_STATUS scossl_rsa_sign(int type, _In_reads_bytes_(m_length) const unsigne
     SIZE_T cbResult = 0;
     SCOSSL_STATUS ret = SCOSSL_FAILURE;
     SYMCRYPT_ERROR scError = SYMCRYPT_NO_ERROR;
-    SCOSSL_RSA_KEY_CONTEXT *keyCtx = RSA_get_ex_data(rsa, scossl_rsa_idx);
+    SCOSSL_RSA_KEY_CONTEXT *keyCtx = RSA_get_ex_data(rsa, e_scossl_rsa_idx);
 
     if( keyCtx == NULL )
     {
@@ -328,7 +328,7 @@ SCOSSL_STATUS scossl_rsa_sign(int type, _In_reads_bytes_(m_length) const unsigne
     }
     if( keyCtx->initialized == 0 )
     {
-        if( scossl_initialize_rsa_key((RSA *)rsa, keyCtx) == 0 )
+        if( e_scossl_initialize_rsa_key((RSA *)rsa, keyCtx) == 0 )
         {
             goto cleanup;
         }
@@ -476,14 +476,14 @@ cleanup:
     return ret;
 }
 
-SCOSSL_STATUS scossl_rsa_verify(int dtype, _In_reads_bytes_(m_length) const unsigned char* m,
+SCOSSL_STATUS e_scossl_rsa_verify(int dtype, _In_reads_bytes_(m_length) const unsigned char* m,
     unsigned int m_length,
     _In_reads_bytes_(siglen) const unsigned char* sigbuf,
     unsigned int siglen, _In_ const RSA* rsa)
 {
     SCOSSL_STATUS ret = SCOSSL_FAILURE;
     SYMCRYPT_ERROR scError = SYMCRYPT_NO_ERROR;
-    SCOSSL_RSA_KEY_CONTEXT *keyCtx = RSA_get_ex_data(rsa, scossl_rsa_idx);
+    SCOSSL_RSA_KEY_CONTEXT *keyCtx = RSA_get_ex_data(rsa, e_scossl_rsa_idx);
 
     if( keyCtx == NULL )
     {
@@ -493,7 +493,7 @@ SCOSSL_STATUS scossl_rsa_verify(int dtype, _In_reads_bytes_(m_length) const unsi
     }
     if( keyCtx->initialized == 0 )
     {
-        if( scossl_initialize_rsa_key((RSA *)rsa, keyCtx) == 0 )
+        if( e_scossl_initialize_rsa_key((RSA *)rsa, keyCtx) == 0 )
         {
             goto cleanup;
         }
@@ -629,7 +629,7 @@ cleanup:
     return ret;
 }
 
-SCOSSL_STATUS scossl_rsa_keygen(_Out_ RSA* rsa, int bits, _In_ BIGNUM* e,
+SCOSSL_STATUS e_scossl_rsa_keygen(_Out_ RSA* rsa, int bits, _In_ BIGNUM* e,
     _In_opt_ BN_GENCB* cb)
 {
     UINT64  pubExp64;
@@ -652,7 +652,7 @@ SCOSSL_STATUS scossl_rsa_keygen(_Out_ RSA* rsa, int bits, _In_ BIGNUM* e,
     SYMCRYPT_RSA_PARAMS SymcryptRsaParam;
     SYMCRYPT_ERROR scError = SYMCRYPT_NO_ERROR;
     int     ret = SCOSSL_FAILURE;
-    SCOSSL_RSA_KEY_CONTEXT *keyCtx = RSA_get_ex_data(rsa, scossl_rsa_idx);
+    SCOSSL_RSA_KEY_CONTEXT *keyCtx = RSA_get_ex_data(rsa, e_scossl_rsa_idx);
     BIGNUM *rsa_n = NULL;
     BIGNUM *rsa_e = NULL;
     BIGNUM *rsa_p = NULL;
@@ -670,7 +670,7 @@ SCOSSL_STATUS scossl_rsa_keygen(_Out_ RSA* rsa, int bits, _In_ BIGNUM* e,
     }
     if( keyCtx->initialized != 0 )
     {
-        scossl_rsa_free_key_context(keyCtx);
+        e_scossl_rsa_free_key_context(keyCtx);
     }
 
     SymcryptRsaParam.version = 1;               // Version of the parameters structure
@@ -832,7 +832,7 @@ SCOSSL_STATUS scossl_rsa_keygen(_Out_ RSA* rsa, int bits, _In_ BIGNUM* e,
 cleanup:
     if( ret != SCOSSL_SUCCESS )
     {
-        scossl_rsa_free_key_context(keyCtx);
+        e_scossl_rsa_free_key_context(keyCtx);
         BN_free(rsa_n);
         BN_free(rsa_e);
         BN_clear_free(rsa_p);
@@ -851,7 +851,7 @@ cleanup:
     return ret;
 }
 
-SCOSSL_STATUS scossl_initialize_rsa_key(_In_ RSA* rsa, _Out_ SCOSSL_RSA_KEY_CONTEXT *keyCtx)
+SCOSSL_STATUS e_scossl_initialize_rsa_key(_In_ RSA* rsa, _Out_ SCOSSL_RSA_KEY_CONTEXT *keyCtx)
 {
     int ret = SCOSSL_FAILURE;
     UINT64  pubExp64;
@@ -1001,8 +1001,8 @@ cleanup:
     if( ret != SCOSSL_SUCCESS )
     {
         SCOSSL_LOG_ERROR(SCOSSL_ERR_F_INITIALIZE_RSA_KEY, ERR_R_OPERATION_FAIL,
-            "scossl_initialize_rsa_key failed.");
-        scossl_rsa_free_key_context(keyCtx);
+            "e_scossl_initialize_rsa_key failed.");
+        e_scossl_rsa_free_key_context(keyCtx);
     }
 
     if( pbData )
@@ -1015,7 +1015,7 @@ cleanup:
 
 typedef int (*PFN_RSA_meth_mod_exp) (BIGNUM* r0, const BIGNUM* i, RSA* rsa, BN_CTX* ctx);
 
-SCOSSL_STATUS scossl_rsa_mod_exp(_Out_ BIGNUM* r0, _In_ const BIGNUM* i, _In_ RSA* rsa, _In_ BN_CTX* ctx)
+SCOSSL_STATUS e_scossl_rsa_mod_exp(_Out_ BIGNUM* r0, _In_ const BIGNUM* i, _In_ RSA* rsa, _In_ BN_CTX* ctx)
 {
     const RSA_METHOD* ossl_rsa_meth = RSA_PKCS1_OpenSSL();
     PFN_RSA_meth_mod_exp pfn_rsa_meth_mod_exp = RSA_meth_get_mod_exp(ossl_rsa_meth);
@@ -1030,7 +1030,7 @@ SCOSSL_STATUS scossl_rsa_mod_exp(_Out_ BIGNUM* r0, _In_ const BIGNUM* i, _In_ RS
 typedef int (*PFN_RSA_meth_bn_mod_exp) (
         BIGNUM* r, const BIGNUM* a, const BIGNUM* p, const BIGNUM* m, BN_CTX* ctx, BN_MONT_CTX* m_ctx);
 
-SCOSSL_STATUS scossl_rsa_bn_mod_exp(_Out_ BIGNUM* r, _In_ const BIGNUM* a, _In_ const BIGNUM* p,
+SCOSSL_STATUS e_scossl_rsa_bn_mod_exp(_Out_ BIGNUM* r, _In_ const BIGNUM* a, _In_ const BIGNUM* p,
         _In_ const BIGNUM* m, _In_ BN_CTX* ctx, _In_ BN_MONT_CTX* m_ctx)
 {
     const RSA_METHOD* ossl_rsa_meth = RSA_PKCS1_OpenSSL();
@@ -1042,7 +1042,7 @@ SCOSSL_STATUS scossl_rsa_bn_mod_exp(_Out_ BIGNUM* r, _In_ const BIGNUM* a, _In_
     return pfn_rsa_meth_bn_mod_exp(r, a, p, m, ctx, m_ctx);
 }
 
-SCOSSL_STATUS scossl_rsa_init(_Inout_ RSA *rsa)
+SCOSSL_STATUS e_scossl_rsa_init(_Inout_ RSA *rsa)
 {
     SCOSSL_RSA_KEY_CONTEXT *keyCtx = OPENSSL_zalloc(sizeof(*keyCtx));
     if( !keyCtx )
@@ -1052,7 +1052,7 @@ SCOSSL_STATUS scossl_rsa_init(_Inout_ RSA *rsa)
         return SCOSSL_FAILURE;
     }
 
-    if( RSA_set_ex_data(rsa, scossl_rsa_idx, keyCtx) == 0 )
+    if( RSA_set_ex_data(rsa, e_scossl_rsa_idx, keyCtx) == 0 )
     {
         SCOSSL_LOG_ERROR(SCOSSL_ERR_F_RSA_INIT, ERR_R_OPERATION_FAIL,
             "RSA_set_ex_data failed");
@@ -1063,7 +1063,7 @@ SCOSSL_STATUS scossl_rsa_init(_Inout_ RSA *rsa)
     return SCOSSL_SUCCESS;
 }
 
-void scossl_rsa_free_key_context(_In_ SCOSSL_RSA_KEY_CONTEXT *keyCtx)
+void e_scossl_rsa_free_key_context(_In_ SCOSSL_RSA_KEY_CONTEXT *keyCtx)
 {
     if( keyCtx->key )
     {
@@ -1074,17 +1074,17 @@ void scossl_rsa_free_key_context(_In_ SCOSSL_RSA_KEY_CONTEXT *keyCtx)
     return;
 }
 
-SCOSSL_STATUS scossl_rsa_finish(_Inout_ RSA *rsa)
+SCOSSL_STATUS e_scossl_rsa_finish(_Inout_ RSA *rsa)
 {
-    SCOSSL_RSA_KEY_CONTEXT *keyCtx = RSA_get_ex_data(rsa, scossl_rsa_idx);
+    SCOSSL_RSA_KEY_CONTEXT *keyCtx = RSA_get_ex_data(rsa, e_scossl_rsa_idx);
     if( keyCtx )
     {
         if( keyCtx->initialized == 1 )
         {
-            scossl_rsa_free_key_context(keyCtx);
+            e_scossl_rsa_free_key_context(keyCtx);
         }
         OPENSSL_free(keyCtx);
-        RSA_set_ex_data(rsa, scossl_rsa_idx, NULL);
+        RSA_set_ex_data(rsa, e_scossl_rsa_idx, NULL);
     }
     return SCOSSL_SUCCESS;
 }
diff --git a/SymCryptEngine/src/scossl_rsa.h b/SymCryptEngine/src/scossl_rsa.h
index 2e05562..f5e9815 100644
--- a/SymCryptEngine/src/scossl_rsa.h
+++ b/SymCryptEngine/src/scossl_rsa.h
@@ -3,14 +3,13 @@
 //
 
 #include "scossl.h"
-#include "scossl_helpers.h"
 #include <openssl/rsa.h>
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-extern int scossl_rsa_idx;
+extern int e_scossl_rsa_idx;
 
 // Public Encryption
 // Encrypts flen bytes at from using public key rsa and stores ciphertext in to.
@@ -20,7 +19,7 @@ extern int scossl_rsa_idx;
 // - from and to may overlap
 // - padding is ones of RSA_PKCS1_PADDING, RSA_PKCS1_OAEP_PADDING, RSA_SSLV23_PADDING, or RSA_NO_PADDING
 // Returns size of encrypted data (RSA_size(rsa)), or -1 on error
-SCOSSL_RETURNLENGTH scossl_rsa_pub_enc(int flen, _In_reads_bytes_(flen) const unsigned char* from,
+SCOSSL_RETURNLENGTH e_scossl_rsa_pub_enc(int flen, _In_reads_bytes_(flen) const unsigned char* from,
                          _Out_writes_bytes_(RSA_size(rsa)) unsigned char* to, _In_ RSA* rsa,
                          int padding);
 
@@ -31,38 +30,38 @@ SCOSSL_RETURNLENGTH scossl_rsa_pub_enc(int flen, _In_reads_bytes_(flen) const un
 // - from and to may overlap
 // - padding is the mode used to encrypt the data
 // Returns size of recovered plaintext, or -1 on error.
-SCOSSL_RETURNLENGTH scossl_rsa_priv_dec(int flen, _In_reads_bytes_(flen) const unsigned char* from,
+SCOSSL_RETURNLENGTH e_scossl_rsa_priv_dec(int flen, _In_reads_bytes_(flen) const unsigned char* from,
                           _Out_writes_bytes_(RSA_size(rsa)) unsigned char* to, _In_ RSA* rsa, int padding);
 
 // Private Encryption
 // Signs flen bytes at from using private key rsa and stores signature in to.
 // Returns size of signature, or -1 on error
-SCOSSL_RETURNLENGTH scossl_rsa_priv_enc(int flen, _In_reads_bytes_(flen) const unsigned char* from,
+SCOSSL_RETURNLENGTH e_scossl_rsa_priv_enc(int flen, _In_reads_bytes_(flen) const unsigned char* from,
                           _Out_writes_bytes_(RSA_size(rsa)) unsigned char* to, _In_ RSA* rsa, int padding);
 
 // Public Decryption
 // Recovers message digest from flen-bytes long signature at from using public key rsa and stores result in to.
 // Returns size of recovered message digest, or -1 on error.
-SCOSSL_RETURNLENGTH scossl_rsa_pub_dec(int flen, _In_reads_bytes_(flen) const unsigned char* from,
+SCOSSL_RETURNLENGTH e_scossl_rsa_pub_dec(int flen, _In_reads_bytes_(flen) const unsigned char* from,
                          _Out_writes_bytes_(RSA_size(rsa)) unsigned char* to, _In_ RSA* rsa,
                          int padding);
 
 // Used for CRT computations, used by default RSA implementations
 // ctx is a temporary BIGNUM variable
 // Returns SCOSSL_SUCCESS on success, or SCOSSL_FAILURE on error
-SCOSSL_STATUS scossl_rsa_mod_exp(_Out_ BIGNUM* r0, _In_ const BIGNUM* i, _In_ RSA* rsa, _In_ BN_CTX* ctx);
+SCOSSL_STATUS e_scossl_rsa_mod_exp(_Out_ BIGNUM* r0, _In_ const BIGNUM* i, _In_ RSA* rsa, _In_ BN_CTX* ctx);
 
 // Used for CRT computations, used by default RSA implementations
 // r = a ^ p mod m
 // ctx is a temporary BIGNUM variable, while m_ctx is a Montgomery multiplication structure
 // Returns SCOSSL_SUCCESS on success, or SCOSSL_FAILURE on error
-SCOSSL_STATUS scossl_rsa_bn_mod_exp(_Out_ BIGNUM* r, _In_ const BIGNUM* a, _In_ const BIGNUM* p,
+SCOSSL_STATUS e_scossl_rsa_bn_mod_exp(_Out_ BIGNUM* r, _In_ const BIGNUM* a, _In_ const BIGNUM* p,
                                       _In_ const BIGNUM* m, _In_ BN_CTX* ctx, _In_ BN_MONT_CTX* m_ctx);
 
 // Signs the message digest m of size m_len using private key rsa using PKCS1-v1_5 and stores signature in sigret and
 // signature size in siglen. Type denotes the message digest algorithm used to generate m.
 // Returns SCOSSL_SUCCESS on success, or SCOSSL_FAILURE on error
-SCOSSL_STATUS scossl_rsa_sign(int type, _In_reads_bytes_(m_length) const unsigned char* m, unsigned int m_length,
+SCOSSL_STATUS e_scossl_rsa_sign(int type, _In_reads_bytes_(m_length) const unsigned char* m, unsigned int m_length,
                                 _Out_writes_bytes_(siglen) unsigned char* sigret, _Out_ unsigned int* siglen,
                                 _In_ const RSA* rsa);
 
@@ -70,7 +69,7 @@ SCOSSL_STATUS scossl_rsa_sign(int type, _In_reads_bytes_(m_length) const unsigne
 // dtype denotes the message digest algorithm that was used to generate the signature. rsa is the signer's
 // public key.
 // Returns SCOSSL_SUCCESS on successful verification, or SCOSSL_FAILURE on error
-SCOSSL_STATUS scossl_rsa_verify(int dtype, _In_reads_bytes_(m_length) const unsigned char* m,
+SCOSSL_STATUS e_scossl_rsa_verify(int dtype, _In_reads_bytes_(m_length) const unsigned char* m,
                                   unsigned int m_length,
                                   _In_reads_bytes_(siglen) const unsigned char* sigbuf,
                                   unsigned int siglen, _In_ const RSA* rsa);
@@ -79,15 +78,15 @@ SCOSSL_STATUS scossl_rsa_verify(int dtype, _In_reads_bytes_(m_length) const unsi
 // the number of primes to form the modulus will be primes, and the public exponent will be e.
 // cb is an optional callback for progress of key generation that is unused in our implementation.
 // Returns SCOSSL_SUCCESS on success, or SCOSSL_FAILURE on error
-SCOSSL_STATUS scossl_rsa_keygen(_Out_ RSA* rsa, int bits, _In_ BIGNUM* e, _In_opt_ BN_GENCB* cb);
+SCOSSL_STATUS e_scossl_rsa_keygen(_Out_ RSA* rsa, int bits, _In_ BIGNUM* e, _In_opt_ BN_GENCB* cb);
 
 // Initializes a new RSA instance.
 // Returns SCOSSL_SUCCESS on success, or SCOSSL_FAILURE on error
-SCOSSL_STATUS scossl_rsa_init(_Inout_ RSA *rsa);
+SCOSSL_STATUS e_scossl_rsa_init(_Inout_ RSA *rsa);
 
 // Destroys instance of RSA object. The memory for rsa is not freed by this function.
 // Returns SCOSSL_SUCCESS on success, or SCOSSL_FAILURE on error
-SCOSSL_STATUS scossl_rsa_finish(_Inout_ RSA *rsa);
+SCOSSL_STATUS e_scossl_rsa_finish(_Inout_ RSA *rsa);
 
 typedef struct _SCOSSL_RSA_KEY_CONTEXT {
     int initialized;
@@ -96,10 +95,10 @@ typedef struct _SCOSSL_RSA_KEY_CONTEXT {
 
 // Initializes keyCtx from key rsa.
 // Returns SCOSSL_SUCCESS on success, or SCOSSL_FAILURE on error
-SCOSSL_STATUS scossl_initialize_rsa_key(_In_ RSA* rsa, _Out_ SCOSSL_RSA_KEY_CONTEXT *keyCtx);
+SCOSSL_STATUS e_scossl_initialize_rsa_key(_In_ RSA* rsa, _Out_ SCOSSL_RSA_KEY_CONTEXT *keyCtx);
 
 // Frees data and key of keyCtx
-void scossl_rsa_free_key_context(_In_ SCOSSL_RSA_KEY_CONTEXT *keyCtx);
+void e_scossl_rsa_free_key_context(_In_ SCOSSL_RSA_KEY_CONTEXT *keyCtx);
 
 #ifdef __cplusplus
 }
diff --git a/SymCryptEngine/src/scossl_rsapss.c b/SymCryptEngine/src/scossl_rsapss.c
index d178867..a39eb77 100644
--- a/SymCryptEngine/src/scossl_rsapss.c
+++ b/SymCryptEngine/src/scossl_rsapss.c
@@ -10,7 +10,7 @@
 extern "C" {
 #endif
 
-static PCSYMCRYPT_HASH scossl_get_symcrypt_hash_algorithm(int type)
+static PCSYMCRYPT_HASH e_scossl_get_symcrypt_hash_algorithm(int type)
 {
     if (type == NID_md5)
         return SymCryptMd5Algorithm;
@@ -27,7 +27,7 @@ static PCSYMCRYPT_HASH scossl_get_symcrypt_hash_algorithm(int type)
     return NULL;
 }
 
-static size_t scossl_get_expected_tbs_length(int type)
+static size_t e_scossl_get_expected_tbs_length(int type)
 {
     if (type == NID_md5)
         return 16;
@@ -44,7 +44,7 @@ static size_t scossl_get_expected_tbs_length(int type)
     return -1;
 }
 
-SCOSSL_STATUS scossl_rsapss_sign(_Inout_ EVP_PKEY_CTX *ctx, _Out_writes_opt_(*siglen) unsigned char *sig, _Out_ size_t *siglen,
+SCOSSL_STATUS e_scossl_rsapss_sign(_Inout_ EVP_PKEY_CTX *ctx, _Out_writes_opt_(*siglen) unsigned char *sig, _Out_ size_t *siglen,
                                     _In_reads_bytes_(tbslen) const unsigned char *tbs, size_t tbslen)
 {
     BN_ULONG cbModulus = 0;
@@ -54,7 +54,7 @@ SCOSSL_STATUS scossl_rsapss_sign(_Inout_ EVP_PKEY_CTX *ctx, _Out_writes_opt_(*si
     SYMCRYPT_ERROR scError = SYMCRYPT_NO_ERROR;
     int ret = SCOSSL_FAILURE;
     SCOSSL_RSA_KEY_CONTEXT *keyCtx = NULL;
-    PCSYMCRYPT_HASH scossl_mac_algo = NULL;
+    PCSYMCRYPT_HASH e_scossl_mac_algo = NULL;
     size_t expectedTbsLength = -1;
     EVP_MD *messageDigest;
     EVP_MD *mgf1Digest;
@@ -117,7 +117,7 @@ SCOSSL_STATUS scossl_rsapss_sign(_Inout_ EVP_PKEY_CTX *ctx, _Out_writes_opt_(*si
         return SCOSSL_UNSUPPORTED;
     }
 
-    keyCtx = RSA_get_ex_data(rsa, scossl_rsa_idx);
+    keyCtx = RSA_get_ex_data(rsa, e_scossl_rsa_idx);
     if( keyCtx == NULL )
     {
         SCOSSL_LOG_ERROR(SCOSSL_ERR_F_RSAPSS_SIGN, SCOSSL_ERR_R_MISSING_CTX_DATA,
@@ -126,7 +126,7 @@ SCOSSL_STATUS scossl_rsapss_sign(_Inout_ EVP_PKEY_CTX *ctx, _Out_writes_opt_(*si
     }
     if( keyCtx->initialized == 0 )
     {
-        if( scossl_initialize_rsa_key(rsa, keyCtx) == 0 )
+        if( e_scossl_initialize_rsa_key(rsa, keyCtx) == 0 )
         {
             return SCOSSL_UNSUPPORTED;
         }
@@ -144,9 +144,9 @@ SCOSSL_STATUS scossl_rsapss_sign(_Inout_ EVP_PKEY_CTX *ctx, _Out_writes_opt_(*si
         goto cleanup; // Not error - this can be called with NULL parameter for siglen
     }
 
-    scossl_mac_algo = scossl_get_symcrypt_hash_algorithm(type);
-    expectedTbsLength = scossl_get_expected_tbs_length(type);
-    if( !scossl_mac_algo || expectedTbsLength == (SIZE_T) -1 )
+    e_scossl_mac_algo = e_scossl_get_symcrypt_hash_algorithm(type);
+    expectedTbsLength = e_scossl_get_expected_tbs_length(type);
+    if( !e_scossl_mac_algo || expectedTbsLength == (SIZE_T) -1 )
     {
         SCOSSL_LOG_ERROR(SCOSSL_ERR_F_RSAPSS_SIGN, SCOSSL_ERR_R_NOT_IMPLEMENTED,
             "Unknown type: %d. Size: %d.", type, tbslen);
@@ -174,7 +174,7 @@ SCOSSL_STATUS scossl_rsapss_sign(_Inout_ EVP_PKEY_CTX *ctx, _Out_writes_opt_(*si
                 keyCtx->key,
                 tbs,
                 tbslen,
-                scossl_mac_algo,
+                e_scossl_mac_algo,
                 cbSalt,
                 0,
                 SYMCRYPT_NUMBER_FORMAT_MSB_FIRST,
@@ -194,7 +194,7 @@ cleanup:
     return ret;
 }
 
-SCOSSL_STATUS scossl_rsapss_verify(_Inout_ EVP_PKEY_CTX *ctx, _In_reads_bytes_(siglen) const unsigned char *sig, size_t siglen,
+SCOSSL_STATUS e_scossl_rsapss_verify(_Inout_ EVP_PKEY_CTX *ctx, _In_reads_bytes_(siglen) const unsigned char *sig, size_t siglen,
                                       _In_reads_bytes_(tbslen) const unsigned char *tbs, size_t tbslen)
 {
     EVP_PKEY* pkey = NULL;
@@ -202,7 +202,7 @@ SCOSSL_STATUS scossl_rsapss_verify(_Inout_ EVP_PKEY_CTX *ctx, _In_reads_bytes_(s
     int ret = SCOSSL_FAILURE;
     SYMCRYPT_ERROR scError = SYMCRYPT_NO_ERROR;
     SCOSSL_RSA_KEY_CONTEXT *keyCtx = NULL;
-    PCSYMCRYPT_HASH scossl_mac_algo = NULL;
+    PCSYMCRYPT_HASH e_scossl_mac_algo = NULL;
     size_t expectedTbsLength = -1;
     EVP_MD *messageDigest;
     EVP_MD *mgf1Digest;
@@ -271,7 +271,7 @@ SCOSSL_STATUS scossl_rsapss_verify(_Inout_ EVP_PKEY_CTX *ctx, _In_reads_bytes_(s
         return SCOSSL_UNSUPPORTED;
     }
 
-    keyCtx = RSA_get_ex_data(rsa, scossl_rsa_idx);
+    keyCtx = RSA_get_ex_data(rsa, e_scossl_rsa_idx);
     if( keyCtx == NULL )
     {
         SCOSSL_LOG_ERROR(SCOSSL_ERR_F_RSAPSS_VERIFY, SCOSSL_ERR_R_MISSING_CTX_DATA,
@@ -280,7 +280,7 @@ SCOSSL_STATUS scossl_rsapss_verify(_Inout_ EVP_PKEY_CTX *ctx, _In_reads_bytes_(s
     }
     if( keyCtx->initialized == 0 )
     {
-        if( scossl_initialize_rsa_key(rsa, keyCtx) == 0 )
+        if( e_scossl_initialize_rsa_key(rsa, keyCtx) == 0 )
         {
             return SCOSSL_UNSUPPORTED;
         }
@@ -291,9 +291,9 @@ SCOSSL_STATUS scossl_rsapss_verify(_Inout_ EVP_PKEY_CTX *ctx, _In_reads_bytes_(s
         goto cleanup;
     }
 
-    scossl_mac_algo = scossl_get_symcrypt_hash_algorithm(type);
-    expectedTbsLength = scossl_get_expected_tbs_length(type);
-    if( !scossl_mac_algo || expectedTbsLength == (SIZE_T) -1 )
+    e_scossl_mac_algo = e_scossl_get_symcrypt_hash_algorithm(type);
+    expectedTbsLength = e_scossl_get_expected_tbs_length(type);
+    if( !e_scossl_mac_algo || expectedTbsLength == (SIZE_T) -1 )
     {
         SCOSSL_LOG_ERROR(SCOSSL_ERR_F_RSAPSS_VERIFY, SCOSSL_ERR_R_NOT_IMPLEMENTED,
             "Unknown type: %d. Size: %d.", type, tbslen);
@@ -324,7 +324,7 @@ SCOSSL_STATUS scossl_rsapss_verify(_Inout_ EVP_PKEY_CTX *ctx, _In_reads_bytes_(s
                 sig,
                 siglen,
                 SYMCRYPT_NUMBER_FORMAT_MSB_FIRST,
-                scossl_mac_algo,
+                e_scossl_mac_algo,
                 cbSalt,
                 0);
 
diff --git a/SymCryptEngine/src/scossl_rsapss.h b/SymCryptEngine/src/scossl_rsapss.h
index 3b7cb1a..b3a61f7 100644
--- a/SymCryptEngine/src/scossl_rsapss.h
+++ b/SymCryptEngine/src/scossl_rsapss.h
@@ -3,7 +3,6 @@
 //
 
 #include "scossl.h"
-#include "scossl_helpers.h"
 
 #ifdef __cplusplus
 extern "C" {
@@ -12,12 +11,12 @@ extern "C" {
 // Signs tbs using key in ctx and stores signature and length in sig and siglen. NULL sig can be passed to get the
 // length needed for sig, returned in siglen.
 // Returns SCOSSL_SUCCESS on success, SCOSSL_FAILURE on failure, or a negative value when the operation is not supported
-SCOSSL_STATUS scossl_rsapss_sign(_Inout_ EVP_PKEY_CTX *ctx, _Out_writes_opt_(*siglen) unsigned char *sig, _Out_ size_t *siglen,
+SCOSSL_STATUS e_scossl_rsapss_sign(_Inout_ EVP_PKEY_CTX *ctx, _Out_writes_opt_(*siglen) unsigned char *sig, _Out_ size_t *siglen,
                                     _In_reads_bytes_(tbslen) const unsigned char *tbs, size_t tbslen);
 
 // Verifies signature sig for tbs.
 // Returns SCOSSL_SUCCESS on success, SCOSSL_FAILURE on failure, or a negative value when the operation is not supported
-SCOSSL_STATUS scossl_rsapss_verify(_Inout_ EVP_PKEY_CTX *ctx, _In_reads_bytes_(siglen) const unsigned char *sig, size_t siglen,
+SCOSSL_STATUS e_scossl_rsapss_verify(_Inout_ EVP_PKEY_CTX *ctx, _In_reads_bytes_(siglen) const unsigned char *sig, size_t siglen,
                                       _In_reads_bytes_(tbslen) const unsigned char *tbs, size_t tbslen);
 
 #ifdef __cplusplus
diff --git a/SymCryptEngine/src/scossl_sshkdf.c b/SymCryptEngine/src/scossl_sshkdf.c
index 750b467..8970a01 100644
--- a/SymCryptEngine/src/scossl_sshkdf.c
+++ b/SymCryptEngine/src/scossl_sshkdf.c
@@ -31,31 +31,31 @@ struct evp_kdf_impl_st {
 };
 
 
-EVP_KDF_IMPL* scossl_sshkdf_new()
+EVP_KDF_IMPL* e_scossl_sshkdf_new()
 {
     EVP_KDF_IMPL *impl = OPENSSL_zalloc(sizeof(*impl));
 
     if (!impl) {
         SCOSSL_LOG_ERROR(SCOSSL_ERR_F_SSHKDF_NEW, ERR_R_MALLOC_FAILURE,
             "OPENSSL_zalloc return NULL");
-    }    
-    
+    }
+
     return impl;
 }
 
-void scossl_sshkdf_reset(EVP_KDF_IMPL *impl)
+void e_scossl_sshkdf_reset(EVP_KDF_IMPL *impl)
 {
     OPENSSL_clear_free(impl->pbKey, impl->cbKey);
     memset(impl, 0, sizeof(*impl));
 }
 
-void scossl_sshkdf_free(EVP_KDF_IMPL *impl)
+void e_scossl_sshkdf_free(EVP_KDF_IMPL *impl)
 {
-    scossl_sshkdf_reset(impl);
+    e_scossl_sshkdf_reset(impl);
     OPENSSL_free(impl);
 }
 
-static PCSYMCRYPT_HASH scossl_get_symcrypt_hash_algorithm(const EVP_MD *md)
+static PCSYMCRYPT_HASH e_scossl_get_symcrypt_hash_algorithm(const EVP_MD *md)
 {
     int type = EVP_MD_type(md);
 
@@ -75,7 +75,7 @@ static PCSYMCRYPT_HASH scossl_get_symcrypt_hash_algorithm(const EVP_MD *md)
 }
 
 
-SCOSSL_STATUS scossl_sshkdf_ctrl(EVP_KDF_IMPL *impl, int cmd, va_list args)
+SCOSSL_STATUS e_scossl_sshkdf_ctrl(EVP_KDF_IMPL *impl, int cmd, va_list args)
 {
     SCOSSL_STATUS ret = SCOSSL_SUCCESS;
     const unsigned char *buffer;
@@ -89,7 +89,7 @@ SCOSSL_STATUS scossl_sshkdf_ctrl(EVP_KDF_IMPL *impl, int cmd, va_list args)
         case EVP_KDF_CTRL_SET_MD:
             md = va_arg(args, EVP_MD*);
 
-            impl->pHash = scossl_get_symcrypt_hash_algorithm(md);
+            impl->pHash = e_scossl_get_symcrypt_hash_algorithm(md);
 
             if(!impl->pHash) {
                 ret = SCOSSL_FAILURE;
@@ -165,21 +165,21 @@ SCOSSL_STATUS scossl_sshkdf_ctrl(EVP_KDF_IMPL *impl, int cmd, va_list args)
     return ret;
 }
 
-SCOSSL_STATUS scossl_sshkdf_call_ctrl(EVP_KDF_IMPL *impl, int cmd, ...)
+SCOSSL_STATUS e_scossl_sshkdf_call_ctrl(EVP_KDF_IMPL *impl, int cmd, ...)
 {
     SCOSSL_STATUS ret;
     va_list args;
 
     va_start(args, cmd);
 
-    ret = scossl_sshkdf_ctrl(impl, cmd, args);
+    ret = e_scossl_sshkdf_ctrl(impl, cmd, args);
 
     va_end(args);
-    
+
     return ret;
 }
 
-SCOSSL_STATUS scossl_sshkdf_ctrl_str(EVP_KDF_IMPL *impl, const char *type, const char *value)
+SCOSSL_STATUS e_scossl_sshkdf_ctrl_str(EVP_KDF_IMPL *impl, const char *type, const char *value)
 {
     SCOSSL_STATUS ret = SCOSSL_FAILURE;
     unsigned char *data;
@@ -188,40 +188,40 @@ SCOSSL_STATUS scossl_sshkdf_ctrl_str(EVP_KDF_IMPL *impl, const char *type, const
 
     if(strcmp(type, "digest") == 0 || strcmp(type, "md") == 0) {
         const EVP_MD *md = EVP_get_digestbyname(value);
-        ret = scossl_sshkdf_call_ctrl(impl, EVP_KDF_CTRL_SET_MD, md);
+        ret = e_scossl_sshkdf_call_ctrl(impl, EVP_KDF_CTRL_SET_MD, md);
     }
     else if(strcmp(type, "hexkey") == 0) {
         data = OPENSSL_hexstr2buf(value, &length);
         if(data) {
-            ret = scossl_sshkdf_call_ctrl(impl, EVP_KDF_CTRL_SET_KEY, data, length);
+            ret = e_scossl_sshkdf_call_ctrl(impl, EVP_KDF_CTRL_SET_KEY, data, length);
             OPENSSL_free(data);
         }
     }
     else if(strcmp(type, "hexxcghash") == 0) {
         data = OPENSSL_hexstr2buf(value, &length);
         if(data) {
-            ret = scossl_sshkdf_call_ctrl(impl, EVP_KDF_CTRL_SET_SSHKDF_XCGHASH, data, length);
+            ret = e_scossl_sshkdf_call_ctrl(impl, EVP_KDF_CTRL_SET_SSHKDF_XCGHASH, data, length);
             OPENSSL_free(data);
         }
     }
     else if(strcmp(type, "hexsession_id") == 0) {
         data = OPENSSL_hexstr2buf(value, &length);
         if(data) {
-            ret = scossl_sshkdf_call_ctrl(impl, EVP_KDF_CTRL_SET_SSHKDF_SESSION_ID, data, length);
+            ret = e_scossl_sshkdf_call_ctrl(impl, EVP_KDF_CTRL_SET_SSHKDF_SESSION_ID, data, length);
             OPENSSL_free(data);
         }
     }
     else if(strcmp(type, "type") == 0 && strlen(value) == 1) {
-        ret = scossl_sshkdf_call_ctrl(impl, EVP_KDF_CTRL_SET_SSHKDF_TYPE, (int)(*value));
+        ret = e_scossl_sshkdf_call_ctrl(impl, EVP_KDF_CTRL_SET_SSHKDF_TYPE, (int)(*value));
     }
     else if(strcmp(type, "key") == 0) {
-        ret = scossl_sshkdf_call_ctrl(impl, EVP_KDF_CTRL_SET_KEY, value, strlen(value));
+        ret = e_scossl_sshkdf_call_ctrl(impl, EVP_KDF_CTRL_SET_KEY, value, strlen(value));
     }
     else if(strcmp(type, "xcghash") == 0) {
-        ret = scossl_sshkdf_call_ctrl(impl, EVP_KDF_CTRL_SET_SSHKDF_XCGHASH, value, strlen(value));
+        ret = e_scossl_sshkdf_call_ctrl(impl, EVP_KDF_CTRL_SET_SSHKDF_XCGHASH, value, strlen(value));
     }
     else if(strcmp(type, "session_id") == 0) {
-        ret = scossl_sshkdf_call_ctrl(impl, EVP_KDF_CTRL_SET_SSHKDF_SESSION_ID, value, strlen(value));
+        ret = e_scossl_sshkdf_call_ctrl(impl, EVP_KDF_CTRL_SET_SSHKDF_SESSION_ID, value, strlen(value));
     }
     else {
         SCOSSL_LOG_ERROR(SCOSSL_ERR_F_SSHKDF_CTRL_STR, ERR_R_INTERNAL_ERROR,
@@ -231,15 +231,15 @@ SCOSSL_STATUS scossl_sshkdf_ctrl_str(EVP_KDF_IMPL *impl, const char *type, const
     return ret;
 }
 
-size_t scossl_sshkdf_size(EVP_KDF_IMPL *impl)
+size_t e_scossl_sshkdf_size(EVP_KDF_IMPL *impl)
 {
     return (size_t)-1;
 }
 
-SCOSSL_STATUS scossl_sshkdf_derive(EVP_KDF_IMPL *impl, unsigned char *out, size_t out_len)
+SCOSSL_STATUS e_scossl_sshkdf_derive(EVP_KDF_IMPL *impl, unsigned char *out, size_t out_len)
 {
     SCOSSL_STATUS ret = SCOSSL_SUCCESS;
-    SYMCRYPT_ERROR scError; 
+    SYMCRYPT_ERROR scError;
 
     if(!impl->pHash) {
         SCOSSL_LOG_ERROR(SCOSSL_ERR_F_SSHKDF_DERIVE, ERR_R_INTERNAL_ERROR,
@@ -261,7 +261,7 @@ SCOSSL_STATUS scossl_sshkdf_derive(EVP_KDF_IMPL *impl, unsigned char *out, size_
                             impl->label,
                             impl->pbSessionId, impl->cbSessionId,
                             out, out_len);
-                
+
     if(scError != SYMCRYPT_NO_ERROR) {
         SCOSSL_LOG_SYMCRYPT_ERROR(SCOSSL_ERR_F_SSHKDF_DERIVE, SCOSSL_ERR_R_SYMCRYPT_FAILURE,
             "SymCryptSshKdf failed", scError);
@@ -275,18 +275,18 @@ end:
 
 
 
-static EVP_KDF_METHOD scossl_sshkdf_meth = {
+static EVP_KDF_METHOD e_scossl_sshkdf_meth = {
     EVP_KDF_SSHKDF,
-    scossl_sshkdf_new,
-    scossl_sshkdf_free,
-    scossl_sshkdf_reset,
-    scossl_sshkdf_ctrl,
-    scossl_sshkdf_ctrl_str,
-    scossl_sshkdf_size,
-    scossl_sshkdf_derive,
+    e_scossl_sshkdf_new,
+    e_scossl_sshkdf_free,
+    e_scossl_sshkdf_reset,
+    e_scossl_sshkdf_ctrl,
+    e_scossl_sshkdf_ctrl_str,
+    e_scossl_sshkdf_size,
+    e_scossl_sshkdf_derive,
 };
 
-EVP_KDF_CTX* scossl_EVP_KDF_CTX_new_id(int id)
+EVP_KDF_CTX* e_scossl_EVP_KDF_CTX_new_id(int id)
 {
     EVP_KDF_CTX *ctx;
 
@@ -295,13 +295,13 @@ EVP_KDF_CTX* scossl_EVP_KDF_CTX_new_id(int id)
     }
 
     ctx = OPENSSL_zalloc(sizeof(*ctx));
-    
+
     if (!ctx) {
         return NULL;
     }
 
-    ctx->kmeth = &scossl_sshkdf_meth;
-    ctx->impl = scossl_sshkdf_meth.new();
+    ctx->kmeth = &e_scossl_sshkdf_meth;
+    ctx->impl = e_scossl_sshkdf_meth.new();
 
     return ctx;
 }
diff --git a/SymCryptEngine/src/scossl_sshkdf.h b/SymCryptEngine/src/scossl_sshkdf.h
index 237e644..5c62ffe 100644
--- a/SymCryptEngine/src/scossl_sshkdf.h
+++ b/SymCryptEngine/src/scossl_sshkdf.h
@@ -3,13 +3,12 @@
 //
 
 #include "scossl.h"
-#include "scossl_helpers.h"
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-EVP_KDF_CTX* scossl_EVP_KDF_CTX_new_id(int id);
+EVP_KDF_CTX* e_scossl_EVP_KDF_CTX_new_id(int id);
 
 #ifdef __cplusplus
 }
diff --git a/SymCryptEngine/src/scossl_tls1prf.c b/SymCryptEngine/src/scossl_tls1prf.c
index 7a8cc44..eadcc5d 100644
--- a/SymCryptEngine/src/scossl_tls1prf.c
+++ b/SymCryptEngine/src/scossl_tls1prf.c
@@ -23,7 +23,7 @@ typedef struct {
     size_t seed_length;
 } SCOSSL_TLS1_PRF_PKEY_CTX;
 
-SCOSSL_STATUS scossl_tls1prf_init(_Inout_ EVP_PKEY_CTX *ctx)
+SCOSSL_STATUS e_scossl_tls1prf_init(_Inout_ EVP_PKEY_CTX *ctx)
 {
     SCOSSL_TLS1_PRF_PKEY_CTX *key_context = NULL;
     if ((key_context = OPENSSL_zalloc(sizeof(*key_context))) == NULL) {
@@ -35,7 +35,7 @@ SCOSSL_STATUS scossl_tls1prf_init(_Inout_ EVP_PKEY_CTX *ctx)
     return SCOSSL_SUCCESS;
 }
 
-void scossl_tls1prf_cleanup(_Inout_ EVP_PKEY_CTX *ctx)
+void e_scossl_tls1prf_cleanup(_Inout_ EVP_PKEY_CTX *ctx)
 {
     SCOSSL_TLS1_PRF_PKEY_CTX *key_context = (SCOSSL_TLS1_PRF_PKEY_CTX *)EVP_PKEY_CTX_get_data(ctx);
     if (key_context == NULL) {
@@ -47,7 +47,7 @@ void scossl_tls1prf_cleanup(_Inout_ EVP_PKEY_CTX *ctx)
     EVP_PKEY_CTX_set_data(ctx, NULL);
 }
 
-SCOSSL_STATUS scossl_tls1prf_ctrl(_Inout_ EVP_PKEY_CTX *ctx, int type, int p1, _In_ void *p2)
+SCOSSL_STATUS e_scossl_tls1prf_ctrl(_Inout_ EVP_PKEY_CTX *ctx, int type, int p1, _In_ void *p2)
 {
     SCOSSL_TLS1_PRF_PKEY_CTX *key_context = (SCOSSL_TLS1_PRF_PKEY_CTX *)EVP_PKEY_CTX_get_data(ctx);
 
@@ -83,7 +83,7 @@ SCOSSL_STATUS scossl_tls1prf_ctrl(_Inout_ EVP_PKEY_CTX *ctx, int type, int p1, _
     }
 }
 
-SCOSSL_STATUS scossl_tls1prf_derive_init(_Inout_ EVP_PKEY_CTX *ctx)
+SCOSSL_STATUS e_scossl_tls1prf_derive_init(_Inout_ EVP_PKEY_CTX *ctx)
 {
     SCOSSL_TLS1_PRF_PKEY_CTX *key_context = (SCOSSL_TLS1_PRF_PKEY_CTX *)EVP_PKEY_CTX_get_data(ctx);
     OPENSSL_clear_free(key_context->secret, key_context->secret_length);
@@ -92,7 +92,7 @@ SCOSSL_STATUS scossl_tls1prf_derive_init(_Inout_ EVP_PKEY_CTX *ctx)
     return SCOSSL_SUCCESS;
 }
 
-static PCSYMCRYPT_MAC scossl_get_symcrypt_mac_algorithm(const EVP_MD *evp_md)
+static PCSYMCRYPT_MAC e_scossl_get_symcrypt_mac_algorithm(const EVP_MD *evp_md)
 {
     int type = EVP_MD_type(evp_md);
 
@@ -111,11 +111,11 @@ static PCSYMCRYPT_MAC scossl_get_symcrypt_mac_algorithm(const EVP_MD *evp_md)
     return NULL;
 }
 
-SCOSSL_STATUS scossl_tls1prf_derive(_Inout_ EVP_PKEY_CTX *ctx, _Out_writes_opt_(*keylen) unsigned char *key,
+SCOSSL_STATUS e_scossl_tls1prf_derive(_Inout_ EVP_PKEY_CTX *ctx, _Out_writes_opt_(*keylen) unsigned char *key,
                                         _Inout_ size_t *keylen)
 {
     SCOSSL_TLS1_PRF_PKEY_CTX *key_context = (SCOSSL_TLS1_PRF_PKEY_CTX *)EVP_PKEY_CTX_get_data(ctx);
-    PCSYMCRYPT_MAC scossl_mac_algo = NULL;
+    PCSYMCRYPT_MAC e_scossl_mac_algo = NULL;
     SYMCRYPT_ERROR scError = SYMCRYPT_NO_ERROR;
 
     if (key_context->md == NULL) {
@@ -143,14 +143,14 @@ SCOSSL_STATUS scossl_tls1prf_derive(_Inout_ EVP_PKEY_CTX *ctx, _Out_writes_opt_(
     }
     else
     {
-        scossl_mac_algo = scossl_get_symcrypt_mac_algorithm(key_context->md);
-        if( scossl_mac_algo == NULL )
+        e_scossl_mac_algo = e_scossl_get_symcrypt_mac_algorithm(key_context->md);
+        if( e_scossl_mac_algo == NULL )
         {
             return SCOSSL_FAILURE;
         }
 
         scError = SymCryptTlsPrf1_2(
-            scossl_mac_algo,
+            e_scossl_mac_algo,
             key_context->secret, key_context->secret_length,
             NULL, 0,
             key_context->seed, key_context->seed_length,
diff --git a/SymCryptEngine/src/scossl_tls1prf.h b/SymCryptEngine/src/scossl_tls1prf.h
index b06d3b7..098dbf4 100644
--- a/SymCryptEngine/src/scossl_tls1prf.h
+++ b/SymCryptEngine/src/scossl_tls1prf.h
@@ -3,7 +3,6 @@
 //
 
 #include "scossl.h"
-#include "scossl_helpers.h"
 
 #ifdef __cplusplus
 extern "C" {
@@ -11,25 +10,25 @@ extern "C" {
 
 // Allocate SymCrypt context inside of ctx.
 // Returns SCOSSL_SUCCESS on success or SCOSSL_FAILURE on error.
-SCOSSL_STATUS scossl_tls1prf_init(_Inout_ EVP_PKEY_CTX *ctx);
+SCOSSL_STATUS e_scossl_tls1prf_init(_Inout_ EVP_PKEY_CTX *ctx);
 
 // Frees SymCrypt context inside of ctx.
-void scossl_tls1prf_cleanup(_Inout_ EVP_PKEY_CTX *ctx);
+void e_scossl_tls1prf_cleanup(_Inout_ EVP_PKEY_CTX *ctx);
 
 // Sends a control operation to context ctx. type indicates which operation, and
 // p1 and p2 are optional parameters depending on which type is used.
 // Returns SCOSSL_SUCCESS on success, SCOSSL_FAILURE on error, or SCOSSL_UNSUPPORTED on not supported.
-SCOSSL_STATUS scossl_tls1prf_ctrl(_Inout_ EVP_PKEY_CTX *ctx, int type, int p1, _In_ void *p2);
+SCOSSL_STATUS e_scossl_tls1prf_ctrl(_Inout_ EVP_PKEY_CTX *ctx, int type, int p1, _In_ void *p2);
 
 // Initializes context ctx.
 // Returns SCOSSL_SUCCESS on success or SCOSSL_FAILURE on error.
-SCOSSL_STATUS scossl_tls1prf_derive_init(_Inout_ EVP_PKEY_CTX *ctx);
+SCOSSL_STATUS e_scossl_tls1prf_derive_init(_Inout_ EVP_PKEY_CTX *ctx);
 
 // Derives a shared secret using ctx. If key is NULL then the maximum size of the output buffer
 // is written to the keylen parameter. If key is not NULL, then keylen should contain the length of
 // the key buffer, the shared secret is written to key and the amount of data written to keylen.
 // Returns SCOSSL_SUCCESS on success, or SCOSSL_FAILURE on error.
-SCOSSL_STATUS scossl_tls1prf_derive(_Inout_ EVP_PKEY_CTX *ctx, _Out_writes_opt_(*keylen) unsigned char *key,
+SCOSSL_STATUS e_scossl_tls1prf_derive(_Inout_ EVP_PKEY_CTX *ctx, _Out_writes_opt_(*keylen) unsigned char *key,
                                         _Inout_ size_t *keylen);
 
 #ifdef __cplusplus
diff --git a/SymCryptEngine/static/CMakeLists.txt b/SymCryptEngine/static/CMakeLists.txt
index 297c281..ffc689e 100644
--- a/SymCryptEngine/static/CMakeLists.txt
+++ b/SymCryptEngine/static/CMakeLists.txt
@@ -6,13 +6,13 @@ set(DEFAULT_BUILD_TYPE "Release")
 
 include(GNUInstallDirs)
 
-set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wall -Wextra -Wno-unused-parameter -Wno-unknown-pragmas")
-set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++1y -Wall -Wextra -Wno-unused-parameter")
+set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wall -Wextra  -Wno-deprecated-declarations -Wno-unused-parameter -Wno-unknown-pragmas")
+set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++1y -Wall -Wextra  -Wno-deprecated-declarations -Wno-unused-parameter")
 
 find_package(OpenSSL REQUIRED)
 include_directories(${OPENSSL_INCLUDE_DIR})
 
-set(SCOSSL_SOURCES 
+set(SCOSSL_SOURCES
     ../src/scossl.c
     ../src/scossl_ciphers.c
     ../src/scossl_dh.c
@@ -26,7 +26,6 @@ set(SCOSSL_SOURCES
     ../src/scossl_hkdf.c
     ../src/scossl_tls1prf.c
     ../src/scossl_hmac.c
-    ../src/scossl_helpers.c
 )
 
 if (SCOSSL_SSHKDF)
@@ -37,12 +36,16 @@ endif()
 
 
 add_library(scossl_static STATIC ${SCOSSL_SOURCES})
+add_dependencies(scossl_static scossl_common)
 
 set_target_properties(scossl_static PROPERTIES PUBLIC_HEADER ../inc/scossl.h)
 # target_link_libraries(scossl_static ${OPENSSL_CRYPTO_LIBRARY})
 target_include_directories(scossl_static PUBLIC ../inc)
 target_include_directories(scossl_static PRIVATE ../src)
-target_include_directories (scossl_static PUBLIC ${CMAKE_CURRENT_SOURCE_DIR}/..)
+target_include_directories(scossl_static PUBLIC ${CMAKE_CURRENT_SOURCE_DIR}/..)
+target_include_directories(scossl_static PUBLIC ../ScosslCommon/inc)
+
+target_link_libraries(scossl_static PRIVATE scossl_common)
 
 install(TARGETS scossl_static
     EXCLUDE_FROM_ALL
diff --git a/SymCryptProvider/CMakeLists.txt b/SymCryptProvider/CMakeLists.txt
new file mode 100644
index 0000000..71bd4fe
--- /dev/null
+++ b/SymCryptProvider/CMakeLists.txt
@@ -0,0 +1,47 @@
+cmake_minimum_required(VERSION 3.13.0)
+
+project(scossl_provider)
+
+set(DEFAULT_BUILD_TYPE "Release")
+
+set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wall -Wextra -Wno-unused-parameter -Wno-unknown-pragmas")
+set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++1y -Wall -Wextra -Wno-unused-parameter")
+
+configure_file(
+    ${CMAKE_CURRENT_SOURCE_DIR}/inc/p_scossl_base.h.in
+    ${CMAKE_CURRENT_SOURCE_DIR}/inc/p_scossl_base.h)
+
+find_package(OpenSSL REQUIRED)
+include_directories(${OPENSSL_INCLUDE_DIR})
+
+find_library(SYMCRYPT_LIBRARY symcrypt PATHS ${CMAKE_SOURCE_DIR})
+
+set(SCOSSL_SOURCES
+    ./src/p_scossl_base.c
+    ./src/p_scossl_digests.c
+)
+
+add_library(scossl_provider SHARED ${SCOSSL_SOURCES})
+add_dependencies(scossl_provider scossl_common)
+
+set_target_properties(scossl_provider PROPERTIES PUBLIC_HEADER ./inc/p_scossl_base.h)
+target_include_directories(scossl_provider PUBLIC ./inc)
+target_include_directories(scossl_provider PRIVATE ./src)
+# target_include_directories(scossl_provider PUBLIC ${CMAKE_CURRENT_SOURCE_DIR})
+target_include_directories(scossl_provider PUBLIC ../ScosslCommon/inc)
+
+# Remove default "lib" prefix from symcryptprovider.so as OpenSSL provider is not a generic Linux .so
+set_target_properties(scossl_provider PROPERTIES PREFIX "")
+set_target_properties(scossl_provider PROPERTIES OUTPUT_NAME "symcryptprovider")
+
+target_link_libraries(scossl_provider PRIVATE scossl_common)
+target_link_libraries(scossl_provider PUBLIC ${SYMCRYPT_LIBRARY})
+target_link_libraries(scossl_provider PUBLIC ${OPENSSL_CRYPTO_LIBRARY})
+
+# Install the engine to the OpenSSL modules directory
+# NB: this won't work if the distro has a custom modules directory that doesn't match
+# the OpenSSL default.
+install(
+    TARGETS scossl_provider
+    LIBRARY DESTINATION "${CMAKE_INSTALL_LIBDIR}/ossl-modules"
+    PUBLIC_HEADER DESTINATION ${CMAKE_INSTALL_INCLUDEDIR})
\ No newline at end of file
diff --git a/SymCryptProvider/inc/p_scossl_base.h.in b/SymCryptProvider/inc/p_scossl_base.h.in
new file mode 100644
index 0000000..46d8cbf
--- /dev/null
+++ b/SymCryptProvider/inc/p_scossl_base.h.in
@@ -0,0 +1,31 @@
+//
+// Copyright (c) Microsoft Corporation. Licensed under the MIT license.
+//
+
+#include <openssl/core_names.h>
+#include <openssl/params.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+// Value provided by CMake, defined in top level CMakeLists.txt
+#define P_SCOSSL_VERSION "@SymCrypt-OpenSSL_VERSION@"
+#define P_SCOSSL_NAME "SymCrypt"
+
+typedef struct {
+    const OSSL_CORE_HANDLE *handle;
+} SCOSSL_PROVCTX, *PSCOSSL_PROVCTX;
+
+static const OSSL_PARAM p_scossl_param_types[] =
+{
+    OSSL_PARAM_DEFN(OSSL_PROV_PARAM_NAME, OSSL_PARAM_UTF8_PTR, NULL, 0),
+    OSSL_PARAM_DEFN(OSSL_PROV_PARAM_VERSION, OSSL_PARAM_UTF8_PTR, NULL, 0),
+    OSSL_PARAM_DEFN(OSSL_PROV_PARAM_BUILDINFO, OSSL_PARAM_UTF8_PTR, NULL, 0),
+    OSSL_PARAM_DEFN(OSSL_PROV_PARAM_STATUS, OSSL_PARAM_INTEGER, NULL, 0),
+    OSSL_PARAM_END
+};
+
+#ifdef __cplusplus
+}
+#endif
\ No newline at end of file
diff --git a/SymCryptProvider/src/p_scossl_base.c b/SymCryptProvider/src/p_scossl_base.c
new file mode 100644
index 0000000..9cab3bb
--- /dev/null
+++ b/SymCryptProvider/src/p_scossl_base.c
@@ -0,0 +1,265 @@
+//
+// Copyright (c) Microsoft Corporation. Licensed under the MIT license.
+//
+
+#include "p_scossl_base.h"
+
+#include "scossl_helpers.h"
+
+#include <openssl/core_dispatch.h>
+#include <openssl/err.h>
+#include <openssl/proverr.h>
+
+#include <symcrypt.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define ALG(names, funcs) {names, "provider="P_SCOSSL_NAME, funcs, NULL}
+#define ALG_TABLE_END { NULL, NULL, NULL, NULL}
+
+static int scossl_prov_initialized = 0;
+
+// Digest
+extern const OSSL_DISPATCH p_scossl_md5_functions[];
+extern const OSSL_DISPATCH p_scossl_sha1_functions[];
+extern const OSSL_DISPATCH p_scossl_sha256_functions[];
+extern const OSSL_DISPATCH p_scossl_sha384_functions[];
+extern const OSSL_DISPATCH p_scossl_sha512_functions[];
+extern const OSSL_DISPATCH p_scossl_sha3_256_functions[];
+extern const OSSL_DISPATCH p_scossl_sha3_384_functions[];
+extern const OSSL_DISPATCH p_scossl_sha3_512_functions[];
+
+static const OSSL_ALGORITHM p_scossl_digest[] = {
+    ALG("MD5:SSL3-MD5:1.2.840.113549.2.5", p_scossl_md5_functions),
+    ALG("SHA1:SHA-1:SSL3-SHA1:1.3.14.3.2.26", p_scossl_sha1_functions),
+    ALG("SHA2-256:SHA-256:SHA256:2.16.840.1.101.3.4.2.1", p_scossl_sha256_functions),
+    ALG("SHA2-384:SHA-384:SHA384:2.16.840.1.101.3.4.2.2", p_scossl_sha384_functions),
+    ALG("SHA2-512:SHA-512:SHA512:2.16.840.1.101.3.4.2.3", p_scossl_sha512_functions),
+    ALG("SHA3-256:2.16.840.1.101.3.4.2.8", p_scossl_sha3_256_functions),
+    ALG("SHA3-384:2.16.840.1.101.3.4.2.9", p_scossl_sha3_384_functions),
+    ALG("SHA3-512:2.16.840.1.101.3.4.2.10", p_scossl_sha3_512_functions),
+    ALG_TABLE_END
+};
+
+// Cipher
+extern const OSSL_DISPATCH p_scossl_aes128cbc_functions[];
+extern const OSSL_DISPATCH p_scossl_aes192cbc_functions[];
+extern const OSSL_DISPATCH p_scossl_aes256cbc_functions[];
+extern const OSSL_DISPATCH p_scossl_aes128ecb_functions[];
+extern const OSSL_DISPATCH p_scossl_aes192ecb_functions[];
+extern const OSSL_DISPATCH p_scossl_aes256ecb_functions[];
+extern const OSSL_DISPATCH p_scossl_aes128gcm_functions[];
+extern const OSSL_DISPATCH p_scossl_aes192gcm_functions[];
+extern const OSSL_DISPATCH p_scossl_aes256gcm_functions[];
+extern const OSSL_DISPATCH p_scossl_aes128ccm_functions[];
+extern const OSSL_DISPATCH p_scossl_aes192ccm_functions[];
+extern const OSSL_DISPATCH p_scossl_aes256ccm_functions[];
+extern const OSSL_DISPATCH p_scossl_aes256xts_functions[];
+extern const OSSL_DISPATCH p_scossl_aes128xts_functions[];
+
+static const OSSL_ALGORITHM p_scossl_cipher[] = {
+    // ALG("AES-128-CBC:AES128:2.16.840.1.101.3.4.1.2", p_scossl_aes128cbc_functions),
+    // ALG("AES-192-CBC:AES192:2.16.840.1.101.3.4.1.22", p_scossl_aes192cbc_functions),
+    // ALG("AES-256-CBC:AES256:2.16.840.1.101.3.4.1.42", p_scossl_aes256cbc_functions),
+    // ALG("AES-128-ECB:2.16.840.1.101.3.4.1.1", p_scossl_aes128ecb_functions),
+    // ALG("AES-192-ECB:2.16.840.1.101.3.4.1.21", p_scossl_aes192ecb_functions),
+    // ALG("AES-256-ECB:2.16.840.1.101.3.4.1.41", p_scossl_aes256ecb_functions),
+    // ALG("AES-128-GCM:id-aes128-GCM:2.16.840.1.101.3.4.1.6", p_scossl_aes128gcm_functions),
+    // ALG("AES-192-GCM:id-aes192-GCM:2.16.840.1.101.3.4.1.26", p_scossl_aes192gcm_functions),
+    // ALG("AES-256-GCM:id-aes256-GCM:2.16.840.1.101.3.4.1.46", p_scossl_aes256gcm_functions),
+    // ALG("AES-128-CCM:id-aes128-CCM:2.16.840.1.101.3.4.1.7", p_scossl_aes128ccm_functions),
+    // ALG("AES-192-CCM:id-aes192-CCM:2.16.840.1.101.3.4.1.27", p_scossl_aes192ccm_functions),
+    // ALG("AES-256-CCM:id-aes256-CCM:2.16.840.1.101.3.4.1.47", p_scossl_aes256ccm_functions),
+    // ALG("AES-128-XTS:1.3.111.2.1619.0.1.1", p_scossl_aes256xts_functions),
+    // ALG("AES-256-XTS:1.3.111.2.1619.0.1.2", p_scossl_aes128xts_functions),
+    ALG_TABLE_END
+};
+
+// MAC
+extern const OSSL_DISPATCH p_scossl_hmac_functions[];
+
+static const OSSL_ALGORITHM p_scossl_mac[] = {
+    // ALG("HMAC", p_scossl_hmac_functions),
+    ALG_TABLE_END
+};
+
+// KDF
+extern const OSSL_DISPATCH p_scossl_sshkdf_kdf_functions[];
+extern const OSSL_DISPATCH p_scossl_hkdf_kdf_functions[];
+extern const OSSL_DISPATCH p_scossl_tls1prf_kdf_functions[];
+
+static const OSSL_ALGORITHM p_scossl_kdf[] = {
+    // ALG("SSHKDF", p_scossl_sshkdf_kdf_functions),
+    // ALG("HKDF", p_scossl_hkdf_kdf_functions),
+    // ALG("TLS1-PRF", p_scossl_tls1prf_kdf_functions),
+    ALG_TABLE_END
+};
+
+// Rand
+extern const OSSL_DISPATCH p_scossl_rand_functions[];
+
+static const OSSL_ALGORITHM p_scossl_rand[] = {
+    // ALG("CTR-DRBG", p_scossl_rand_functions),
+    ALG_TABLE_END
+};
+
+// Key management
+extern const OSSL_DISPATCH p_scossl_dh_keymgmt_functions[];
+extern const OSSL_DISPATCH p_scossl_rsa_keymgmt_functions[];
+extern const OSSL_DISPATCH p_scossl_ecc_keymgmt_functions[];
+
+static const OSSL_ALGORITHM p_scossl_keymgmt[] = {
+    // ALG("DH:dhKeyAgreement:1.2.840.113549.1.3.1", p_scossl_dh_keymgmt_functions),
+    // ALG("RSA:rsaEncryption:1.2.840.113549.1.1.1:", p_scossl_rsa_keymgmt_functions),
+    // ALG("RSA-PSS:RSASSA-PSS:1.2.840.113549.1.1.10", p_scossl_rsa_keymgmt_functions),
+    // ALG("EC:id-ecPublicKey:1.2.840.10045.2.1", p_scossl_ecc_keymgmt_functions),
+    ALG_TABLE_END
+};
+
+// Key exchange
+extern const OSSL_DISPATCH p_scossl_dh_functions[];
+extern const OSSL_DISPATCH p_scossl_ecdh_functions[];
+extern const OSSL_DISPATCH p_scossl_x25519_functions[];
+extern const OSSL_DISPATCH p_scossl_hkdf_keyexch_functions[];
+extern const OSSL_DISPATCH p_scossl_tls1prf_keyexch_functions[];
+
+static const OSSL_ALGORITHM p_scossl_keyexch[] = {
+    // ALG("DH:dhKeyAgreement:1.2.840.113549.1.3.1", p_scossl_dh_functions),
+    // ALG("ECDH", p_scossl_ecdh_functions),
+    // ALG("X25519:1.3.101.110", p_scossl_x25519_functions),
+    // ALG("HKDF", p_scossl_hkdf_keyexch_functions),
+    // ALG("TLS1-PRF", p_scossl_tls1prf_keyexch_functions),
+    ALG_TABLE_END
+};
+
+// Signature
+extern const OSSL_DISPATCH p_scossl_rsa_signature_functions[];
+extern const OSSL_DISPATCH p_scossl_ecdsa_signature_functions[];
+
+static const OSSL_ALGORITHM p_scossl_signature[] = {
+    // ALG("RSA-PSS:RSASSA-PSS:1.2.840.113549.1.1.10", p_scossl_rsa_signature_functions),
+    // ALG("EC:id-ecPublicKey:1.2.840.10045.2.1", p_scossl_ecdsa_signature_functions),
+    ALG_TABLE_END
+};
+
+// Asymmetric Cipher
+extern const OSSL_DISPATCH p_scossl_rsa_asym_cipher_functions[];
+
+static const OSSL_ALGORITHM p_scossl_asym_cipher[] = {
+    // ALG("RSA-PSS:RSASSA-PSS:1.2.840.113549.1.1.10", p_scossl_rsa_asym_cipher_functions),
+    ALG_TABLE_END
+};
+
+static int p_scossl_get_status()
+{
+    return scossl_prov_initialized;
+}
+
+static void p_scossl_teardown(_Inout_ PSCOSSL_PROVCTX provctx)
+{
+    OPENSSL_free(provctx);
+}
+
+static const OSSL_PARAM *p_scossl_gettable_params(_Inout_ PSCOSSL_PROVCTX provctx)
+{
+    return p_scossl_param_types;
+}
+
+static int p_scossl_get_params(_Inout_ PSCOSSL_PROVCTX provctx, _Inout_ OSSL_PARAM params[])
+{
+    OSSL_PARAM *p;
+
+    p = OSSL_PARAM_locate(params, OSSL_PROV_PARAM_NAME);
+    if (p != NULL && !OSSL_PARAM_set_utf8_ptr(p, P_SCOSSL_NAME))
+    {
+        ERR_raise(ERR_LIB_PROV, PROV_R_FAILED_TO_SET_PARAMETER);
+        return 0;
+    }
+    p = OSSL_PARAM_locate(params, OSSL_PROV_PARAM_VERSION);
+    if (p != NULL && !OSSL_PARAM_set_utf8_ptr(p, P_SCOSSL_VERSION))
+    {
+        ERR_raise(ERR_LIB_PROV, PROV_R_FAILED_TO_SET_PARAMETER);
+        return 0;
+    }
+    p = OSSL_PARAM_locate(params, OSSL_PROV_PARAM_BUILDINFO);
+    if (p != NULL && !OSSL_PARAM_set_utf8_ptr(p, P_SCOSSL_VERSION))
+    {
+        ERR_raise(ERR_LIB_PROV, PROV_R_FAILED_TO_SET_PARAMETER);
+        return 0;
+    }
+    p = OSSL_PARAM_locate(params, OSSL_PROV_PARAM_STATUS);
+    if (p != NULL && !OSSL_PARAM_set_int(p, p_scossl_get_status()))
+    {
+        ERR_raise(ERR_LIB_PROV, PROV_R_FAILED_TO_SET_PARAMETER);
+        return 0;
+    }
+
+    return 1;
+}
+
+static const OSSL_ALGORITHM *p_scossl_query_operation(_Inout_ PSCOSSL_PROVCTX provctx, int operation_id, _Out_ int *no_store)
+{
+    // Dispatch tables do not change and may be cached
+    *no_store = 0;
+    switch (operation_id)
+    {
+        case OSSL_OP_DIGEST:
+            return p_scossl_digest;
+        case OSSL_OP_CIPHER:
+            return p_scossl_cipher;
+        case OSSL_OP_MAC:
+            return p_scossl_mac;
+        case OSSL_OP_KDF:
+            return p_scossl_kdf;
+        case OSSL_OP_RAND:
+            return p_scossl_rand;
+        case OSSL_OP_KEYMGMT:
+            return p_scossl_keymgmt;
+        case OSSL_OP_KEYEXCH:
+            return p_scossl_keyexch;
+        case OSSL_OP_SIGNATURE:
+            return p_scossl_signature;
+        case OSSL_OP_ASYM_CIPHER:
+            return p_scossl_asym_cipher;
+    }
+
+    return NULL;
+}
+
+static const OSSL_DISPATCH p_scossl_base_dispatch[] = {
+    {OSSL_FUNC_PROVIDER_TEARDOWN, (void (*)(void))p_scossl_teardown},
+    {OSSL_FUNC_PROVIDER_GETTABLE_PARAMS, (void (*)(void))p_scossl_gettable_params},
+    {OSSL_FUNC_PROVIDER_GET_PARAMS, (void (*)(void))p_scossl_get_params},
+    {OSSL_FUNC_PROVIDER_QUERY_OPERATION, (void (*)(void))p_scossl_query_operation},
+    {0, NULL}};
+
+SCOSSL_STATUS OSSL_provider_init(_In_ const OSSL_CORE_HANDLE *handle,
+                       _In_ const OSSL_DISPATCH *in,
+                       _Out_ const OSSL_DISPATCH **out,
+                       _Out_ void **provctx)
+{
+    PSCOSSL_PROVCTX p_ctx = OPENSSL_malloc(sizeof(SCOSSL_PROVCTX));
+    if (p_ctx != NULL)
+    {
+        p_ctx->handle = handle;
+        *provctx = p_ctx;
+    }
+
+    *out = p_scossl_base_dispatch;
+
+    if (!scossl_prov_initialized)
+    {
+        SYMCRYPT_MODULE_INIT();
+        scossl_prov_initialized = 1;
+    }
+
+    scossl_setup_logging();
+
+    return SCOSSL_SUCCESS;
+}
+
+#ifdef __cplusplus
+}
+#endif
\ No newline at end of file
diff --git a/SymCryptProvider/src/p_scossl_ciphers.h b/SymCryptProvider/src/p_scossl_ciphers.h
new file mode 100644
index 0000000..df93d7e
--- /dev/null
+++ b/SymCryptProvider/src/p_scossl_ciphers.h
@@ -0,0 +1,33 @@
+//
+// Copyright (c) Microsoft Corporation. Licensed under the MIT license.
+//
+
+#include <openssl/core_dispatch.h>
+#include "scossl_helpers.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+// Prototype definition, subject to change
+#define IMPLEMENT_SCOSSL_CIPHER_FUNCTIONS(alg, bits, mode)                                                \
+    const OSSL_DISPATCH p_scossl_##alg##kbits##mode##_functions[] = {                                  \
+        {OSSL_FUNC_CIPHER_NEWCTX, (void (*)(void))p_scossl_##alg##kbits##mode##_newctx},               \
+        {OSSL_FUNC_CIPHER_DUPCTX, (void (*)(void))p_scossl_##alg##kbits##mode##_dupctx},               \
+        {OSSL_FUNC_CIPHER_FREECTX, (void (*)(void))p_scossl_##alg##_##mode##_freectx},                 \
+        {OSSL_FUNC_CIPHER_ENCRYPT_INIT, (void (*)(void))p_scossl_##alg##mode##_encrypt_init},          \
+        {OSSL_FUNC_CIPHER_DECRYPT_INIT, (void (*)(void))p_scossl_##alg##mode##_decrypt_init},          \
+        {OSSL_FUNC_CIPHER_UPDATE, (void (*)(void))p_scossl_##alg##mode##_update},                      \
+        {OSSL_FUNC_CIPHER_FINAL, (void (*)(void))p_scossl_##alg##mode##_final},                        \
+        {OSSL_FUNC_CIPHER_CIPHER, (void (*)(void))p_scossl_##alg##mode##_cipher},                      \
+        {OSSL_FUNC_CIPHER_GET_PARAMS, (void (*)(void))p_scossl_##alg##_##kbits##_##mode##_get_params}, \
+        {OSSL_FUNC_CIPHER_GET_CTX_PARAMS, (void (*)(void))p_scossl_##mode##_get_ctx_params},           \
+        {OSSL_FUNC_CIPHER_SET_CTX_PARAMS, (void (*)(void))p_scossl_##mode##_set_ctx_params},           \
+        {OSSL_FUNC_CIPHER_GETTABLE_PARAMS, (void (*)(void))p_scossl_cipher_gettable_params},           \
+        {OSSL_FUNC_CIPHER_GETTABLE_CTX_PARAMS, (void (*)(void))p_scossl_cipher_gettable_ctx_params},   \
+        {OSSL_FUNC_CIPHER_SETTABLE_CTX_PARAMS, (void (*)(void))p_scossl_cipher_settable_ctx_params},   \
+        {0, NULL}};
+
+#ifdef __cplusplus
+}
+#endif
\ No newline at end of file
diff --git a/SymCryptProvider/src/p_scossl_digests.c b/SymCryptProvider/src/p_scossl_digests.c
new file mode 100644
index 0000000..968896b
--- /dev/null
+++ b/SymCryptProvider/src/p_scossl_digests.c
@@ -0,0 +1,54 @@
+//
+// Copyright (c) Microsoft Corporation. Licensed under the MIT license.
+//
+
+#include "p_scossl_digests.h"
+
+#include <openssl/core_names.h>
+#include <openssl/proverr.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+static const OSSL_PARAM p_scossl_digest_param_types[] = {
+    OSSL_PARAM_size_t(OSSL_DIGEST_PARAM_BLOCK_SIZE, NULL),
+    OSSL_PARAM_size_t(OSSL_DIGEST_PARAM_SIZE, NULL),
+    OSSL_PARAM_END};
+
+const OSSL_PARAM *p_scossl_digest_gettable_params(_Inout_ void *dctx, _In_ void *provctx)
+{
+    return p_scossl_digest_param_types;
+}
+
+SCOSSL_STATUS p_scossl_digest_get_params(_Inout_ OSSL_PARAM params[], size_t blocksize, size_t size)
+{
+    OSSL_PARAM *p = NULL;
+
+    p = OSSL_PARAM_locate(params, OSSL_DIGEST_PARAM_BLOCK_SIZE);
+    if (p != NULL && !OSSL_PARAM_set_size_t(p, blocksize))
+    {
+        ERR_raise(ERR_LIB_PROV, PROV_R_FAILED_TO_SET_PARAMETER);
+        return SCOSSL_FAILURE;
+    }
+    p = OSSL_PARAM_locate(params, OSSL_DIGEST_PARAM_SIZE);
+    if (p != NULL && !OSSL_PARAM_set_size_t(p, size))
+    {
+        ERR_raise(ERR_LIB_PROV, PROV_R_FAILED_TO_SET_PARAMETER);
+        return SCOSSL_FAILURE;
+    }
+    return SCOSSL_SUCCESS;
+}
+
+IMPLEMENT_SCOSSL_DIGEST(md5, Md5, MD5)
+IMPLEMENT_SCOSSL_DIGEST(sha1, Sha1, SHA1)
+IMPLEMENT_SCOSSL_DIGEST(sha256, Sha256, SHA256)
+IMPLEMENT_SCOSSL_DIGEST(sha384, Sha384, SHA384)
+IMPLEMENT_SCOSSL_DIGEST(sha512, Sha512, SHA512)
+IMPLEMENT_SCOSSL_DIGEST(sha3_256, Sha3_256, SHA3_256)
+IMPLEMENT_SCOSSL_DIGEST(sha3_384, Sha3_384, SHA3_384)
+IMPLEMENT_SCOSSL_DIGEST(sha3_512, Sha3_512, SHA3_512)
+
+#ifdef __cplusplus
+}
+#endif
\ No newline at end of file
diff --git a/SymCryptProvider/src/p_scossl_digests.h b/SymCryptProvider/src/p_scossl_digests.h
new file mode 100644
index 0000000..9c72296
--- /dev/null
+++ b/SymCryptProvider/src/p_scossl_digests.h
@@ -0,0 +1,103 @@
+//
+// Copyright (c) Microsoft Corporation. Licensed under the MIT license.
+//
+
+#include <openssl/core_dispatch.h>
+#include <openssl/params.h>
+#include "scossl_helpers.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+// lowercase, CamelCase, and UPPERCASE must be provided to reconcile differences
+// between OpenSSL and SymCrypt APIs and macro definitions
+#define IMPLEMENT_SCOSSL_DIGEST(lcalg, CcAlg, UCALG)                                  \
+    static void *p_scossl_##lcalg##_newctx(_Inout_ void *prov_ctx)                    \
+    {                                                                                 \
+        return OPENSSL_malloc(sizeof(SYMCRYPT_##UCALG##_STATE));                      \
+    }                                                                                 \
+    static void *p_scossl_##lcalg##_dupctx(_In_ SYMCRYPT_##UCALG##_STATE *dctx)       \
+    {                                                                                 \
+        SYMCRYPT_##UCALG##_STATE *copy_ctx =                                          \
+            OPENSSL_malloc(sizeof(SYMCRYPT_##UCALG##_STATE));                         \
+                                                                                      \
+        if (copy_ctx != NULL)                                                         \
+            SymCrypt##CcAlg##StateCopy(copy_ctx, dctx);                               \
+                                                                                      \
+        return copy_ctx;                                                              \
+    }                                                                                 \
+    static void p_scossl_##lcalg##_freectx(_Inout_ SYMCRYPT_##UCALG##_STATE *dctx)    \
+    {                                                                                 \
+        OPENSSL_clear_free(dctx, sizeof(SYMCRYPT_##UCALG##_STATE));                   \
+    }                                                                                 \
+    static SCOSSL_STATUS p_scossl_##lcalg##_init(                                     \
+        _Inout_ SYMCRYPT_##UCALG##_STATE *dctx,                                       \
+        _In_ const OSSL_PARAM params[])                                               \
+    {                                                                                 \
+        SymCrypt##CcAlg##Init(dctx);                                                  \
+        return SCOSSL_SUCCESS;                                                        \
+    }                                                                                 \
+    static SCOSSL_STATUS p_scossl_##lcalg##_update(                                   \
+        _Inout_ SYMCRYPT_##UCALG##_STATE *dctx,                                       \
+        _In_reads_bytes_(inl) const unsigned char *in,                                \
+        size_t inl)                                                                   \
+    {                                                                                 \
+        SymCrypt##CcAlg##Append(dctx, in, inl);                                       \
+        return SCOSSL_SUCCESS;                                                        \
+    }                                                                                 \
+    static SCOSSL_STATUS p_scossl_##lcalg##_final(                                    \
+        _Inout_ SYMCRYPT_##UCALG##_STATE *dctx,                                       \
+        _Out_writes_(SYMCRYPT_##UCALG##_RESULT_SIZE) unsigned char *out,              \
+        _Out_ size_t *outl, size_t outsz)                                             \
+    {                                                                                 \
+        if (outsz < SYMCRYPT_##UCALG##_RESULT_SIZE)                                   \
+        {                                                                             \
+            ERR_raise(ERR_LIB_PROV, PROV_R_OUTPUT_BUFFER_TOO_SMALL);                  \
+            return SCOSSL_FAILURE;                                                    \
+        }                                                                             \
+                                                                                      \
+        SymCrypt##CcAlg##Result(dctx, out);                                           \
+        *outl = SYMCRYPT_##UCALG##_RESULT_SIZE;                                       \
+        return SCOSSL_SUCCESS;                                                        \
+    }                                                                                 \
+    static SCOSSL_STATUS p_scossl_##lcalg##_digest(                                   \
+        _Inout_ void *provctx,                                                        \
+        _In_ const unsigned char *in, size_t inl,                                     \
+        _Out_writes_(SYMCRYPT_##UCALG##_RESULT_SIZE) unsigned char *out,              \
+        _Out_ size_t *outl, size_t outsz)                                             \
+    {                                                                                 \
+        if (outsz < SYMCRYPT_##UCALG##_RESULT_SIZE)                                   \
+        {                                                                             \
+            ERR_raise(ERR_LIB_PROV, PROV_R_OUTPUT_BUFFER_TOO_SMALL);                  \
+            return SCOSSL_FAILURE;                                                    \
+        }                                                                             \
+                                                                                      \
+        SymCrypt##CcAlg(in, inl, out);                                                \
+        *outl = SYMCRYPT_##UCALG##_RESULT_SIZE;                                       \
+        return SCOSSL_SUCCESS;                                                        \
+    }                                                                                 \
+    static SCOSSL_STATUS p_scossl_##lcalg##_get_params(_Inout_ OSSL_PARAM params[])   \
+    {                                                                                 \
+        return p_scossl_digest_get_params(params,                                     \
+                                          SYMCRYPT_##UCALG##_INPUT_BLOCK_SIZE,        \
+                                          SYMCRYPT_##UCALG##_RESULT_SIZE);            \
+    }                                                                                 \
+                                                                                      \
+    const OSSL_DISPATCH p_scossl_##lcalg##_functions[] = {                            \
+        {OSSL_FUNC_DIGEST_NEWCTX, (void (*)(void))p_scossl_##lcalg##_newctx},         \
+        {OSSL_FUNC_DIGEST_DUPCTX, (void (*)(void))p_scossl_##lcalg##_dupctx},         \
+        {OSSL_FUNC_DIGEST_FREECTX, (void (*)(void))p_scossl_##lcalg##_freectx},       \
+        {OSSL_FUNC_DIGEST_INIT, (void (*)(void))p_scossl_##lcalg##_init},             \
+        {OSSL_FUNC_DIGEST_UPDATE, (void (*)(void))p_scossl_##lcalg##_update},         \
+        {OSSL_FUNC_DIGEST_FINAL, (void (*)(void))p_scossl_##lcalg##_final},           \
+        {OSSL_FUNC_DIGEST_DIGEST, (void (*)(void))p_scossl_##lcalg##_digest},         \
+        {OSSL_FUNC_DIGEST_GET_PARAMS, (void (*)(void))p_scossl_##lcalg##_get_params}, \
+        {OSSL_FUNC_DIGEST_GETTABLE_PARAMS, (void (*)(void))p_scossl_digest_gettable_params}};
+
+const OSSL_PARAM *p_scossl_digest_gettable_params(_Inout_ void *dctx, _In_ void *provctx);
+SCOSSL_STATUS p_scossl_digest_get_params(_Inout_ OSSL_PARAM params[], size_t blocksize, size_t size);
+
+#ifdef __cplusplus
+}
+#endif
\ No newline at end of file
diff --git a/SymCryptProvider/src/p_scossl_kdfs.h b/SymCryptProvider/src/p_scossl_kdfs.h
new file mode 100644
index 0000000..caa7969
--- /dev/null
+++ b/SymCryptProvider/src/p_scossl_kdfs.h
@@ -0,0 +1,28 @@
+//
+// Copyright (c) Microsoft Corporation. Licensed under the MIT license.
+//
+
+#include <openssl/core_dispatch.h>
+#include "scossl_helpers.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+// Prototype definition, subject to change
+#define IMPLEMENT_SCOSSL_KDF_FUNCTIONS(alg)                                                               \
+    const OSSL_DISPATCH p_scossl_##alg##_kdf_functions = {                                             \
+        {OSSL_FUNC_KDF_NEWCTX, (void (*)(void))p_scossl_##alg##_kdf_new},                              \
+        {OSSL_FUNC_KDF_DUPCTX, (void (*)(void))p_scossl_##alg##_kdf_dup},                              \
+        {OSSL_FUNC_KDF_FREECTX, (void (*)(void))p_scossl_##alg##_kdf_free},                            \
+        {OSSL_FUNC_KDF_RESET, (void (*)(void))p_scossl_##alg##_kdf_reset},                             \
+        {OSSL_FUNC_KDF_DERIVE, (void (*)(void))p_scossl_##alg##_kdf_derive},                           \
+        {OSSL_FUNC_KDF_SETTABLE_CTX_PARAMS, (void (*)(void))p_scossl_##alg##_kdf_settable_ctx_params}, \
+        {OSSL_FUNC_KDF_SET_CTX_PARAMS, (void (*)(void))p_scossl_##alg##_kdf_set_ctx_params},           \
+        {OSSL_FUNC_KDF_GETTABLE_CTX_PARAMS, (void (*)(void))p_scossl_##alg##_kdf_gettable_ctx_params}, \
+        {OSSL_FUNC_KDF_GET_CTX_PARAMS, (void (*)(void))p_scossl_##alg##_kdf_get_ctx_params},           \
+        {0, NULL}};
+
+#ifdef __cplusplus
+}
+#endif
\ No newline at end of file
diff --git a/SymCryptProvider/src/p_scossl_keyexch.h b/SymCryptProvider/src/p_scossl_keyexch.h
new file mode 100644
index 0000000..0ea4279
--- /dev/null
+++ b/SymCryptProvider/src/p_scossl_keyexch.h
@@ -0,0 +1,29 @@
+//
+// Copyright (c) Microsoft Corporation. Licensed under the MIT license.
+//
+
+#include <openssl/core_dispatch.h>
+#include "scossl_helpers.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+// Prototype definition, subject to change
+#define IMPLEMENT_SCOSSL_KEYEXCH_FUNCTIONS(alg)                                                                   \
+    const OSSL_DISPATCH p_scossl_##alg##_keyexch_functions = {                                                 \
+        {OSSL_FUNC_KEYEXCH_NEWCTX, (void (*)(void))p_scossl_##alg##_keyexch_newctx},                           \
+        {OSSL_FUNC_KEYEXCH_INIT, (void (*)(void))p_scossl_##alg##_keyexch_init},                               \
+        {OSSL_FUNC_KEYEXCH_DERIVE, (void (*)(void))p_scossl_##alg##_keyexch_derive},                           \
+        {OSSL_FUNC_KEYEXCH_SET_PEER, (void (*)(void))p_scossl_##alg##_keyexch_set_peer},                       \
+        {OSSL_FUNC_KEYEXCH_FREECTX, (void (*)(void))p_scossl_##alg##_keyexch_freectx},                         \
+        {OSSL_FUNC_KEYEXCH_DUPCTX, (void (*)(void))p_scossl_##alg##_keyexch_dupctx},                           \
+        {OSSL_FUNC_KEYEXCH_SET_CTX_PARAMS, (void (*)(void))p_scossl_##alg##_keyexch_set_ctx_params},           \
+        {OSSL_FUNC_KEYEXCH_SETTABLE_CTX_PARAMS, (void (*)(void))p_scossl_##alg##_keyexch_settable_ctx_params}, \
+        {OSSL_FUNC_KEYEXCH_GET_CTX_PARAMS, (void (*)(void))p_scossl_##alg##_keyexch_get_ctx_params},           \
+        {OSSL_FUNC_KEYEXCH_GETTABLE_CTX_PARAMS, (void (*)(void))p_scossl_##alg##_keyexch_gettable_ctx_params}, \
+        {0, NULL}};
+
+#ifdef __cplusplus
+}
+#endif
\ No newline at end of file
diff --git a/SymCryptProvider/src/p_scossl_keymgmt.h b/SymCryptProvider/src/p_scossl_keymgmt.h
new file mode 100644
index 0000000..c1d9017
--- /dev/null
+++ b/SymCryptProvider/src/p_scossl_keymgmt.h
@@ -0,0 +1,41 @@
+//
+// Copyright (c) Microsoft Corporation. Licensed under the MIT license.
+//
+
+#include <openssl/core_dispatch.h>
+#include "scossl_helpers.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+// Prototype definitions, subject to change
+#define IMPLEMENT_SCOSSL_KEYMGMT_FUNCTIONS(alg)                                                           \
+    const OSSL_DISPATCH p_scossl_##alg##_keymgmt_functions[] = {                                       \
+        {OSSL_FUNC_KEYMGMT_FREE, (void (*)(void))p_scossl_##alg##_keymgmt_free},                       \
+        {OSSL_FUNC_KEYMGMT_LOAD, (void (*)(void))p_scossl_##alg##_keymgmt_load},                       \
+        {OSSL_FUNC_KEYMGMT_GET_PARAMS, (void (*)(void))p_scossl_##alg##_keymgmt_get_params},           \
+        {OSSL_FUNC_KEYMGMT_GETTABLE_PARAMS, (void (*)(void))p_scossl_##alg##_keymgmt_gettable_params}, \
+        {OSSL_FUNC_KEYMGMT_SET_PARAMS, (void (*)(void))p_scossl_##alg##_keymgmt_set_params},           \
+        {OSSL_FUNC_KEYMGMT_SETTABLE_PARAMS, (void (*)(void))p_scossl_##alg##_keymgmt_settable_params}, \
+        {OSSL_FUNC_KEYMGMT_HAS, (void (*)(void))p_scossl_##alg##_keymgmt_has},                         \
+        {OSSL_FUNC_KEYMGMT_MATCH, (void (*)(void))p_scossl_##alg##_keymgmt_match},                     \
+        {OSSL_FUNC_KEYMGMT_IMPORT, (void (*)(void))p_scossl_##alg##_keymgmt_import},                   \
+        {OSSL_FUNC_KEYMGMT_IMPORT_TYPES, (void (*)(void))p_scossl_##alg##_keymgmt_import_types},       \
+        {OSSL_FUNC_KEYMGMT_EXPORT, (void (*)(void))p_scossl_##alg##_keymgmt_export},                   \
+        {OSSL_FUNC_KEYMGMT_EXPORT_TYPES, (void (*)(void))p_scossl_##alg##_keymgmt_export_types},       \
+
+#define IMPLEMENT_SCOSSL_KEYMGMT_GEN_FUNCTIONS(alg)                                                       \
+        {OSSL_FUNC_KEYMGMT_GEN_INIT, (void (*)(void))##alg##_gen_init},                                   \
+        {OSSL_FUNC_KEYMGMT_GET_PARAMS, (void (*)(void))p_scossl_##alg##_get_params},                   \
+        {OSSL_FUNC_KEYMGMT_GEN_SET_PARAMS, (void (*)(void))p_scossl_##alg##_gen_set_params},           \
+        {OSSL_FUNC_KEYMGMT_GEN_SETTABLE_PARAMS, (void (*)(void))p_scossl_##alg##_gen_settable_params}, \
+        {OSSL_FUNC_KEYMGMT_GEN, (void (*)(void))p_scossl_##alg##_gen},                                 \
+        {OSSL_FUNC_KEYMGMT_GEN_CLEANUP, (void (*)(void))p_scossl_##alg##_gen_cleanup},                 \
+
+#define SCOSSL_KEYMGMT_FUNCTIONS_END \
+        {0, NULL}};                  \
+
+#ifdef __cplusplus
+}
+#endif
\ No newline at end of file
diff --git a/SymCryptProvider/src/p_scossl_signature.h b/SymCryptProvider/src/p_scossl_signature.h
new file mode 100644
index 0000000..336e24f
--- /dev/null
+++ b/SymCryptProvider/src/p_scossl_signature.h
@@ -0,0 +1,40 @@
+//
+// Copyright (c) Microsoft Corporation. Licensed under the MIT license.
+//
+
+#include <openssl/core_dispatch.h>
+#include "scossl_helpers.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+// Prototype definition, subject to change
+#define IMPLEMENT_SCOSSL_SIGNATURE(alg)                                                                                   \
+    const OSSL_DISPATCH p_scossl_##alg##_signature[] = {                                                               \
+        {OSSL_FUNC_SIGNATURE_NEWCTX, (void (*)(void))p_scossl_##alg##_sig_sig_newctx},                                 \
+        {OSSL_FUNC_SIGNATURE_SIGN_INIT, (void (*)(void))p_scossl_##alg##_sig_sig_sign_init},                           \
+        {OSSL_FUNC_SIGNATURE_SIGN, (void (*)(void))p_scossl_##alg##_sig_sig_sign},                                     \
+        {OSSL_FUNC_SIGNATURE_VERIFY_INIT, (void (*)(void))p_scossl_##alg##_sig_sig_verify_init},                       \
+        {OSSL_FUNC_SIGNATURE_VERIFY, (void (*)(void))p_scossl_##alg##_sig_sig_verify},                                 \
+        {OSSL_FUNC_SIGNATURE_DIGEST_SIGN_INIT, (void (*)(void))p_scossl_##alg##_sig_sig_digest_sign_init},             \
+        {OSSL_FUNC_SIGNATURE_DIGEST_SIGN_UPDATE, (void (*)(void))p_scossl_##alg##_sig_sig_digest_signverify_update},   \
+        {OSSL_FUNC_SIGNATURE_DIGEST_SIGN_FINAL, (void (*)(void))p_scossl_##alg##_sig_sig_digest_sign_final},           \
+        {OSSL_FUNC_SIGNATURE_DIGEST_VERIFY_INIT, (void (*)(void))p_scossl_##alg##_sig_sig_digest_verify_init},         \
+        {OSSL_FUNC_SIGNATURE_DIGEST_VERIFY_UPDATE, (void (*)(void))p_scossl_##alg##_sig_sig_digest_signverify_update}, \
+        {OSSL_FUNC_SIGNATURE_DIGEST_VERIFY_FINAL, (void (*)(void))p_scossl_##alg##_sig_sig_digest_verify_final},       \
+        {OSSL_FUNC_SIGNATURE_FREECTX, (void (*)(void))p_scossl_##alg##_sig_sig_freectx},                               \
+        {OSSL_FUNC_SIGNATURE_DUPCTX, (void (*)(void))p_scossl_##alg##_sig_sig_dupctx},                                 \
+        {OSSL_FUNC_SIGNATURE_GET_CTX_PARAMS, (void (*)(void))p_scossl_##alg##_sig_sig_get_ctx_params},                 \
+        {OSSL_FUNC_SIGNATURE_GETTABLE_CTX_PARAMS, (void (*)(void))p_scossl_##alg##_sig_sig_gettable_ctx_params},       \
+        {OSSL_FUNC_SIGNATURE_SET_CTX_PARAMS, (void (*)(void))p_scossl_##alg##_sig_sig_set_ctx_params},                 \
+        {OSSL_FUNC_SIGNATURE_SETTABLE_CTX_PARAMS, (void (*)(void))p_scossl_##alg##_sig_sig_settable_ctx_params},       \
+        {OSSL_FUNC_SIGNATURE_GET_CTX_MD_PARAMS, (void (*)(void))p_scossl_##alg##_sig_sig_get_ctx_md_params},           \
+        {OSSL_FUNC_SIGNATURE_GETTABLE_CTX_MD_PARAMS, (void (*)(void))p_scossl_##alg##_sig_sig_gettable_ctx_md_params}, \
+        {OSSL_FUNC_SIGNATURE_SET_CTX_MD_PARAMS, (void (*)(void))p_scossl_##alg##_sig_sig_set_ctx_md_params},           \
+        {OSSL_FUNC_SIGNATURE_SETTABLE_CTX_MD_PARAMS, (void (*)(void))p_scossl_##alg##_sig_sig_settable_ctx_md_params}, \
+        {0, NULL}};
+
+#ifdef __cplusplus
+}
+#endif
\ No newline at end of file
-- 
2.39.2

